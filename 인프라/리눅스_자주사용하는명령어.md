# 리눅스 자주 사용하는 명령어

```
$ cat (파일 보기)

$ cd (디렉터리 이동)

$ chmod (권한 변경)
$ chmod [OPTIONS] (reference)(operator)(modes) FILE

$ chown (소유 변경, 소유자:그룹)
$ chown [OPTIONS] USER[:GROUP] FILE(s)
$ chown root FILE
$ chown root:staff FILE
$ chown -hR root FILE

$ chgrp (그룹 변경)
$ chgrp [변경할 소유그룹] FILE

$ cp (파일 복사)

$ crontab (crontab 관리)

$ finger (사용자 정보 보기)

$ free (메모리 정보 보기)

$ gpasswd (그룹 사용자 관리)

$ grep (문자열 검색)

$ groupadd (그룹 추가)

$ groupdel (그룹 삭제)

$ groupmod (그룹 정보 수정)

$ groups (그룹 보기)

$ iptables (방화벽 관리 도구)

$ kill (프로세스 종료)
```

## 현재 생성되어 있는 그룹 보기

```
$ tail /etc/group

사용자가 속한 그룹 보기

$ id <user>

또는

$ groups <user>
```

## 파일 권한

rwxr-xr-x

r(읽기, 2의 2승) / w(쓰기, 2의 1승) / x(실행, 2의 0승) - 2진수

첫번째(소유자 접근 권한) / 두번째(그룹 접근 권한) / 세번째(그외 사용자 접근 권한)

rwxr-xr-x

소유자 : rwx , 그룹 : r-x , 공개 : r-x

소유자는 읽기(r),쓰기(w),실행(x)을 허용

그룹에 속하고 있는 사용자들은 읽기(r),실행(x)만 허용

나머지 모든 사용자들도 읽기(r),실행(x)만 허용

---

## 기본셀

```
$ echo $SHELL
```

## 실행 경로 보기

```
$ which node
```

## 실행 중인 프로세스 확인

```
$ ps -ef
```

## 실행(리슨) 중인 포트 확인

```
$ netstat -an | grep 8080
```

## 서버 실행 상태 한눈에 보기

```
$ top
```

## 명령어에 조건 넣기

- ; - 앞의 명령어가 실패해도 다음 명령어가 실행
- && - 앞의 명령어가 성공했을 때 다음 명령어가 실행
- & - 앞의 명령어를 백그라운드로 돌리고 동시에 뒤의 명령어를 실행
- || - 앞에서부터 순차적으로 실행하되, 명령 실행에 성공하면 뒤에 오는 명령을 실행하지 않는다.

## 특정 포트 사용중 여부 확인

```
$ sudo lsof -i :포트번호
$ sudo lsof -i :3000
```

## 서버 OS 및 버전 정보

```
$ cat /etc/redhat-release
CentOS release 6.7 (Final)
```

## 서버 비트확인

```
$ getconf LONG_BIT
64
```

## node 또는 tomcat 강제 종료

```
$ ps -ef | grep node

$ kill -9 3582 3589

$ kill -9 `ps -ef | grep ‘프로세스명(예를 들어 “/usr/src/nodejs/story/server.js”)’ | awk '{print $2}'`
```

kill -9 프로세스 ID로 프로세스 중지.
ps -ef 프로세스 전체출력.
grep 'PROCESS_NAME' 프로세스 이름 검색.
awk '{print $2}' 위에서 검색된 줄에서 2번째 항목(PDI) 출력.
ps명령어에 aux 옵션을 주면 CPU, MEM사용률, 프로세스 상태 코드 등 확인 가능. (ps -ef, ps aux 둘 다 두번째 필드는 PID)

## 프로세스명이 일치하는 경우 (killall)

```
$ killall -9 PROCESS_NAME
또는 원하는 프로세스만 죽이기
$ pkill -9 -ef my_process
```

## nohup 명령어

리눅스, 유닉스에서 쉘스크립트파일 (_.sh)을 데몬형태로 실행시키는 프로그램
터미널 세션이 끊겨도 실행을 멈추지 않고 동작하도록 함
nohup으로 실행할 쉘스크립트파일 (_.sh)은 현재 퍼미션이 755 이상 상태여야 함.

```
$ chmod 755 shell.sh
```

실행

```
$ nohup shell.sh &
$ nohup sh -- ./shell.sh &
```

종료

```
$ “ps -ef | grep 쉘스크립트파일명” 명령으로 데몬형식으로 실행

$ "kill -9 PID번호“ 명령으로 해당 프로세스 종료
```

$ ./run &
$ nohup ./run &
위 둘의 차이
nohup 으로 실행하면 hang-up signal 이 와도 동작하기 때문에 터미널 연결이 끊어져도 실행을 멈추지 않습니다.
& 은 백그라운드로 돌린다는 의미이며, 기본적으로는 nohup 이 아닐 경우 터미널이 끊어지면 실행도 끊어집니다. 
하지만 요즘 옵션에 nohup 과 같은 동작을 하게 설정이 되어 있어서 & 만으로도 nohup 과 같은 동작을 보입니다.
만약 nohup명령어로 직접 만든 스크립트를 실행하고자 하는데 명령어를 입력한 후 엔터를 치면 exit이 나온다면 스크립트에 에러가 있어 종료가 되는 것입니다.

## 환경변수 목록

```
$ env
```

환경변수 값 출력

```
$ echo ${HOME}
```

## 심볼릭 링크

```
$ ln -s [원본 파일 또는 디렉토리] [심볼릭 링크 이름]
```

## 리드링크

https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_readlink  
심볼릭링크의 원본을 찾는 명령어

```
$ readlink /usr/cc
```

## 권한변경

```
$ chown -R ysm:makegroup <폴더 또는 파일>

$ chmod -R 775 <폴더 또는 파일>
```

## 그룹

```
$ groupadd <추가할 그룹명>

$ gpasswd -a <그룹에 추가할 사용자> <그룹>

$ groupadd makegroup

$ gpasswd -a jenkins makegroup

$ gpasswd -a <배포폴더사용자> makegroup

$ chown -R <배포폴더사용자>:makegroup ./test-build/

$ chmod -R 775 ./test-build/
```

## 그룹에 소속된 사용자 리스트 정보

```
$ getent group makegroup

또는 전체

$ cat /etc/group
```

## 톰캣 소유권(그룹) 설정

```
$ cd /usr/local/server

$ chown -R root:makegroup apache-tomcat-8.5.11

(심볼릭 링크 폴더가 있을 경우, 함께 수정)

$ chmod -R g+w logs/

$ chmod -R g+rx conf/
```

## git 사용자로 로그인

```
$ su git
```

## 홈디렉토리로 이동

```
$ cd ~
```

## 용량 확인

```
$ df -h
```

## 파일 용량으로 검색

```
$ find ./\* -size +1048576k

c : byte
k : kbyte
```

## OS 비트확인

```
$ getconf LONG_BIT

64
```

## 리눅스 상태 파악

https://b.luavis.kr/server/linux-performance-analysis

```
$ uptime
uptime은 현재 대기중인 프로세스가 얼마나 있는지를 나타내는 load average값을 확인하는 가장 쉬운 방법

$ dmesg | tail
dmesg는 시스템 메세지를 확인할 수 있는 커맨드

$ vmstat 1
virtual memory stat의 약자인 vmstat은 왠만한 환경에서 사용 가능한 툴이다. 1을 인자로 준 vmstat은 1초마다 정보를 보여준다. 첫번째 라인은 부팅된 뒤에 평균적인 값을 나타낸다.
확인해봐야할 항목

- r: CPU에서 동작중인 프로세스의 숫자입니다. CPU 자원이 포화(saturation)가 발생하는지 확인할때에 좋은 값입니다. . r 값이 CPU의 값보다 큰 경우에 포화되어 있다고 해석된다.
- free: free memory를 kb단위로 나타냅니다. free memory가 너무 자리수가 많은 경우 free -m를 이용하면 조금더 편하게 확인할 수 있다.
- si, so: swap-in과 swap-out에 대한 값입니다. 0이 아니라면 현재 시스템에 메모리가 부족한것이다.
- us, sy, id, wa, st: 모든 CPU의 평균적인 CPU time을 측정할 수 있다. 각각 user time, 커널에서 사용되는 system time, idle, wait I/O 그리고 stolen time순이다(stolen time은 hypervisor가 가상 CPU를 서비스 하는 동안 실제 CPU를 차지한 시간을 이야기한다.).

$ mpstat -P ALL 1
CPU time을 CPU 별로 측정

$ pidstat 1
pidstat은 process당 top명령을 수행하는것

$ iostat -xz 1
block device(HDD, SSD, …)가 어떻게 동작하는지 이해
확인해봐야할 항목

- r/s, w/s rkB/s, wkB/s: read 요청과 write 요청, read kB/s, write kB/s를 나타낸다. 어떤 요청이 가장 많이 들어오는지 확인해볼 수 있는 중요한 지표다. 성능 문제는 생각보다 과도한 요청때문에 발생하는 경우도 있기 때문이다.
- await: I/O처리 평균 시간을 밀리초로 표현한 값이다. application한테는 I/O요청을 queue하고 서비스를 받는데 걸리는 시간이기 때문에 application이 이 시간동안 대기하게 된다. 일반적인 장치의 요청 처리 시간보다 긴 경우에는 블럭장치 자체의 문제가 있거나 장치가 포화된 상태임을 알 수 있다.

$ sar -n DEV 1
network throughput(Rx, Tx KB/s)을 측정

$ sar -n TCP,ETCP 1
TCP 통신량을 요약
```
