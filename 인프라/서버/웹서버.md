# 웹 서버와 웹 클라이언트

WWW를 통한 하이퍼텍스트의 공개와 열람은 구체적으로 웹서버와 웹클라이언트라는 소프트웨어로 구현된다.

일반적으로 서버에 대한 클라이언트의 요구를 요청(request), 클라이언트에 대한 서버의 반응을 응답(response)이라고 한다.

현재 웹 서버용 소프트웨어로는 오픈소스로 공개된 아파치 HTTP 서버(Apache HTTP Server)와 마이크로소프트사의 IIS(Internet Information Services)가 널리 이용되고 있다.

- HTTP 통신 관련 (다른 글 참고)

# URL (Uniform Resource Locator)

URL은 크게 세 부분으로 나눌 수 있다.

## 스킴(Scheme)

스킴은 리소스를 취득하기 위한 방법을 나타낸다.  
웹 애플리케이션에서는 대부분의 경우 http(HTTP 프로토콜을 사용해 가져오는 것)가 된다.  
스킴은 RFC1738이라는 문서에 규정돼 있는데, http 외에도 여러가지가 있다.

- https : 암호화된 http통신을 나타내는 스킴
- mailto : 이메일의 수취인을 나타내는 스킴
- ftp : FTP프로토콜을 통한 파일 획득을 나타내는 스킴
- file : 파일 시스템 속의 파일이나 디렉터리를 참조하기 위한 스킴

## 호스트명

리소스가 존재하는 호스트(컴퓨터)의 이름을 나타낸다.  
네트워크에 접속되어 다른 컴퓨터로부터 요구를 받고 처리한 결과를 되돌려주는 컴퓨터를 일반적으로 호스트 컴퓨터라고 한다. 여기서 말하는 호스트명은 호스트 컴퓨터의 이름을 가리킨다.  
호스트명은 로컬명과 부모 도메인명으로 나뉜다. 부모 도메인은 해당 호스트가 존재하는 조직을 나타내며, 로컬명은 그 조직 안의 컴퓨터에 붙은 이름을 나타낸다.

- co.kr(Korea) : 한국의
- makestory : makestory 라는 조직의
- www : www서버라는 컴퓨터

## 경로명

호스트명에서 지정된 컴퓨터상의 리소스의 위치를 나타낸다.

# HTTP

웹 서버와 웹 클라이언트가 통신하기 위한 공통된 프로토콜(약속)

# CGI의 탄생 (동적인 콘텐츠에 대한 요구)

## 동적 콘텐츠

웹클라이언트 -> 요청 -> 웹서버 -> 웹서버상에서 작동하는 프로그램이 HTML을 생성해 돌려준다. -> 응답

## 정적 콘텐츠

웹클라이언트 -> 오쳥 -> 웹서버 -> 미리 준비된 HTML을 돌려준다. -> 응답

동적 콘텐츠를 생성해 웹 클라이언트에 보내려면 웹 서버와 콘텐츠를 생성하는 프로그램의 연동이 필요하다.  
그래서 고안된 것이 CGI(Common Gateway Interface)라는 구조이다.

CGI에서는 웹 서버가 클라이언트로부터 받은 요청을 웹 서버상에서 작동하는 프로그램에 보낸다.  
프로그램은 요청을 참조해 HTML을 생성한 다음 웹 서버에 돌려보낸다.

실제로 웹 서버상에서 작동해 콘텐츠를 생성할 목적으로 주로 이용되던 것은 펄(Perl) 이라는 프로그래밍 언어였다.  
또 규모가 거대하거나 빠른 속도가 요구될 때는 C언어로 작성한 프로그램이 활약했다.

# 서블릿의 등장 (CGI를 둘러싼 문제점)

첫째, 개발언어의 문제  
웹 애플리케이션에 요구되는 기능의 규모가 커지고 복잡해지면서 당시 주로 이용되던 펄로 그램을 제작하기가 어려워졌다.  
펄은 텍스트 처리에 강점이 있는 언어였기에 대규모 애플리케이션을 개발하는 데는 그다지 적합하지 않았다.  
또 규모가 크고 복잡한 애플리케이션을 개발하는 데 필수라고도 할 수 있는 객체지향 프로그래밍도 지원하지 않았다.

둘째, 성능 문제  
기존에는 웹 브라우저에서 요청이 도착할 때마다 CGI를 통해 프로세스를 기동했다.  
여기에는 조금 시간(수십 밀리초에서 수백 밀리초 단위이지만)이 걸리는데, 접속 수가 적을 때는 전혀 문제가 없지만  
하루 접속 수가 수만, 수십만에 이르는 사이트에서는 프로그램의 기동 처리가 많아져 요청을 따라잡지 못한다.

# 자바/서블릿의 탄생

웹 애플리케이션 개발이 이런 문제로 고민하고 있을 때 등장한 것이 썬 마이크로시스템즈의 제임스 고슬링(James Gosling)이 개발한 자바(Java)였다.  
자바는 객체지향 기능을 완벽히 지원해 대규모 시스템을 개발하기 용이하며, 당시 널리 사용되던 C언어와 문법이 매우 비슷했기 때문에 당시의 개발자들이 쉽게 받아들일 수 있었다는 장점도 있다. 또 멀티 스레드와 보안, 네트워크 통신 등 당시 중요성이 높아지던 기술을 표준화된 방식으로 지원했다는 점도 매력적이다.

자바 자체는 웹 애플리케이션을 위해 개발된 언어가 아니다. 그러나 웹 애플리케이션은 당시 기업의 시스템 개발에서도 주류가 되고 있었다.  
그래서 JavaEE(Java Enterprise Edition, 기업 시스템용 자바)의 일부로서 서블릿(Servlet)이라는 웹 애플리케이션 개발을 지원하기 위한 기능을 제공했다.

서블릿은 자바로 만들어진, HTML 등의 웹 콘텐츠를 생성하기 위한 프로그램으로, CGI를 경유해 기동하는 펄이나 C언어의 자바 버전에 해당한다.  
서블릿은 기본적으로 CGI와 같은 개념이지만 콘텐츠를 생성하는 언어가 자바이며 객체지향을 지원함으로써 대규모 애플리케이션 개발에 적합하다는 점, 웹서버와 같은 프로세스 속에서 콘텐츠를 생성하는 프로그램이 작동하기 때문에 CGI처럼 새로운 프로세스를 매번 기동할 필요가 없어 비교적 고속으로 작동한다는 이점이 있다.

# 자바로 애플리케이션을 개발할 때의 이점

자바에는 특정 운영체제나 하드웨어에 의존하지 않고 작동한다는 특징이 있다.  
자바는 C언어처럼 소스코드를 직접 컴퓨터의 기계어로 컴파일(컴퓨터가 이해할 수 있는 기계어로 번환하는 작업)하지 않고 JavaVM이라고 하는 가상 컴퓨터에서 동작하는 언어로 컴파일해 실행한다. 그래서 JavaVM(Java Virtual Machine)이 작동하는 컴퓨터라면 어디에서나 프로그램을 실행할 수 있다.

다만 서블릿은 그것을 동작시키는 웹 컨테이너를 설치하기가 웹 서버만 설치하는 경우에 비해 조금 어렵고, 자바로 프로그램을 만들려면 객체지향에 관한 지식이 필요하다는 점에서 개인은 이용하길 꺼리는 경향이 있다.

# JSP의 탄생 (서블릿의 문제점)

대규모 사이트에서는 프로그래밍하는 사람과 화면의 디자인을 담당하는(HTML을 작성하는) 사람이 분담해 작업하는 일이 많다.  
그렇게 할 경우, 화면의 디자인을 변경할 때마다 프로그램을 변경하야 한다면 작업 효율이 나빠진다. 또 프로그래밍 지식이 없는 웹 디자이너는 실수로 프로그램을 망가트릴 우려가 있다는 위험성도 있다.  
또 다른 문제도 있다. 서블릿을 통해 출력되는 HTML을 상상하기 어렵다는 점이다.  
서블릿은 자바의 출력 명령을 사용해 HTML의 문자열을 출력하는 방식이었다. 그래서 프로그램이 길어지거나 출력할 HTML이 복잡해지면 HTML을 변경하려고 해도 수정해야 할 부분을 찾기조차 쉽지 않다.

이런 상황을 조금이라도 개선하기 위해 고안된 것이 JSP(Java Server Pages)라는 기술이다.  
JSP에서는 동적으로 출력하고 싶은 부분을 <%, %>로 묶고 그 안에 자바 프로그램을 기술할 수 있다. 이와 같이 JSP 내부에 적힌 자바 프로그램을 스크립틀릿(Scriptlet)이라고 한다.

- 서블릿: Java안에 HTML 출력
- JSP: HTML안에 Java 출력

# 서블릿과 JSP의 문제점 (웹 애플리케이션 프레임워크의 시대)

웹 애플리케이션 개발 기술 덕분에 간단한 웹 애플리케이션을 만들기가 매우 편해졌다. 그러나 실제 개발 현장에서는 아직 웹 애플리케이션을 개발하는 데 어려움이 있었다. 웹 애플리케이션의 규모가 엄청나게 커졌기 때문이다.  
대규모 애플리케이션을 처음부터 서블릿이나 JSP로 만들면 코딩 분량이 엄청나며, 완성되기까지 막대한 시간과 돈이 든다.

또 시스템의 규모가 커지면서 개발에 관여하는 사람의 수도 점점 늘어났다. 그런 상황에서는 개발자가 독자적인 라이브러리나 클래스를 만들고 나중에 결합하려고 했을 때 결합이 잘 되자 않거나 디자인팀과 개발팀의 성과물을 연결하는 과정에서 불협화음이 일어나는 식의 문제가 나타난다.

소프트웨어 개발을 건축에 비유한다. 개집 정도라면 혼자서 못과 망치만 가지고도 문제없이 지을 수 있다.  
그러나 고층 빌딩을 지을 때는 많은 사람의 팀워크와 튼튼한 지반, 우수한 중장비가 있어야 한다. 고층 빌딩을 지으려면 서블릿이나 JSP만으로는 아직 부족한 것이다.

재사용할 수 있는 부분을 늘려 애플리케이션 개발을 용이하게 하는 토대로 만들어진 것이 프레임워크다.  
프레임워크는 애플리케이션의 기반이 되는 것으로, 프레임워크를 토대로 필요한 부분을 만들어 나가면 원하는 애플리케이션을 단기간에 개발할 수 있다.

# 서블릿/JSP를 작동시키기 위한 애플리케이션 서버

JavaVM 상에서는 애플리케이션 서버(Application Server)라고 하는 소프트웨어가 작동되고 있으며,  
이 애플리케이션 서버가 서블릿이나 JSP를 작동시키는 구조로 돼 있다.

웹 서버와 웹 애플리케이션을 실행하는 프로세스가 다르다는 점에서는 CGI와 애플리케이션 서버가 똑같다.  
다만 CGI는 웹 서버로 요청이 도착할 때마다 새로운 프로세스가 기동됐다가 종료되는 '1회용 모델'이고,  
애플리케이션 서버는 데이터베이스와 마찬가지로 항상 프로세스가 실행되고 있으면서 웹 서버로부터 요청을 받아 서블릿이나 JSP를 실행하는 재사용 모델이라는 점이 크게 다르다.

- 아파치(HTTP)는 기본적으로 정적인 데이터(이미지, html 등) 처리, WAS(Web Application Server)는 동적인 데이터(JSP, 서블릿 등) 처리

# PHP는 어떻게 실행되는가? (CGI와 모듈의 차이)

PHP 스크립트를 실행하는 프로그램(PHP 엔진이라고 한다)은 웹 서버의 프로그램에 '모듈'이라는 형태로 탑재돼 있다.  
웹서버에 아파치라고 하는 소프트웨어가 설치돼 있고, PHP 엔진은 이 아파치에 대한 모듈로 탑재돼 있다.  
아파치는 HTTP 요청을 받으면 자신에게 등록된 모듈에서 요청을 처리하게 된다.

PHP 모듈이 탑재돼 있으면 디스크에서 읽은 파일을 조사해 <?PHP ... ?> 로 묶인 부분을 PHP 스크립트로 인식하고 실행한다.  
또 그 외의 부분은 그대로 응답으로 되돌려주게 된다.

CGI의 경우는 범용적인 인터페이스이므로 대부분의 웹 서버에서 이용할 수 있다.  
그러나 모듈 방식은 각 웹서버 제품에 대응하는 모듈이 필요하다. 예를 들어 PHP 엔진인 mod_php5는 아파치용 모듈이므로 마이크로소프트의 IIS에서는 사용할 수 없다. 실제로 펄이나 PHP 등 유명한 언어는 아파치용과 IIS용이 각각 준비돼있으므로 이용하는 측에서는 그다지 불편함이 없다.  
그러나 모듈 개발자로서는 여러 웹 서버 제품에 대응하는 모듈을 개발해야 한다는 단점이 있다.

# 웹 서버와 애플리케이션 서버의 연동

CGI는 웹 서버가 펄이나 C언어로 작성한 프로그램(프로세스)을 매번 기동해 결과를 받는 방식으로 연동했다.  
웹 서버와 애플리케이션 서버의 연동 방법은 딱히 표준적인 방법이 정해져 있지는 않다.

톰캣(Tpmcat)은 아파치 소프트웨어 재단(Apache Software Foundation)에서 개발한 오픈소스 애플리케이션 서버다.

웹 서버와 애플리케이션 서버는 다른 프로세스이므로 서로 연동하려면 어떤 식으로든 통신을 해야한다.  
일반적으로 애플리케이션 서버 측이 주요 웹 서버별로 연동용 모듈을 마련해 그 모듈은 웹 서버에 탑재함으로써 상호 연동을 가능하게 했다.  
톰캣의 경우는 아파치용으로 mod_jk라고하는 연동 모듈(아파치나 IIS 등의 웹 서버는 확장 모듈을 탑재해 본래의 기능을 확장할 수 있는 구조로 돼있다.)을 제공하며, 이것을 아파치의 확장 기능으로 탑재해 연동을 구현한다.

구체적으로는 아파치에 도착한 HTTP 요청을 mod_jk가 톰캣으로 전송하고, 이것을 톰캣이 그 기반에서 작동하는 웹 애플리케이션에 전달한다.  
웹 애플리케이션은 지금까지와 마찬가지로 요청을 바탕으로 처리를 실행하며, 결과를 애플리케이션 서버로 되돌려준다.  
애플리케이션 서버는 이전과 반대 경로로 mod_jk에 결과를 되돌려주며, 최종적으로 아파치가 웹 브라우저로 HTTP응답을 되돌려 준다.

mod_jk와 톰캣 사이의 통신은 HTTP가 아니라 ajp13이라고 하는 톰캣 고유의 프로토콜로 한다. 이것은 독자 규격이지만 HTTP보다 효율이 좋은 프로토콜을 이용함으로써 아파치와 톰캣 사이의 통신을 고속화하려는 목적이다.

- 프로세스를 항상 실행해 놓는 것을 '상주시킨다'라고 표현한다. 또 특히 UNIX 세계에서는 상주 프로그램을 데몬(Daemon)이라고 부른다.  
  이것은 악마(Demon)라는 뜻이 아니라 그리스 신화에 나오는 수호신의 이름에서 유래했다. 데몬은 신들이 시달리고 싶어 하지 않는 잡일을 처리하는 존재였다고 하는데, 이것이 '눈에 띄지 않는 곳에서 잡일을 처리해 주는 존재'라는 의미가 된 것이다.

# 웹 서버와 애플리케이션 서버의 분담 (정적, 동적의 분담)

웹 서버와 애플리케이션 서버를 연동할 경우, 통상적인 HTML 파일이나 이미지, 동영상 등 정적 콘텐츠만으로 구성된 페이지는 웹 서버상에 배치하고 동적 콘텐츠인 웹 애플리케이션은 애플리케이션 서버가 담당하는 식으로 분담한다.

그러나 HTTP 요청을 발행하는 클라이언트(웹 브라우저)로서는 페이지에 따라 요구를 보낼 프로세스가 제각각이라면 골치가 아플 수밖에 없다.  
그래서 보통은 클라이언트의 HTTP요청을 웹 서버가 전부 받아들이고 URL에 따라 애플리케이션 서버가 처리해야할 요청만 애플리케이션 서버에 보낸다.

# 웹 서버와 애플리케이션 서버 연동의 이점

웹 서버와 애플리케이션 서버를 다른 프로세스로 분리시켜 놓으면 애플리케이션 서버를 별도의 노드에서 작동시킬 수도 있다.  
ajp13은 HTTP와 마찬가지로 TCP/IP의 기반에서 만들어진 프로토콜이므로 서로 다른 노드 사이에서도 통신이 가능하다.

웹 서버와 애플리케이션 서버가 실행해야 하는 작업량을 비교하면 일반적으로 애플리케이션 서버의 작업량이 더 많다.  
웹 서버는 HTTP 요청에서 지정된 파일을 웹브라우저에 되돌려주기만 하면 되는 데 비해 애플리케이션 서버에서 웹 애플리케이션이 온갖 작업을 처리하기 때문이다.

웹 서버와 애플리케이션 서버를 다른 노드에 배치하면 처리량은 가벼운 대신 횟수가 많은 정적 콘텐츠에 대한 요청은 웹 서버,  
횟수는 적지만 처리량이 무거운 동적 콘텐츠에 대한 요청은 애플리케이션 서버와 같은 식으로 다른 성격의 요청을 적절히 분담시킬 수 있다.

웹 클라이언트 -> 웹서버(스타일시트, 자바스크립트, 이미지 등 정적처리) -> 애블리케이션 서버(동적 HTML 처리) -> DB 서버(데이터 처리)

# 웹 서버의 기능을 가진 애플리케이션 서버

사실 대부분의 애플리케이션 서버는 웹 서버 기능도 가지고 있다. 굳이 아파치와 같은 웹 서버와 연동하지 않아도 단독으로 웹 서버로 작동시킬 수 있는 것이다.  
이 같은 구성은 그다지 규모가 크지 않은 웹 시스템이나 웹 애플리케이션 개발 환경(개발한 애플리케이션의 작동 확인이나 테스트를 위한 환경)에 자주 활용된다. 다만 애플리케이션 서버는 웹 서버로서 최소한의 기능밖에 제공하지 않을 때가 많으며, 아파치처럼 다양한 기능을 제공하지는 않는다.

# 웹 시스템의 삼층 구성

각 서버를 별개의 노드에 배치한다.  
웹 클라이언트(브라우저) <-> 웹 서버(아파치 등) <-> 웹 애플리케이션서버(톰캣 등) <-> DB 서버(MySQL 등 DBMS)
