# Node.js

https://nodejs.org/en/docs

https://hanamon.kr/nodejs-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/

`Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임`  
Node.js는 확장성 있는 네트워크 애플리케이션 개발에 사용되는 소프트웨어 플랫폼

즉, 노드를 통해 다양한 자바스크립트 애플리케이션을 실행

Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능을 가지고 있는 것이 특징
내장 HTTP 서버 라이브러리를 포함하고 있어 웹 서버에서 아파치 등의 별도 소프트웨어 없이 동작하는 것이 가능

## 자바스크립트 런타임

- `런타임`이란 `특정 언어로 만든 프로그램을 실행할 수 있는 환경`을 뜻한다.
- 따라서 `노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 하는 자바스크립트 실행기`이다.
- 특히 2008년 구글이 V8 엔진을 사용하여 크롬을 출시했고 V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨라 라이언 달(Ryan Dahl)은 2009년 V8 엔진 기반의 노드 프로젝트를 시작하며 세상에 나왔다.

(즉, 프로그래밍언어 JavaScript 가 구동되는 환경)
(JavaScript 언어를 사용해 HTTP 요청/응답을 처리하도록 만들면, 웹서버 형태로 Node.js 를 사용한다는 것)

---

# Node.js

1. 이벤트 기반 (Event-Driven)

Node.js는 이벤트 기반의 비동기적인 프로그래밍 모델을 채택하고 있습니다.  
이는 애플리케이션이 이벤트에 반응하고 이벤트 루프를 통해 비동기적으로 작업을 수행할 수 있도록 합니다.  
이벤트 기반 구조는 높은 확장성을 제공하며, 동시에 많은 연결을 처리할 수 있는 서버 애플리케이션을 만들기에 적합합니다.

2. 비동기적인 I/O 처리 (Asynchronous I/O)

Node.js는 비동기적인 I/O 처리를 통해 여러 작업을 병렬로 처리할 수 있습니다.  
이는 블로킹되는 작업이 다른 작업들에게 영향을 미치지 않도록 하며, 전체 시스템의 성능을 향상시킵니다.  
비동기 I/O는 파일 시스템 액세스, 네트워크 요청 등과 같은 작업에서 특히 유용하며, 애플리케이션의 응답 시간을 최소화하는 데 기여합니다.

3. 단일 스레드 (Single-Threaded)

Node.js는 단일 스레드 이벤트 루프를 사용합니다.  
이는 간단하게 말하면 한 번에 하나의 작업만을 처리한다는 의미입니다.  
비록 단일 스레드이지만 비동기 I/O 처리를 통해 다중 작업을 효율적으로 수행할 수 있으며, 이는 높은 확장성을 유지하면서도 자원 사용을 최적화할 수 있게 해줍니다.

4. 모듈화 (Modularity)

Node.js는 CommonJS와 함께 모듈 시스템을 도입하여 코드를 모듈로 나누고 재사용할 수 있도록 지원합니다.  
모듈화를 통해 코드의 유지보수성이 향상되고, 각 모듈이 독립적으로 개발 및 테스트될 수 있습니다.

---

# 멀티 스레드(Multithreaded) 구조와 싱글 스레드 이벤트 루프(Single Threaded Event Loop) 구조의 차이점

`study.git/SW공학_컴퓨터구조/코어_스레드_클러스터.md` 참고!

https://mygumi.tistory.com/154

## 우선 멀티 스레드 기반의 HTTP 요청/응답 모델을 보자. (Spring + JSP)

- 클라이언트는 웹 서버에게 요청을 보낸다.
- 웹 서버는 내부적으로 제한된 스레드 풀을 관리하여 클라이언트의 요청에 서비스를 제공한다.
- 웹 서버는 무한 루프에 있으며, 클라이언트의 요청을 기다리는 중이다.
- 웹 서버는 요청들을 받아들인다.
  - 웹 서버는 하나의 요청을 가져온다.
  - `스레드 풀로부터의 하나의 스레드에 가져온다.`
  - 이 스레드에 요청이 할당된다.
  - 이 스레드가 요청을 읽고 처리한다. (요청 처리, Blocking I/O 가 있다면 수행, 응답 준비) - DB 또는 File 시스템을 사용할 경우, Blocking I/O 수행
  - 이 스레드는 준비된 응답을 다시 웹 서버에게 보낸다.
  - 웹 서버는 이 응답을 클라이언트에게 보낸다.

서버는 무한 루프에서 기다리고, 모든 클라이언트 요청을 위의 단계로 수행한다.
여기서는 하나의 요청이 하나의 스레드를 생성하는 것을 의미한다.

만약 많은 요청들이 Blocking I/O를 요구한다면, 거의 모든 스레드는 응답 준비중이다.
그 결과, 나머지 클라이언트 요청은 더 오랜 시간을 기다리게 된다.

멀티 스레드 구조의 단점은 아래와 같다.

- 점점 더 많은 동시에 발생하는 클라이언트의 요청을 처리하는 것이 어렵다.
- 동시에 발생하는 클라이언트의 요청이 증가할 때, 많은 스레드를 이용해야하기 때문에 많은 메모리를 사용하게 된다.
- 때때로, 클라이언트의 요청은 사용 가능한 스레드가 요청을 처리할 때까지 기다려야한다.
- Blocking I/O 작업으로 인해 시간이 낭비된다.

## 이번에는 Node.js의 싱글 스레드 기반의 구조를 살펴보자.

- 클라이언트는 웹 서버에게 요청을 보낸다.
- Node.js의 웹 서버는 내부적으로 제한된 스레드 풀을 관리하여 클라이언트의 요청에 서비스를 제공한다.
- `Node.js의 웹 서버는 클라이언트의 요청을 받아들이고, 큐 안에 배치한다. 이 큐를 이벤트 큐(Event Queue)라 부른다.`
- `Node.js의 웹 서버는 내부적으로 이벤트 루프(Event Loop)라 불리는 컴포넌트를 가진다.` 이름의 유래는 요청을 받아들이고 처리하는 것이 무한 루프를 사용하기 때문이다. (아래에 있는 Java 슈더 코드를 보면 이해하기 쉬울 것이다)
- `이벤트 루프는 싱글 스레드를 사용한다. 이것이 Node.js의 핵심이다.`
- `이벤트 루프는 이벤트 큐에 배치된 클라이언트의 요청을 확인한다.` 만약 없다면, 요청을 무한히 기다리게 된다.
- 만약 있다면, 이벤트 큐에 배치된 클라이언트의 요청을 가져온다.
  - 클라이언트 요청을 처리한다.
  - 만약 클라이언트 요청이 Blocking I/O 작업이 없다면, 모든 처리는 응답을 준비하고 클라이언트에 보낸다.
  - `만약 클라이언트 요청이 Blocking I/O 작업이 있다면,` - DB 또는 File 시스템을 사용할 경우, Blocking I/O 수행
    - `스레드 풀에서의 사용 가능한 스레드를 확인한다.`
    - `하나의 스레드를 가져와 요청을 할당한다.`
    - 이 스레드는 요청을 처리하고, 응답을 준비하고, 이벤트 루프에 보낸다.
    - 이벤트 루프는 클라이언트에게 응답을 보낸다.

싱글 스레드 이벤트 루프 방식의 장점은 아래와 같다.

- 점점 더 많은 동시에 발생하는 클라이언트의 요청을 처리하는 것이 쉽다.
- 동시에 발생하는 클라이언트의 요청이 증가할 때, 이벤트 루프를 이용하기 때문에 많은 스레드를 이용하지 않는다.
- 멀티 스레드 방식보다 스레드를 덜 이용하기 때문에 메모리 또는 자원 소모가 작다.

---

# `Node.js 교과서` 책 정리

# 동기외 비동기, 블로킹과 논 블로킹

동기와 비동기, 블로킹과 논 블로킹이라는 네 개의 용어가 노드에서 혼용되고 있으며, 의미도 서로 다릅니다.

- 동기와 비동기 : 백그라운드 작업 완료 확인 여부
- 블로킹과 논 블로킹 : 함수가 바로 return 되는지 여부  
  노드에서는 동기-블로킹과 비동기-논 블로킹 방식이 대부분입니다. 동기-논 블로킹이나 비동기-블로킹은 없다고 봐도 됩니다.

동기-블로킹 방식에서는 백그라운드 작업 완료 여부를 계속 확인하여, 호출한 함수가 바로 return 되지 않고 백그라운드 작업이 끝나야 return 됩니다.  
비동기-논 블로킹 방식에서는 호출한 함수가 바로 return 되어 다음 작업으로 넘어가며, 백그라운드 작업 완료 여부는 신경 쓰지 않고 나중에 백그라운드가 알림을 줄 때 비로소 처리합니다.

```javascript
// 동기-블로킹 방식
const fs = require('fs');

console.log('시작');
let data = null;

data = fs.readFileSync('./readme2.txt');
console.log('1번', data.toString());

data = fs.readFileSync('./readme2.txt');
console.log('2번', data.toString());

data = fs.readFileSync('./readme2.txt');
console.log('3번', data.toString());

console.log('끝');
```

```javascript
// 비동기-논 블로킹 방식
const fs = require('fs').promises;

console.log('시작');

fs.readFile('./readme2.txt')
  .then(data => {
    console.log('1번', data.toString());
    return fs.readFile('./readme2.txt');
  })
  .then(data => {
    console.log('2번', data.toString());
    return fs.readFile('./readme2.txt');
  })
  .then(data => {
    console.log('3번', data.toString());
    console.log('끝');
  })
  .catch(error => {
    console.error(error);
  });
```

---

# `한권으로 끝내는 Node & Express` 책 정리

# 스캐폴딩

p53

# 모범사례

p68

# 요청 / 응답 헤더

## 인터넷 미디어 타입

p107

## 요청 객체

p108

## 응답 객체

p110

# 서버 사이트 템플릿

p130

# 쿠키 세션

p157

## 자격 증명 위임

p159

# 미들웨어

p171

## 미들웨어 원칙

p172

# 앱 클러스터를 통한 스케일 아웃

# 지속성

p213

# 라우팅

p245

# 보안

## 인증서 직접 생성

p308

---
