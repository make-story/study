# `인프라` 기초 정리

> 참고 페이지  
> https://futurecreator.github.io/2018/11/09/it-infrastructure-basics/?fbclid=IwAR2wxDw7gzKCf6YXLAhyOt0PXtZ80A8sYfw2GeVyU9REpc94P8z9GmLCPXM

> IT 인프라  
> 애플리케이션을 가동시키기 위해 필요한 하드웨어나 OS, 미들웨어, 네트워크 등 시스템의 기반을 말합니다.

---

## 인프라 구성 요소

- 하드웨어(Hardware, HW):
  서버 장비 본체나 데이터를 저장하기 위한 스토리지, 전원 장치 등입니다. 넓은 의미에서는 이런 하드웨어를 설치하는 데이터 센터의 설비(건물, 공조, 보안 설비, 소화 설비 등)도 포함됩니다.
- 네트워크(Network) :
  사용자가 원격으로 접근할 수 있도록 서버를 연결하는 도구들입니다. 라우터, 스위치, 방화벽 등 네트워크 장비와 이를 연결하는 케이블 배선 등이 있습니다. 사용자가 단말에서 무선으로 연결할 때 필요한 액세스 포인트(Access Point, AP)도 있습니다.
- 운영체제(Operating System, OS) :
  하드웨어와 네트워크 장비를 제어하기 위한 기본적인 소프트웨어입니다. 리소스나 프로세스를 관리합니다.  
   - 클라이언트 OS : 사용자가 사용하기 쉽도록 하는데 초점을 맞추고 있습니다(Windows, macOS 등).  
   - 서버 OS : 시스템을 빠르고 안정적으로 실행하는데 초점을 맞추고 있습니다(Linux, Unix, Windows Server 등).
- 미들웨어(middleware) : 서버 상에서 서버가 특정 역할을 하도록 기능을 제공하는 소프트웨어입니다.

---

## 온프레미스 On-premises

데이터 센터나 서버실에 서버를 두고 직접 관리하는 방식

## 클라우드

- 퍼블릭 클라우드 Public Cloud  
  인터넷을 통해 불특정 다수에게 서비스 형태로 제공되는 시스템

- 프라이빗 클라우드 Private Cloud  
  이용자를 한정하여 제공되는 시스템

- 클라우드가 유리한 경우  
  트래픽의 변동이 많은 시스템은 클라우드 시스템이 유리합니다. 클라우드 시스템에서는 트래픽에 따라 자동으로 증설해주는 오토스케일링(Auto Scaling)이 있어 유리합니다.

- 하이브리드 클라우드 Hybrid Cloud  
  온프레미스와 클라우드를 함께 사용  
  https://cloud.google.com/anthos

## 하드웨어

- CPU  
  CPU가 직렬 처리에 최적화된 몇 개의 코어로 구성된 반면, GPU는 병렬 처리에 최적화된 작고 많은 코어로 이루어져 있습니다.  
  따라서 딥러닝이나 수치해석 등 대량의 데이터를 고속으로 처리해야하는 분야에서는 CPU와 GPU를 함께 사용해서 처리 성능을 높이는 GPU 컴퓨팅 방식이 사용됩니다.

- 데이터 스토리지  
  IT에서 가장 중요한 것은 데이터라고 할 수 있는데요. 이런 데이터가 손실되면 안되기 때문에 대부분 고가용성(High Availability, HA, 오랜 기간 동안 지속적으로 운영될 수 있음)을 위해 이중화(redundancy) 또는 다중화로 구성합니다. 이중화란 같은 장비 또는 시스템이 장애가 나는 것을 대비해 같은 모듈을 2개(또는 그 이상) 준비하는 것을 말합니다.

## 네트워크

- MAC 주소
  물리적으로 할당되는 48bit 주소

- IP 주소  
  인터넷이나 인트라넷 같은 네트워크에 연결된 장비에 할당되는 번호

## 리눅스

- 리눅스 커널 Linux Kernel
  커널이란 OS의 코어가 되는 부분을 말합니다. 메모리 관리, 파일 시스템, 프로세스 관리, 디바이스 제어의 역할을 합니다. 안드로이드(Android) 또한 리눅스 커널을 기반으로 만들어졌습니다.

- 디바이스 관리  
  리눅스 커널은 CPU, 메모리, 디스크, IO 등 `하드웨어를 디바이스 드라이버라는 소프트웨어를 이용해 제어`합니다.

- 프로세스 관리  
  리눅스는 프로그램 파일에 쓰여 있는 내용을 읽어서 메모리 상에서 처리하는데 이렇게 실행된 프로그램을 프로세스라고 합니다. 이 프로세스를 식별하기 위해 `PID(Process ID)`를 붙여서 관리하고 각 프로세스에 필요한 자원을 효율적으로 할당합니다.

- 메모리 관리  
  프로세스에 필요한 메모리를 할당하고 해제합니다. 다만 메모리가 부족한 경우에는 하드디스크와 같은 보조기억장치에 가상 메모리 영역을 만들어 사용하는데 이를 `스왑(swap)`이라고 합니다.

- 쉘 Shell  
  사용자는 쉘이라는 커맨드라인 인터페이스를 통해 명령어를 커널로 전달할 수 있습니다. 또한 쉘에서 실행하고자 하는 명령을 모아놓은 것을 `쉘 스크립트(shell script)`라고 합니다.  
   - bash  
   명령 이력, 디렉토리 스택, 명령이나 파일명의 자동 완성 기능 등을 지원하는 쉘.
  대부분의 Linux 시스템이나 macOS(OS X)에 표준으로 탑재되어 있다. - csh  
   C 언어와 비슷한 쉘. BSD 계열 OS에서 주로 사용한다. - tcsh  
   csh 를 개선한 버전으로 명령이나 파일명 등의 자동완성 기능 지원. - zsh  
   bash 와 호환성이 있고 고속으로 동작하는 쉘.

- 파일 시스템  
  파일 시스템이란 파일에 이름을 붙여서 어디에 저장할지 나타내는 체계입니다. 즉 파일을 관리하는 시스템입니다. 리눅스 커널은 `가상 파일 시스템(Virtual File System, VFS)을 사용`합니다. 사용자의 입장에서 각 데이터가 저장되어 있는 위치(하드디스크, 메모리, 네트워크 스토리지 등)와 상관없이 그냥 파일처럼 사용할 수 있도록 하는 것입니다. VFS에서는 각 디바이스를 파일로 취급합니다.

- 디렉토리 구성  
  리눅스의 디렉토리 목록은 `FHS(Filesystem Hierarchy Standard)라는 규격으로 표준화`되어 있습니다. 대부분의 주요 배포판은 이 FHS를 기반으로 디렉토리를 구성합니다. - `/`  
   루트 디렉토리 - `/bin`  
   ls, cp 같은 기본 커맨드를 저장하는 디렉토리. - `/boot`  
   리눅스 커널(vmlinuz) 등 OS 시작에 필요한 파일을 저장하는디렉토리. - `/dev`  
   하드디스크, 키보드, 디바이스 파일을 저장하는 디렉토리. - `/etc`  
   OS 나 애플리케이션의 설정 파일을 저장하는 디렉토리. - `/home`  
   일반 사용자의 홈 디렉토리. root 사용자는 /root 를 홈 디렉토리로 사용. - `/proc`  
   커널이나 프로세스에 대한 정보가 저장하는 디렉토리. - `/proc`  
   하위에 있는 숫자 폴더는 프로세스 ID를 의미. - `/tmp`  
   일시적으로 사용하는 파일을 저장하는 임시 디렉토리. 서버를 재시작하면 사라짐. - `/usr`  
   각종 프로그램이나 커널 소스를 저장하는 디렉토리 - `/sbin`  
   시스템 관리용 마운트를 저장하는 디렉토리. - `/var`  
   시스템 기동과 함께 변하는 파일을 저장하는 디렉토리.

- 계정에 대한 권한 설정  
  리눅스는 사용자 계정에 권한을 설정할 수 있습니다. 시스템 전체를 관리하는 root 사용자와 그 외 일반 사용자가 있습니다. 또한 미들웨어와 같은 데몬을 작동시키기 위한 시스템 계정도 있습니다. 계정은 그룹으로 묶을 수도 있습니다. 이런 `계정과 그룹을 바탕으로 파일이나 디렉토리에 대한 액세스 권한(permission)을 설정`할 수 있습니다.

- 네트워크 필터링  
  리눅스는 원래 네트워크 상에서 여러 사용자가 이용하는 것을 전제로 만든 OS 이므로 네트워크 관련 기능이 많습니다. `iptables는 리눅스에 내장된 패킷 필터링 및 NAT를 설정할 수 있는 기능`입니다.

- SELinux(Security-Enhanced Linux)  
  SELinux는 미국 국가안전보장국이 제공하는 리눅스 커널에 강제 액세스 제어 기능을 추가한 기능입니다. 리눅스는 root 사용자가 퍼미션에 상관없이 모든 액세스가 가능해서 root 계정이 도난당하면 시스템에 치명적인 영향을 줄 수 있는 단점이 있는데요. SELinux는 프로세스마다 액세스 제한을 거는 TE(Type Enforcement)와 root 를 포함한 모든 사용자에게 제어를 거는 RBAC(Role-based Access Control) 등으로 root 에게 권한이 집중되는 것을 막아줍니다.

- 리눅스 배포판 Linux Distribution  
  보통 리눅스는 커널 위에 각종 커맨드, 라이브러리, 애플리케이션 등을 포함해 배포판이라는 패키지 형태로 배포됩니다.  
  https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg

## 미들웨어 Middleware

미들웨어는 OS와 비즈니스를 처리하는 애플리케이션 사이에 들어가는 각종 소프트웨어를 말합니다. 웹 서버, DBMS, 시스템 모니터링 툴 등이 있습니다.

## 웹 서버 Web Server

웹 서버는 클라이언트가 보낸 HTTP 요청을 받아 웹 콘텐츠를 응답으로 반환하거나 서버쪽 애플리케이션을 호출하는 기능을 가진 서버입니다.

## DBMS

데이터 베이스 관리 시스템(Database Management System, DBMS)은 데이터베이스를 관리하는 미들웨어입니다. 데이터의 CRUD(Create, Read, Update, Delete)와 같은 기본 기능과 트랜잭션 처리 등 많은 기능을 포함합니다.

## 시스템 모니터링 System Monitoring

시스템 운영을 위해서는 여러 상태를 지속적으로 감시해야 합니다. 네트워크, 서버, 클라우드, 애플리케이션, 서비스, 트랜잭션 등 다양한 레벨에서 모니터링을 하면서 이상 여부를 확인하고 원인을 분석합니다.

- Zabbix  
  Zabbix SIA 가 개발한 오픈 소스 모니터링 툴. 다양한 서버의 상태를 모니터링 가능
- Datadog  
  Datadog 가 개발한 서버 모니터링 SaaS. 따로 서버를 도입할 필요 없이 웹 브라우저에서 모니터링 가능. 멀티 클라우드 환경에서도 손쉽게 모니터링이 가능.
- Mackerel  
  Hatena 가 개발한 서버 모니터링 SaaS. 클라우드 서버 모니터링에 유용.

## Immutable Infrastructure

온프레미스 환경에서는 인프라 환경을 구축하는 것도 큰 일이고, 일단 구축하면 변경 이력을 정리하면서 상당히 오랜 기간 사용합니다. 하지만 클라우드는 가상 환경이기 때문에 필요하면 구축하고 불필요하면 바로 폐기해도 상관 없습니다. 즉 `서비스가 업데이트되면 기존 운영 환경을 변경하는 대신 이미지를 새로 생성해 배포합니다. 이를 변경하지 않는다는 뜻의 Immutable Infrastructure` 라고 합니다.  
Immutable 인프라는 이미지 하나로 서버를 쉽게 찍어낼 수 있고 해당 이미지만 관리하면 되기 관리도 용이합니다. 또한 환경 자체를 배포하기 때문에 동일한 환경에서 테스트도 쉽습니다.

## Infrastructure as Code

새로 서버를 설치한다고 합시다. 온프레미스 환경에서는 물리 서버나 네트워크 장비를 데이터 센터에 설치한 후 여러가지 설정을 해야 합니다. 만약 서버 100대를 수작업으로 설정한다면 어떨까요? 단순 반복 작업이라 시간도 오래 소요될 뿐더러 수작업으로 하다보면 실수가 나올 수도 있습니다.

또한 이후 OS 와 미들웨어의 버전 관리 및 보안 패치 적용을 생각했을 때 구성 관리를 효율적으로 하는 것이 앞으로의 운영 효율을 높이는 데 중요합니다. 이력이 제대로 관리되지 않으면 버전 정보와 설정 항목을 적어놓은 파라미터 시트와 값이 맞질 않아서 제대로 동작하지 않는 경우가 있습니다.

그래서 `수작업 대신 프로그램 코드를 기반으로 관리`하는 것이 좋습니다다. 이렇게 하면 편하고 작업 실수도 줄일 수 있을 뿐더러 Git 과 같은 버전 관리 소프트웨어를 이용해 변경 이력을 관리할 수 있습니다. 이렇게 `코드 기반으로 인프라 구성을 관리하는 방식을 Infrastructure as Code` 라고 합니다.

## 인프라 구성 관리 툴

- Bootstrapping : OS 시작을 자동화
  - 서버 OS 를 설치, 가상 환경 설정, 네트워크 구성 설정 등
  - Vagrant
- Configuration : OS 나 미들웨어의 설정을 자동화
  - OS 설정, 각종 미들웨어 설치 및 설정
  - Ansible, Chef, Puppet
- Orchestration : 여러 서버 관리를 자동화
  - Kubernetes : 컨테이너 오케스트레이션의 사실 살 표준(de facto standrad). 줄여서 k8s 라고도 부름.

## Continuous Integration 와 인프라

http://www.pepgotesting.com/continuous-integration/  
지속적인 통합은 제대로 동작하는 코드를 자동으로 유지하기 위한 방법입니다. CI 환경이 구성되어 있지 않으면 빌드가 깨지는 경우도 많고 심지어 깨진 걸 모르는경우도 있습니다. `CI 환경에서 개발자가 코드를 커밋하면 Jenkins 와 같은 인테그레이션 툴이 코드 커밋을 감지해 자동으로 빌드와 테스트를 수행하고 코드 품질을 점검합니다. 문제가 있을 경우 해당 개발자에게 피드백이 가서 빠르게 조치하고 좋은 품질의 코드를 계속 유지할 수 있습니다.`

단위 테스트를 통과한 모듈이 다른 환경에서도 똑같이 동작한다는 보장은 없습니다. 각종 설정이나 네트워크, 권한 등 인프라 환경에 의존하는 부분이 많은데요, 이러한 부분을 코드로 관리한다면 개발 멤버가 항상 동일한 환경에서 개발할 수 있어 테스트가 쉽고 환경 구성 관리가 더욱 쉬워집니다.

## Continuous Delivery 와 인프라

폭포수 모델에서는 처음 요구사항을 정의하는 시기와 실제로 SW를 고객에게 전달(delivery)하는 시기가 워낙 차이가 나다보니 문제가 생기곤 합니다. 물론 그 과정에서 고객이 아예 관여하지 않는 것은 아니지만, 대규모 프로젝트의 경우 몇 년이 소요되기도 하다보니 계속 변화하는 고객의 생각과 니즈를 충족시키기 어렵습니다.

고객의 입장에서는 시간이 지나면서 다른 기능이 계속 눈에 들어오다보니 실제 결과물이 마음에 차지 않게 되고, 개발하는 입장에서는 처음에 말한대로 다 만들었는데 개발 막바지에 수정이나 추가 개발을 해야하는 상황이 되는 것이죠.

그래서 서로를 만족시키기는 방법은 고객의 니즈는 변한다는 것을 인정하고, 그 대신 개발 사이클 자체를 짧게 해서 개발과 릴리즈를 반복하는 것입니다. `실제로 동작하는 SW 를 고객에게 주기적으로 딜리버리함으로써 고객의 피드백을 받고 반영하는 것을 Continuous Delivery 라고 합니다.`

그런데 지속적으로 딜리버리(배포0하는 과정에서 테스트 환경과 실제 운영 환경이 달라서 문제가 발생하기도 합니다. 인프라 환경도 포함한 애플리케이션 실행 환경을 그대로 제품 환경에 딜리버리할 수 있다면 안전하게 버전업을 할 수 있게 됩니다.

## 가상화 Virtualization

https://www.redhat.com/ko/topics/virtualization/what-is-virtualization  
가상화란 쉽게 말해 `컴퓨터 안에 독립적인 컴퓨터를 만드는 것`입니다. 왜 컴퓨터 안에 컴퓨터를 만들까요? 주요한 목적 중 하나는 물리적인 리소스를 여러 사용자 또는 환경에 배포해서 제한된 리소스를 최대한 활용하기 위함입니다.

## 호스트형 서버 가상화

http://www.govmlab.com/news-section-3/  
`하드웨어 위에 호스트 OS 를 설치하고 OS에서 가상화 SW를 이용해 게스트 OS를 작동시키는 기술`입니다. 가상화 SW 를 설치하면 쉽게 가상 환경을 구축할 수 있기 때문에 개발 환경 구축 등에 주로 사용합니다. 오라클의 Virtual Box 나 VMware 가 있습니다.

하지만 OS 상에서 또 다른 OS 가 돌아가므로 자원이 많이 소비되고 느리다는 단점이 있습니다.

## 하이퍼바이저형 가상화

https://www.docker.com/resources/what-container  
`하드웨어 상에 가상화를 전문적으로 수행하는 SW 인 하이퍼바이저(Hypervisor)를 올라가는 방식`입니다. 이 하이퍼바이저가 하드웨어와 가상 환경을 제어합니다. 호스트 OS 가 없어져서 조금 덜 부담되지만 그래도 각 VM(Virtual Machine)마다 게스트 OS 가 돌아가기 때문에 가상 환경 시작에 걸리는 오버헤드가 커집니다. 클라우드의 가상 머신에서도 사용하는 방법입니다.

## 컨테이너 Container

https://www.docker.com/resources/what-container  
컨테이너는 오버헤드를 최소화하기 위한 방법입니다. `호스트 OS 상에 독립적인 공간을 만들고 별도의 서버인 것처럼 사용`합니다. 따라서 각 컨테이너는 같은 호스트 OS 를 공유하기 때문에 오버헤드가 적고 고속으로 동작합니다. 항구의 컨테이너처럼 안에 필요한 것을 모두 담고 다른 컨테이너와 격리시켜놓은 것이라고 볼 수 있습니다.

컨테이너는 애플리케이션 실행에 필요한 모듈을 하나로 모을 수 있기 때문에 여러 개의 컨테이너를 조합해서 하나의 애플리케이션을 구축하는 마이크로서비스와 잘 맞습니다.

- 도커 Docker  
  https://foxutech.com/how-to-build-a-docker-image-using-jenkins/how-to-build-a-docker-image-using-jenkins-2/  
  도커는 `애플리케이션 실행에 필요한 환경을 이미지로 만들고 해당 이미지를 활용해 다양한 환경에서 실행 환경을 구축하기 위한 오픈소스 플랫폼`입니다. 도커는 내부에서 컨테이너를 사용합니다.

일반적인 개발 환경에서는 잘 동작하다가 갑자기 스테이징이나 운영 환경으로 가면 동작하지 않는 경우가 있습니다. 이런 인프라 환경을 도커를 이용해 컨테이너로 관리하면 어떨까요? 필요한 것을 모두 컨테이너로 모아서 이미지로 만드는 것입니다.

- 쿠버네티스 Kubernetes  
  실제 애플리케이션은 여러 컨테이너에 걸쳐 있고 이러한 컨테이너는 여러 서버에 배포되어 있습니다. 이렇게 `여러 대의 서버나 하드웨어를 모아서 한 대처럼 보이게 하는 기술을 클러스터링(clustering)`이라고 합니다. 이를 통해서 가용성과 확장성을 향상시킬 수 있습니다.

이런 `멀티호스트 환경에서 컨테이너를 클러스터링하기 위한 툴을 컨테이너 오케스트레이션 툴`이라고 합니다. 오케스트레이션 툴은 컨테이너들을 클러스터링하기 위해 `컨테이너 시작 및 정지와 같은 조작, 호스트 간 네트워크 연결, 스토리지 관리, 컨테이너를 어떤 호스트에서 가동시킬지와 같은 스케줄링 기능을 제공`합니다.

---
