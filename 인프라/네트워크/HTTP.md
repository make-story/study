그림으로 배우는 Http & Network Basic

# 웹은 HTTP로 나타낸다

서버에 의뢰를 하는 웹브라우저 등을 클라이언트(Client)라고 부릅니다.
클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 웹에서 HTTP(HyperText Transfer Protocol)이라 불리는 프로토콜입니다.
프로토콜이라는 의미는 "약속"입니다. 즉, 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있습니다.

HTTP/0.9
HTTP가 등장한 때는 1990년인데, 이 당시 HTTP가 정식 사양서는 아니었습니다. 이 당시 등장한 HTTP는 1.0 이전이라는 의미에서 HTTP/0.9로 불리고 있습니다.

HTTP/1.0
HTTP가 정식 사양으로 공개된 것은 1996년 5월 이었습니다. 이 때 HTTP/1.0으로 RFC1945가 발행되었습니다.
초기의 사양이지만 현재에도 아직 많은 서버상에서 현역으로 가동되고 있는 프로토콜 사양입니다.
http://www.ietf.org/rfc/rfc1945.txt

HTTP/1.1
1997년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전입니다.
그 당시의 사양은 RFC2068이지만 개정판으로 발행된 RFC2616이 최신버전 입니다.
http://www.ietf.org/rfc/rfc2616.txt

HTTP는 등장한 당시에 주로 텍스트를 전송하기 위한 프로토콜이었지만, 프로토콜 자체가 상당히 심플해서 여러 가지 응용 방법을 고려해 기능이 계속해서 추가되었습니다.

# 네트워크의 기본은 TCP/IP

인터넷을 포함하여 일반적으로 사용하고 있는 네트워크는 TCP/IP라는 프로토콜에서 움직이고 있습니다. HTTP는 그 중 하나입니다.

계층으로 관리하는 TCP/IP
TCP/IP에서 중요한 개념 중 하나가 계층(Layer)입니다. TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '데이터링크 계층', '링크 계층' 이렇게 4계층으로 나뉘어 있습니다.

TCP/IP가 계층화된 것은 메리트가 있기 때문입니다.
예를 들면, 인터넷이 하나의 프로토콜로 되어 있다면 어디선가 사양이 변경되었을 때 전체를 바꾸지 않으면 안되지만,
계층화되어 있으면 사양이 변경된 해당 계층만 바꾸면 됩니다.
각 계층은 계층이 연결되어 있는 부분만 결정되어 있어, 각 계층의 내부는 자유롭게 설계할 수 있습니다.

> 모듈화, MVC패턴 등 각각 역할로 구분하는 것과 같음

## 애플리케이션 계층

애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정하고 있습니다.
TCP/IP에는 여러 가지의 공통 애플리케이션이 준비되어 있습니다. 예를 들면, FTP랑 DNS 등도 애플리케이션의 한 가지 입니다. HTTP도 이 계층에 포함됩니다.

## 트랜스포트 계층

트랜스포트 계층은 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공합니다.
트랜스포트 계층에서는 서로 다른 성질을 가진 TCP(Transmission Control Protocol)와 UDP(User Data Protocol) 두 가지 프로토콜이 있습니다.

네트워크 계층(혹은 인터넷 계층)
네트워크 계층은 네트워크 상에서 패킷의 이동을 다룹니다. 패킷이란 전송하는 데이터의 최소 단위입니다.
이 계층에서는 어떠한 경로(이른바 절차)을 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 합니다.
인터넷의 경우라면 상대 컴퓨터에 도달하는 동안에 여러 대의 컴퓨터랑 네트워크 기기를 거쳐서 상대방에게 배송됩니다. 그러한 여러 가지 선택지 중에서 하나의 길을 결정하는 것이 네트워크의 역할입니다.

링크 계층(혹은 데이터 링크 계층, 네트워크 인터페이스 계층)
네트워크에 접속하는 하드웨어적인 면을 다룹니다. 운영체제가 하드웨어를 제어하기 때문에 디바이스 드라이버랑 네트워크 인터페이스 카드(NIC)를 포함합니다. 그리고 케이블 등과 같이 물리적으로 보이는 부분(커넥트 등을 포함한 여러 가지 전송 매체)도 포함합니다.
하드웨어 측면은 모두 링크 계층의 역할입니다.

TCP/IP 통신의 흐름
[그림] 23p

배송을 담당하는 IP
IP(Internet Protocol)는 계층으로 말하자면 네트워크 층에 해당됩니다.
IP는 TCP/IP라는 명칭의 일부가 될 정도로 중요한 프로토콜입니다. 'IP' 와 'IP주소'를 혼동하는 사람이 있는데 'IP'는 프로토콜의 명칭입니다.
IP의 역할은 개개의 패킷을 상대방에게 전달하는 것입니다. 상대발에게 전달하기까지 여러 가지 요소가 필요합니다. 그 중에서도 IP주소와 MAC주소(Media Access Control Address)라는 요소가 중요합니다.
IP 주소는 각 노드에 부여된 주소를 가리키고 MAC주소는 각 네트워크 카드에 할당된 고유의 주소입니다. IP주소는 MAC주소와 결부됩니다. IP주소는 변경 가능하지만 기본적으로 MAC주소는 변경할 수 없습니다.

통신은 ARP를 이용하여 MAC주소에서 한다.
IP통신은 MAC주소에 의존해서 통신을 합니다. 인터넷에서 통신 상대가 같은 랜선 내에 있을 경우는 적어서 여러 대의 컴퓨터와 네트워크 기기를 중계해서 상대방에게 도착합니다. 그렇게 중계하는 동안에는 다음으로 중계할 곳의 MAC 주소를 사용하여 목적지를 찾아가는 것입니다.
이 때, ARP(Address Resolution Protocol)이라는 프로토콜이 사용됩니다.
ARP는 주소를 해결하기 위한 프로토콜 중 하나인데, 수신지의 IP주소를 바탕으로 MAC주소를 조사할 수 있습니다.

신뢰성을 담당하는 TCP
TCP(Transfer Control Protocol)는 계층으로 말하자면 트랜트포트 층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공합니다.
바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말하고, 신뢰성 있는 서비스는 상대방에게 보내는 서비스를 의미합니다.
결국 TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하고 상대에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있습니다.

상대에게 데이터를 확실하게 보내는 것이 일이다.
상대에게 확실하게 데이터를 보내기 위해서 TCP는 "쓰리웨이 핸드셰이킹(three way handshaking)"이라는 방법을 사용하고 있습니다.
이 방법은 패킷을 보내고 나서 바로 끝내는 것이 아니라, 보내졌는지 여부를 상대에게 확인하러 갑니다. 이것은 'SYN'와 'ACK'라는 TCP 플래그를 사용합니다.

이름 해결을 담당하는 DNS
DNS는 도메인명에서 IP주소를 조사하거나 반대로 IP주소로부터 도메인명을 조사하는 서비스를 제공하고 있습니다.

URI는 리소스 식별자
URI(Uniform Resource Identifiers)는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소(네트워크 상의 위치)를 나타냅니다. URL은 URI의 서브셋입니다.

# 리퀘스트와 리스폰스를 교환하여 성립

HTTP는 클리이언트로부터 리퀘스트(요청, Request)가 송신되며, 그 결과가 서버로부터 리스폰스(응답, Response)로 되돌아옵니다.
즉, 반드시 클라이언트측으로부터 통신이 시작됩니다. 서버 측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일은 없습니다.
서버 측은 리퀘스트를 수신하지 않으면 리스폰스가 발생하는 경우는 없습니다.

HTTP는 상태를 유지하지 않는 프로토콜
HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜입니다.
HTTP 프로토콜 독자적으로, 리퀘스트와 리스폰스를 교환하는 동안에 상태(state)를 관리하지 않습니다. 결국, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않습니다.
HTTP에서는 새로운 리퀘스트가 보내질 때 마다 새로운 리스폰스가 생성됩니다. 프로토콜로서는 과거의 리퀘스트나 리스폰스 정보를 전혀 가지고 있지 않습니다.

> 상태를 계속 유지하고 싶은 요구에 부응하기 위해서 쿠키(Cookie)라는 기술이 도입되었습니다.

쿠키를 사용한 상태 관리
HTTP는 스테이트리스(stateless) 프로토콜이기 때문에, 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않습니다.
결국, 과거 상태를 근거로해서 현재 리퀘스트를 처리한다는 것은 불가능합니다.
쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템입니다.
쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다.
다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신합니다. 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있습니다.

# 서버에 임무롤 부여하는 HTTP메소드

## GET: 리소스 획득 (1.0, 1.1)

GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구합니다.
가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과입니다. 결국 리소스가 텍스트이면 그대로 반환하고 CGI와 같은 프로그램이면 실행해서 출력된 내용을 돌려줍니다.

## POST: 엔티티 전송 (1.0, 1.1)

POST 메소드는 엔티티를 전송하기 위해서 사용됩니다.
GET으로도 엔티티를 전송할 수 있지만, 자주 사용하지 않고 일반적으로 POST를 사용합니다.
POST는 GET과 기능이 비슷하지만 리스폰스에 의한 엔티티를 획득하는 것만이 목적은 아닙니다.

## PUT: 파일 전송 (1.0, 1.1)

PUT 메소드는 파일을 전송하기 위해서 사용됩니다.
FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구합니다.
단지, HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않고 있습니다.
웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST(Representational State Transfer)와 같이 웹끼지 연계하는 설계 양식을 사용할 때 이용하는 경우가 있습니다.

## HEAD: 메시지 헤더 취득 (1.0, 1.1)

HEAD 메소드는 GET과 같은 기능이지만 메시지 바디는 돌려주지 않습니다.
URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용됩니다.

## DELETE: 파일 삭제 (1.0, 1.1)

DELETE 메소드는 파일을 삭제하기 위해 사용됩니다.
PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리스트의 삭제를 요규합니다.
단지, HTTP/1.1의 DELETE 자체이는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되고 있지 않습니다.
웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST를 사용하는 경우에 사용되는 경우가 있습니다.

## OPTIONS: 제공하고 있는 메소드의 문의 (1.1)

OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용됩니다.

## TRACE: 경로 조사 (1.1)

TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킵니다.
리퀘스트를 보낼 때에 "Max-Forwards" 라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 그 수치를 줄여갑니다.
수치가 0이 된 곳을 끝으로, 리퀘스트를 마지막으로 수신한 곳에서 상태 코드 200 OK 리스폰스를 되돌려 줍니다.
클라이언트는 TRACE 메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있습니다.
이것은 프록시 등을 중계하여 오리진(origin) 서버에 접속할 때 그 동작을 확인하기 위해서 사용되고 있습니다.
다만, TRACE 메소드는 거의 사용되지 않는데다 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되고 있지 않습니다.

## CONNECT: 프록시에 터널링 요구 (1.1)

CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용됩니다.
주로 SSL이랑 TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해서 사용되고 있습니다.

# 지속 연결로 접속량을 절약

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었습니다.
리퀘스트를 보낼 때마다 매번 TCP연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 됩니다.

한번에 한건에 대한 연결과 종료
TCP 커넥션 연결(쓰리웨이 핸드셰이킹) -> HTTP 리퀘스트 -> HTTP 리스폰스 -> TCP 커넥션 종료

HTTP/1.1와 일부 HTTP/1.0에서는 TCP 연결문제를 해결하기 위해서 지속연결(Persistent Connections)이라는 방법을 고안하였습니다.
지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP연결을 계속 유지합니다.
지속 연결을 하는 이점은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감됩니다. 또한, 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있습니다.
이러한 지속 연결은 HTTP/1.1 에서는 표준 동작이지만 HTTP/1.0 에서는 정식 사양이 아니었습니다.

한번 연결되면 리퀘스트/리스폰스가 끝날 때까지 종료안함
TCP 커넥션 연결(쓰리웨이 핸드셰이킹) -> HTTP 리퀘스트 -> HTTP 리스폰스 -> HTTP 리퀘스트 -> HTTP 리스폰스 -> TCP 커넥션 종료
[그림] 56p

파이프라인화
지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인(HTTP pipelining)화를 가능하게 합니다.
파이프라인에 의해서, 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 리스폰트를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있습니다.
이로 인해, 여러 리퀘스트를 병행해서 보내는 것이 가능하기 때문에 일일이 리스폰스를 기다릴 필요가 없습니다.

리퀘스트에 대한 해당 리스폰스가 올 때까지 기다리지 않고, 다음 레퀘스트를 보낼 수 있음
[그림] 57p

# HTTP 메시지

HTTP에서 교환하는 정보는 HTTP 메시지라고 불리는데 리퀘스트 측 HTTP메시지를 리퀘스트 메시지,
리스폰스 측 HTTP 메시지를 리스폰스 메시지라고 부릅니다.

HTTP 메시지는 복수 행(개행 문자는 CR+LF)의 데이터로 구성된 텍스트 문자열입니다. HTTP 메시지는 크게 구분하면 메시지 헤더와 메시지 바디로 구성되어 있고, 최초에 나타나는 개행 문자(CR+LF)로 메시지 헤더와 메시지 바디를 구분합니다.
이 안에 메시지 바디가 항상 존재한다고는 할 수 없습니다.
[그림] 62p

리퀘스트 메시지와 리스폰스 메시지의 메시지 헤더 내부는 다음과 같은 데이터로 구성되어 있습니다.

## 리퀘스트 라인

리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함됩니다.

## 상태 라인

리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함됩니다.

## 헤더 필드

리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함됩니다.
일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드 등 4종류가 있습니다.

## 그 외

HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있습니다.

# 메시지 해더

HTTP프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함되어 있는데 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어 있습니다.

# 리퀘스트의 HTTP메시지

메소드, URI, HTTP버전, HTTP헤더필드 등으로 구성되어 있습니다.

## 메서드

GET, POST 등 메서드

## URI

URL 정보

## HTTP 버전

HTTP/1.0, HTTP/1.1, HTTP/2.0 과 같은 것

## Accept 헤더필드

웹 클라이언트가 받을 수 있는 데이터의 종류를 표시
Content-Type 형식으로 표시되며, 클라이언트가 받을 수 있는 Content-Type을 콤마로 구분해서 지정

## Accept-Language 헤더필드

웹 클라이언트가 받을 수 있는 자연 언어의 종류를 나타낸다. (예: ko-KR)

## User-Agent 헤더필드

이용 중인 웹 브라우저의 종류와 버전

## Host 헤더필드

요청을 보낸 곳의 호스트명과 포트 번호

# 리스폰스의 HTTP메시지

HTTP메시지와 HTTP버전, 상태코드(코드와 설명), HTTP헤더필드 등으로 구성되어 있습니다.

## 상태 라인

HTTP/1.1 200 OK
HTTP 버전, 상태코드, 응답 구문

## 메시지 헤더

HTTP 요청의 메시지 헤더와 같은 형식으로, 응답에 관한 부가적인 정보가 들어 있다.

## 메시지 본문

마지막으로 등장하는 것이 메시지 본문
HTML은 텍스트 형식이므로 우리가 읽을 수 있는 형식으로 메시지 본문에 저장돼 있다.
그러나 GIF나 JPEG 형식의 이미지 파일을 요청했을 경우에도 마찬가지로 그 데이터가 메시지 본문에 그대로 들어간다. (바이너리 형식)

# 압축해서 보내는 콘텐츠 코딩

메일에 파일을 첨부해서 보낼 경우 같이 용량을 줄이기 위해서 파일을 zip으로 압축하고 나서 첨부해서 보내는 일이 있습니다.
HTTP에는 이와 같은 일이 가능한 콘텐츠 코딩(Content Codings)이라고 불리는 기능이 구현되어 있습니다.
콘텐츠 코딩은 엔티티에 적용하는 인토딩을 가리키는데 엔티티 정보를 유지한채로 압축합니다.
콘첸트 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩합니다.

주요 콘텐츠 압축에는 다음과 같은 것이 있습니다.

- gzip (GNU zip)
- compress (UNIX의 표준 압축)
- deflate (zlib)
- identity (인코딩 없음)

# 분해해서 보내는 청크 전송 코딩

HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않습니다.
사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시할 수 있습니다.
이렇게 엔티티 바디를 분할하는 기능을 청크 전송 코딩(Chunked transfer Coding)이라고 부릅니다.

# 여러 데이터를 보내는 멀티파트

메일의 경우에는 메일의 본문이나 복수의 첨부 파일을 붙여서 함께 보낼 수 있습니다.
이것은 MIME(Multipurpose Internet Mail Extensions: 다목적 인터넷 메일 확장 사양)으로 불리는 메일로 텍스트나 영상, 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있습니다.

MIME는 이미지 등의 바이너리 데이터를 아스키(ASCII) 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있습니다.
이 MIME의 확장 사양에 있는 멀티파트(Multipart)라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있는 것입니다.

HTTP도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있습니다. 주로 이미지나 텍스트 파일 등을 업로드할 때 사용되고 있습니다.

# 일부분만 받는 레인지 리퀘스트

광대역의 네트워크를 이용할 수 있기 전에는 대용량의 이미지와 데이터를 다운로드하기가 힘들었습니다.
다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 해야 했기 때문입니다.
이러한 문제를 해결하기 위해서 일반적인 리줌(resume)이라는 기능이 필요하게 되었습니다.
리줌을 통해 이전에 다운로드를 한 곳에서 부터 다운로드를 재개할 수 있습니다.
이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있습니다. 이와 같이 범위를 지정하여 리퀘스트 하는 것을 레인지 리퀘스트(Range Request)라고 부릅니다.

# 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션

같은 콘텐츠(내용)이지만 여러 개의 페이지를 지닌 웹 페이지가 있습니다.
예를 들면, 내용은 같지만 영어판과 한국어판과 같이 표시되는 언어가 서로 다른 웹페이지의 경우 입니다.
이러한 웹 페이지에서는 영어와 한국어와 같이 서로 다른 언어를 주로 사용하는 브라우저가 같은 URI에 엑세스할 때에 각각 영어판 웹페이지와 한국어 웹페이지를 표시합니다.
이와 같은 구조를 콘텐츠 네고시에이션(Content Negotiation)이라고 부릅니다.

콘텐츠 네고시에이션이란 클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것입니다.
클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조입니다.
콘텐츠 네고시에이션은 제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등을 기준으로 판단하고 있습니다.

판단 기준은 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤더 필드입니다.

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

콘텐츠 네고시에이션에는 다음과 같은 종류들이 있습니다.

- 서버 구동형 네고시에이션 (Server-driven Negotiation)
  서버 측에서 콘텐츠 네고시에이션을 하는 방식입니다. 서버 측에서 리퀘스트헤더 필드의 정보를 참고해서 자동적으로 처리합니다.
  단지, 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한 것이 선택되었다고 할 수 없습니다.

- 에이전트 구동형 네고시에이션 (Agent-driven Negotiation)
  클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식입니다. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택합니다.
  JavaScript 등을 사용해서 웹 페이지에서 자동으로 이것을 정하는 것도 있습니다.

- 트랜스페어런트 네고시에이션 (Transparent Negotiation)
  서버 구동형과 에이전트 구동형을 혼합한 것으로 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식입니다.

# 상태 코드는 서버로부터 리퀘스트 결과를 전달한다.

클라이언트가 서버를 향해 리퀘스브를 보낼 때 서버에서 그 결과가 어떻게 되었는지 알려주는 것이 상태코드의 역할 입니다.

상태코드 클래스
1xx Informational 리퀘스트를 받아들여 처리중
2xx Success 리퀘스트를 정상적으로 처리했음
3xx Redirection 리퀘스트를 완료하기 위해서 추가 동작이 필요
4xx Client Error 서버는 리퀘스트 이해 불가능
5xx Server Error 서버는 리퀘스트 처리 실패

## 리다이렉트와 포워드의 차이

리다이렉트는 서버에서 클라이언트에 대해 일단 상태 코드 302를 되돌려줌으로써 이동할 곳의 URL을 알려 클라이언트에서 서버로 다시 HTTP요청을 발생하게 한다. 즉 HTTP요청이 두 차례 발생한다.
포워드는 애플리케이션 서버내에서만 이동 처리가 진행된다.

# 통신을 중계하는 프로그램: 프록시, 게이트웨이, 터널

## 프록시

서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램으로, 클라이언트로 부터의 리퀘스트를 서버에 전송하고,
서버로 부터의 리스폰스를 클라이언트에 전송합니다.

## 게이트웨이

다른 서버를 중계하는 서버로, 클라이언트로 부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신합니다.
경우에 따라서는 클라이언트는 상대가 게이트웨이라는 것을 알지 못하는 경우도 있습니다.

## 터널

서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램 입니다.

# 리소스를 보관하는 캐시

캐시(Cache)는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킵니다.
캐시를 사용하면 리소스를 가진 서버에의 액세스를 줄이는 것이 가능하기 때문에 통신량과 통신 시간을 절약할 수 있습니다.

캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류됩니다.
결국, 프록시가 서버로부터의 리스폰스를 중계하는 때에 프록시 서버상에 리소스의 사본을 보존합니다.

> 캐시는 유효시간이 있다.

# HTTP의 약점

- 평문(암호화 하지 않은)통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

# 암호화로 도청을 피하다

## 통신 암호화

HTTP에는 암호화 구조는 없지만 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security) 이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있습니다.
SSL 등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 합니다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure)나 HTTP overSSL이라 불리고 있습니다.

## 콘텐츠 암호화

HTTP에 암호화를 하는 기능은 없기 때문에 HTTP를 사용해서 운반하는 내용을 암호화하는 것입니다.
즉, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것입니다.

# 통신 상대를 확인하지 않기 때문에 위장 가능

HTTP를 사용한 리퀘스트나 리스폰스에서는 통신 상대를 확인하지 않습니다.
리퀘스트를 보낸 서버가 정말 URI에서 지정된 호스트인지 아난지, 리스폰스를 반환한 클라이언트가 정말로 리퀘스트를 출력한 클라이언트인지 아닌지를 모든다는 것입니다.

- 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹서버인지 아닌지를 확인할 수 없다. 위장한 웹 서버일 우려가 있다.
- 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 아닌지를 확인할 수 없다. 위장한 클라이언트일 우려가 있다.
- 통신하고 있는 상대가 접근이 허가된 상대인지 아닌지를 확인할 수 없다. 중요한 정보를 가진 웹서버에서는 특정 상대만 통신을 허가하고 싶을 때가 있다.
- 어디의 누가 리퀘스트를 했는지를 확인할 수 없다.
- 의미없는 리퀘스트라도 수신하게 된다. 대량의 리퀘스트에 의한 DoS 공격(서비스 불능 공격)을 방지할 수가 없다.

# 상대를 확인하는 증명서

HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있습니다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있습니다.
증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사살을 증명합니다. 또 그 증명서를 위조하는 것은 기술적으로 상당히 어렵습니다.
통신 상대의 서버나 클라이언트가 가진 증명서를 확인함으로써 통신 상대가 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있습니다.

# HTTP에 암호화와 인증과 안전성 보호를 더한 HTTPS

HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아닙니다. HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)이라는 프로토콜로 대체하고 있을 뿐입니다.

보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL와 통신하고 SSL이 TCP와 통신하게 됩니다.
즉, SSL이라는 껍질을 덮어쓴 HTTP가 HTTPS인 것입니다.

SSL 에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있습니다.

# 공통키 암호의 딜레마

암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키 암호라고 부릅니다.
네트워크를 이용해서 키를 넘겨줄 때 통신이 도청되어 공격자에게 키를 빼앗기게 되면 암호화의 의미가 없게 되어 버립니다.

# 두 개의 키를 사용하는 공개키 암호

공통키 암호의 문제를 해결하려고 한 것이 공개키 암호라는 방식입니다.
공개키 암호에서는 서로 다른 두 개의 키 페어(쌍)를 사용합니다. 한쪽은 비밀키(private key)라 부르고 다른 한쪽은 공개키(public key)라고 부릅니다.
이름대로, 비밀키는 누구에게도 알려지면 안되는 키이며 공개키는 누구에게나 알려져도 괜찮은 키입니다.

공개키 암호를 사용한 암호화는 암호를 보내는 측이 상대의 공개키를 사용해 암호화를 합니다.
그리고 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시합니다.
이 방식은 암호를 푸는 비밀키를 통신으로 보낼 필요가 없기 때문에 도청에 의해서 키를 빼앗길 걱정은 없습니다.

# 하이브리드 암호 시스템

키를 안전하게 교환할 수만 있다면 공개키 암호만을 사용해서 통신을 해도 괜찮다고 생각할 지도 모르지만, 공개키 암호는 공통키 암호에 비해서 처리 속도가 늦습니다.
거기서 두 가지 장점을 살릴 수 있도록 각각의 방식을 조합해서 통신합니다.
키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용합니다.

# 공개키가 정확한지 아닌지를 증명하는 증명서

아쉽게도 공개키 암호에도 문제점이 있습니다. 그 문제점은 공개키가 진짜인지 아닌지를 증명할 수 없다는 것입니다.
예를 들면, 어떤 서버와 공개키 암호를 사용해서 통신을 시작하려 할 때 수신한 공개키가 본래 의도한 서버가 발행한 공개키인지를 어떻게 증명할 수 있을 까요? 도중에 공격자가 공개키를 바꿔치기 했을지도 모릅니다.

이 문제를 해결하는 데는 인증기관(CA:Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다.
인증 기관이란 클라이언트와 서버가 모두 신뢰하는 제3자 기관입니다.

인증 기관은 다음과 같이 이용됩니다.
먼저 서버의 운영자가 인증 기관에 공개키를 제출합니다.
인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듭니다.
그리고 공개키 인증서에 서명이 끝난 공개키를 담습니다.

서버는 이 인증 기관에 의해서 작성된 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신을 합니다.
공개키 인증서는 디지털 증명서나 줄여서 증명서라고 부르는 경우도 있습니다.
증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 진짜 인증 기관이라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있습니다.

여기에서 사용되는 인증 기관의 공개키는 안전하게 클라이언트에 전달되지 않으면 안됩니다.
통신중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어렵기 때문에 많은 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 제품을 내놓고 있습니다.

# SSL은 느리다?

HTTPS에도 문제가 있습니다. 바로 SSL를 사용하면 처리가 늦어지게 된다는 점입니다.
SSL 통신이 지연되는 이유에는 두 가지가 있습니다. 하나는 통신 속도가 떨어지는 것과, 다른 하나는 CPU나 메모리 등의 리소스를 다량으로 소비함으로써 처리가 느려지는 것입니다.

네트워크의 부하는 HTTP를 사용하는 경우에 비해 2배에서 100배 정도 느려질 수 있습니다.
TCP 접속과 HTTP의 리퀘스트/리스폰스 이외에 SSL에 필요한 통신이 추가되기 때문에 전체적으로 처리해야 할 통신이 증가해 버립니다.

다른 하나는 SSL은 반드시 암호화 처리를 하고 있기 때문에 서버나 클라이언트에서는 암호화나 복호화를 위한 계산을 할 필요가 있습니다.
그렇기 때문에 서버나 클라이언트의 리소스를 소비하게 되어 HTTP에 비해 부담이 커집니다.

느려지는 것에 대한 근본적인 해결 방법은 없기 때문에, SSL 엑셀레이터라는 하드웨어(appliance 서버)를 사용해서 이 문제를 해결하기도 합니다.
SSL 엑셀레이터는 SSL을 처리하기 위한 전용 하드웨어로, 소프트웨어 SSL을 처리할 때보다 몇 배 빠른 계산을 할 수 있습니다.
SSL의 처리만 SSL 엑셀레이터에 맡김으로써 부하를 분산하도록 하고 있습니다.

---

# GET, POST 차이

GET 요청은 캐시가 가능
GET 요청은 브라우저 히스토리에 남음
GET 요청은 길이 제한 있음 (GET 은 URL 쿼리스트링 에 데이터를 담아 보내기 때문, 브라우저 마다 기준이 다름)

POST 요청은 캐시되지 않음
POST 요청은 브라우저 히스토리에 남지 않음
POST 요청은 데이터 길이에 제한이 없음 (POST 는 body 에 데이터를 담아 보내기 때문)
