`MySQL 퍼포먼스 최적화` 책 정리

- 구조
  서버엔진(Server Engine)은 클라이언트의 요청을 받아 SQL을 처리하는 DB자체의 기능적인 역할을 담당한다.
  스토리지엔진(Storage Engine)은 서버 엔진이 필요한 데이터를 물리 장치에서 가져오는 역할을 한다.

- 서버엔진
  서버 엔진은 사용자가 쿼리를 날렸을 때, DB가 SQL을 이해할 수 있도록 쿼리를 재구성하는 '쿼리파싱'과 디스크나 메모리 같은 물리적인 저장장치와 통신하는 스토리지 엔진에 데이터를 요청하는 업무를 담당한다.

또한, 스토리지 엔진에서 받아온 데이터를 사용자 요청에 맞게 처리하거나 접근 제어, 쿼리 캐시, 옵티마이저(SQL이 들어왔을 때 연관된 데이터를 빠르게 찾아내기 위해 최적의 실행을 유도하는 DB내부의 기능) 등의 역할을 수행한다.
즉, 물리적인 저장장치와 직접적으로 통신하는 역할을 제외하고 사용자와 MySQL 사이에서 발생하는 데이터 처리 프로페스의 대부분을 담당한다.

스토리지 엔진이 물리적인 저장장치에서 데이터를 읽어오는 역할을 수행한다면, 서버 엔진은 스토리지 엔진에서 가져온 데이터를 처리하는 역할을 담당한다.
Table Join, Group By, Order By와 같은 일반적인 SQL 처리부터 Function/Procedure, Trigger, Constraint 등과 같은 기능도 서버 엔진에서 수행된다.

- 스토리지 엔진
  스토리지 엔진은 물리적인 저장장치에서 데이터를 읽어오는 역할을 담당한다.
  MySQL은 다른 DBMS(Database Management System)와는 다르게 스토리지 엔진이 플러그인 방식으로 동작한다.
  (필요한 스토리지 엔진을 간단하게 설치하여 바로 사용할 수 있다.)
  플러그인 방식이기 때문에 여러 개의 스토리지 엔진을 설치하여 사용할 수도 있다(MySQL 5.5에서는 스토리지 엔진 8개가 기본적으로 설치되어 있다.)
  필요하다면 3rd Party 스토리지 엔진을 별도로 설치하여 사용할 수도 있다.

다음은 MySQL Community 버전(MySQL 5.5 기준)을 처음 설치했을 때 제공되는 스토리지 엔진이다.

> InnoDB
> MyISAM
> MRG_MYISAM
> BLACKHOLE
> CSV
> MEMORY
> FEDERATED
> ARCHIVE

서버 엔진은 스토리지 엔진의 API를 호출하며 실제 필요한 데이터를 요청하고 조작한다.
그래서 API에는 구현되어 있지만 스토리지 엔진에서는 지원하지 않는 경우도 있다. 예를 들어 InnoDB에서 인덱스 타입이 해시(Hash)로 정의하여 생성했는데, 실제 스토리지 엔진에서는 B-Tree 인덱스로 생성되는 경우다.

MySQL은 다른 상용 DBMS와는 다르게 DB엔진에 완벽하게 최적화되어 있지 않다.
이는 다양한 스토리지 엔진에서 동작할 수 있어야 하기 때문이다. 그래서 데이터처리가 일부 비효율적일 수도 있지만 확장성 면에서는 다른 어떠한 DBMS보다 유연하다. 지근도 새로운 플러그인이 개발되고 있기 때문에 어떤 DBMS보다 강력하다고 할 수 있다.

- MySQL에서 스토리지 엔진이란 무엇인가?
  MySQL의 가장 강력한 특징 중 하나가 바로 스토리지 엔진의 다양성이다.
  만약 스토리지 엔진별 특성을 이해하고 적재적소에 적용할 수 있다면 강력한 성능은 물론이고 장비 효율성도 높일 수 있다.
  반대로 서비스 특성에 맞지 않는 스토리지 엔진을 사용하면 예기치 않은 문제가 발생할 수도 있다.
  때로는 테이블 설계나 SQL작성보다 스토리지 엔진 선정전략이 전체 쿼리 수행 시간이나 장비 사용 효율에 큰 영향을 미치기도 한다.

- 주요 스토리지 엔진의 특징

|               | MyISAM | InnoDB     | Archive |
| ------------- | ------ | ---------- | ------- |
| 스토리지 제한 | 256TB  | 64TB       | None    |
| 트랜잭션      | No     | Yes        | No      |
| Locking레벨   | Table  | Row        | Row     |
| 인덱스        | B-Tree | B-Tree     | No      |
| Cache         | Index  | Data/Index | No      |
| 파티셔닝      | Yes    | Yes        | Yes     |
| Cluster Index | No     | Yes        | No      |
| Foreign Key   | No     | Yes        | No      |

- MyISAM 스토리지 엔진
  MyISAM은 MySQL에서 가장 오래된 스토리지 엔진이다. 파일 기반 스토리지 엔진이며 데이터에 대한 키, 즉 인덱스만 메모리에 올려서 처리한다.
  데이터는 메모리에 적재하지 않고 디스크에서 바로 접근한다.
  트랜잭션을 지원하지 않고 테이블 단위 잠금(Table Level Lock)으로 데이터 변경을 처리한다.
  따라서 특정 테이블의 여러 세션에서 데이터를 변경하면 성능이 상당히 저하된다. 특정 세션이 테이블의 데이터를 변경하는 동안 다른 세션은 앞선 변경작업이 끝날 때까지 대기하기 때문이다.

그렇다고 MyISAM이 다른 스토리지 엔진에 비해 성능이 뒤떨어지는 것은 아니다.
텍스트 전문을 검색할 수 있는 '풀텍스트 인덱싱(Fulltext Indexing)'과 지리 정보를 처리할 수 있는 '지오메트릭 스파셜 인덱싱(Geometric Spatial Indexing)' 같은 좋은 기능도 제공한다.
단, 풀텍스트 인덱싱과 지오메트릭 스파셜 인덱싱을 사용하면 테이블 파티셔닝을 사용할 수 없다는 제약이 있다.
MySQL은 애초에 저사양 서버에서 구동하기 위한 목적으로 고안된 스토리지 엔진이기 때문에 다양한 기법으로 데이터 사이즈를 줄인다.
그중 대표적인 방법이 프리픽스(Prefix)인덱스 압축 기법으로 키 사이즈를 최소화 한다.

프리픽스 인덱스 압축을 사용하면 키 사이즈는 대폭 줄어들고 메모리 효율은 높아진다.
그러나 키 역순으로 데이터를 찾아야 할 경우에는 성능 이슈가 있다. 원하는 데이터를 찾으려면 이전 단계에 저장된 인덱스 내용이 필요하다.
따라서 MyISAM은 로그 수집 또는 단순 SELECT에는 적합하나 동시 데이터 처리에는 한계가 있다.

- InnoDB 스토리지 엔진
  MySQL에서 유일하게 트랜잭션을 지원하는 스토리지 엔진으로, 일반적인 서비스에 가장 많이 사용하는 엔진이다.
  '다중 버전 동시성 제어 메커니즘(Multiversion Concurrency Control, MVCC)'을 제공하고 행 단위 잠금으로 데이터 변경 작업을 수행하기 때문에 연관이 없는 데이터를 다른 사용자가 변경할 수 있다.

MyISAM은 인덱스만 메모리에 올리지만 InnoDB는 인덱스와 데이터를 모두 메모리에 올린다는 것이 가장 큰 차이점이다.
메모리에 인덱스와 데이터가 적재되어 있기 때문에 메모리 버퍼 크기(InnoDB_Buffer_Pool_Size)가 DB 성능에 큰 영향을 미친다.

Primary Key는 '클러스터 인덱스(Cluster Index)'로 구성된다.
쉽게 풀어서 말하면 Primary Key 순서로 디스크에 저장되어 있다는 것을 의미한다.
만약 Primary Key가 정의되어 있지 않으면 Unique Key가 클러스터 인덱스로 구성된다.
Primary Key와 Unique Key가 테이블 내에 정의되어 있지 않으면 내부적으로 6바이트 크기의 키를 만들어서 Primary Key로 사용한다.
물론 사용자가 볼 수 있는 키 값은 아니다. 하지만 MySQL의 데이터 복제(Replication)기능을 사용하고 있는 중이라면 사용을 권고하지 않는다.
업데이트가 많은 서비스에서는 복제 데이터 동기화 지연이 발생할 수 있기 때문이다. Primary Key가 클러스터 인덱스로 구성되어 있기 때문에 데이터를 찾아가는 가장 빠른 경로는 Primary Key를 통해서 접근하는 것이다.

- Archive 스토리지 엔진
  로그 수집에 적합한 스토리지 엔진이다. 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장되기 때문에 행단위 잠금이 가능하다.
  단, 한번 INSERT 된 데이터는 UPDATE와 DELETE를 사용할 수 없으며 인덱스를 지원하지 않는다.
  모든 로그 수집에 적합한 엔진은 아니지만 원시로그, 즉 가공이 한 번 필요한 데이터 수집에는 상당히 효율적이다.
  테이블 파티셔닝도 지원하므로 일별 또는 월별로 데이터를 관리할 수 있다.

- 테이블 단위 잠금과 행 단위 잠금의 차이
  테이블 단위 잠금에서 특정 사용자가 데이터 입력/수정/삭제 작업을 수행하면 해당 테이블 전체에 잠금이 걸려 다른 사용자는 대기해야 한다.
  따라서 테이블 변경 작업을 동시에 하면 성능이 상당히 저하된다.

이에 반해 행단위 잠금은 변경하고자 하는 Row에만 락을 걸어 해당 Row를 제외한 다른 사용자의 데이터 변경 작업에 영향을 미치지 않는다. 테이블 단위 잠금과는 달리 테이블을 동시에 변경할 수 있다.

- MySQL에서는 모든 SQL을 단일코어에서 처리한다.
  MySQL은 SQL을 병렬 처리하지 않는다. 3rd Party스토리지 엔진을 설치하여 병렬 처리를 할 수 있지만,
  기본적인 스토리지 엔진은 단일 코어로만 데이터를 처리한다.

- MySQL은 테이블 조인을 Nested Loop Join 알고리즘으로만 처리한다.
  Nested Loop Join은 선행 테이블 A의 조건 검색 결과값 하나하나를 테이블 B와 비교하여 조인하는 방식이다.
  프로그램적으로 풀자면 for문 안의 for문과 유사하다.
  결국 처리할 데이터가 적으면 수행 속도가 빠르지만 테이블 A나 테이블 B중 하나라도 연산해야 할 데이터가 많아지면 쿼리 효율이 기하급수적으로 떨어진다.

* DB내부에서는 이것보다 한 단계 업그레이드된 'Block Nested Loop Join' 방식(조인 버퍼 개념을 도입)으로 처리한다. 테이블 조인 시 필요한 데이터를 메모리에 일시적으로 저장하여 효율적으로 데이터에 접근한다.

- 쿼리 실행 계획
  사람이 이해할 수 있는 언어로 구성된 SQL을 실행하도록 DB에 명령을 내리면 DB는 내부적으로 SQL파싱(SQL 문법 체크 및 DB에서 실행하기 위한 형태로 변환하는 단계)을 하고 옵티마이징(데이터를 찾는 가장 빠른 방법을 찾아내는 단계)을 거친 후 실제로 데이터를 찾는다.

쿼리 실행 계획이란 DB가 데이터를 찾아가는 일련의 과정을 사람이 알아보기 쉽게 DB결과셋으로 보여주는 것이다.
쿼리 실행 계획을 활용하여 기존의 쿼리를 튜닝할 수 있을 뿐만 아니라 성능 분석, 인덱스 전략 수립 등과 같이 성능 최적화에 대한 전반적인 업무를 처리할 수 있다.

실행할 쿼리 앞에 EXPLAIN

- 실행결과에 warning 이 있을 경우 'SHOW WARNINGS\G' 쿼리

EXPLAIN EXTENDED 는 실행한 쿼리가 실제 DB 내부적으로 어떻게 처리되는지를 알고자 할 때 유용한 명령어다.
읽는 순서는 두 가지다.
첫째, 동일한 아이디끼리는 위에서 아래 방향으로 향한다.
둘째, 위에서 아래로 향하는 도중 table 항목에 <drived번호> 항목을 만나면 번호에 해당하는 ID로 가서 첫 번째 단계를 수행한 후 돌아와서 나머지를 수행한다.

결과의 각 항목별 의미

> ID : Select 아이디로 Select를 구분하는 번호
> Select_type : Select에 대한 타입
> Table : 참조하는 테이블
> Type : 조인 혹은 조회 타입
> Possible_keys : 데이터를 조회할 때 DB에서 사용할 수 있는 인덱스 리스트
> Key : 실제로 사용할 인덱스
> Key_len : 실제로 사용할 인덱스의 길이
> Ref : key 안의 인덱스와 비교하는 칼럼(상수)
> Rows : 쿼리 실행 시 조사하는 행 수
> Extra : 추가정보

Type의 의미 (조인 혹은 조회 시 어떤 방식으로 데이터를 가져오는지에 대한 내용)
성능은 위에서 아래로 내려올 수록 좋지 않다. (단, range에서 조회 데이터 건수가 많지 않다면 성능이 나쁘다고 볼 수 없다.)

> system : 테이블에 단 한 개의 데이터만 있는 경우
> const : SELECT에서 Primary Key 혹은 Unique Key를 상수로 조회하는 경우로, 많아야 한 건의 데이터만 있음
> eq_ref : 조인할 때 Primary Key 혹은 Unique Key로 매칭하는 경우
> ref : 조인할 때 Primary Key 혹은 Unique Key로 매칭하는 경우
> ref_or_null : ref와 같지만 NULL이 추가되어 검색되는 경우
> Index_merge : 두 개의 인덱스가 병합되어 검색이 이루어지는 경우
> unique_subquery : IN절 안의 서브쿼리에서 Primary Key가 오는 특수한 경우
> index_subquery : unique_subquery 와 비슷하나 Primary Key가 아닌 일반 인덱스인 경우
> range : 특정 범위 내에서 인덱스를 사용하여 원하는 데이터를 추철하는 경우로, 데이터가 방대하지 않다면 단순 SELECT에서는 나쁘지 않다.
> index : 인덱스를 처음부터 끝까지 찾아서 검색하는 경우로, 일반적으로 인덱스 풀스캔이라고 한다.
> all : 테이블을 처음부터 끝까지 검색하는 경우로, 일반적으로 테이블 풀스캔이라고 한다.

쿼리 상태도

> System -> const -> eq_ref -> ref -> ref_or_null -> index_merge -> unique_subquery -> index_subquery -> range -> index(인덱스 풀스캔) -> All(풀스캔)

- 쿼리 프로파일링을 이해하자 (실제 쿼리 실행 시 병목이 되는 부분을 찾아낼 수 있는 방법)
  쿼리를 처리할 때 DB내부적으로는 Open Table/Close Table/, Optimizing, Sending Data 등을 비롯해 여러 단계를 거치며 최종적으로 데이터를 찾아낸다.

프로파일링 관련 세션 변수를 활성화한 후 쿼리를 실행하면 프로파일된 정보를 확인할 수 있다.
SET PROFILING = 1;
SELECT \* FROM tab;
SHOW PROFILE;

프로파일링 정보 리스트 중 확인하고 싶은 쿼리 번호를 다음과 같이 실행하면 특정 쿼리에 대한 프로파일링 정보를 확인할 수 있다.
SHOW PROFILE FOR QUERY 3;

프로파알링 결과에서 Sending data(스토리지 엔진에서 DB엔진으로 쿼리를 보내는 단계)부분이 오래 걸린 것으로 나왔다면
스토리지 엔진이 DB엔진으로 데이터를 적게 보내도록 쿼리를 튜닝한다.

- 묵시적 형변환 함정에 빠지지 말자
  묵시적 형변환이란 조건절의 데이터 타입이 다를 때 우선순위가 높은 타입으로 형이 내부적으로 변환되는 것을 말한다.
  정수 타입이 문자열 타입보다 우선순위가 높다.
  만약 문자열과 정수값을 비교하는 쿼리가 들어오면 두 개의 칼럼 중 우선순위가 낮은 문자열은 자연스럽게 정수 타입으로 형변환되어 처리된다.

형변환은 언제든지 발생할 수 있다. 하지만 묵시적 형변환이 일어나는 대상이 인덱스 필드라면 어떨까?
조건절을 처리하기 위해 모든 데이터를 묵시적으로 형변환하기 때문에 테이블 풀스캔을 할 수 밖에 없으며, 이 경우 성능이 심각하게 저하된다.
(문자열 칼럼을 정수 조건으로 검색 등)

- MySQL에서는 'SHOW PROCESSLIST' 명령을 수행하면 바인딩된 변수값까지 나오지만 경우에 따라서는 찾기가 상당히 난해하다.

사실 이것저것 생각하기 싫다면 MySQL에서 무조건 문자열 조건으로 질의해도 큰 문제는 없다. 어차피 정수형이 문자열보다 우선순위가 높아 문자열은 묵시적 형변환되기 때문이다. 하지만 다른 DBMS로 데이터를 이관할 때 문제가 생길 수도 있다.

- 편리한 함수, 잘못 쓰면 성능에 독이 된다
  함수는 복잡한 연산을 사람이 알아보기 쉽고 사용하기 편리하지만 잘못 쓰면 불필요한 시스템 부하를 야기한다.

SELECT \* FROM WHERE DATE_FORMAT(reg_date, '%Y%m%d') = '20120818';
위와 같은 쿼리는 DB내부적으로 테이블 풀스캔을 수행할 수 밖에 없다.

SELECT \* FROM WHERE reg_date >= '2012-08-18 18:00:00';
불필요한 함수를 없애고 원하는 시간 사잇값만 가져오도록 쿼리를 다시 작성하였다.

- LIKE 검색을 아무 때나 써야하나?
  LIKE 검색을 별생각 없이 사용하다 보면 DBMS 성능이 전체적으로 크게 저하된다.
  그렇다고 이런 편리한 기능을 무조건 사용하지 않을 수는 없다.
  다음과 같은 팀만 지켜도 LIKE검색의 성능을 향상시킬 수 있다.
  > LIKE 조건이 '검색어%'와 같이 검색어가 앞 단에 있다면 데이터 분포도를 따져서 수행한다.
  > LIKE 조건이 '%검색어'와 같은 형태로 반드시 수행해야 한다면 LIKE 조건 이외의 조건절을 적극 활용하여 LIKE 처리가 필요한 데이터 범위를 최대한 줄인다.

인덱스는 필요한 데이터를 지칭한다는 점에서 데이터에 접근하기 위한 효율적 요소인 것은 분명하다.
그러나 인덱스 또한 메모리를 차지하고, 디스크를 소모하며, CPU연산이 필요한 데이터라는 것을 기억해야 한다.
DB에서 처리하는 데이터 범위를 줄이는 것이 성능 최적화의 가장 기본적인 요소이다.

- 데이터 흐름을 이해하자
  조인(JOIN)은 여러 테이블에서 하나의 결과를 가져올 수 있다는 점에서 편리하다.
  그러나 무분별하게 조인을 사용하면 데이터가 누적됨에 따라 쿼리 성능이 점진적으로 저하된다.

Temporary Table(임시 데이터를 저장하는 테이블이다. 예를 들어 용량이 큰 리포트를 생성하는 동안 데이터를 잠시 저장하여 전용 데이터에 영향을 주지 않고 데이터를 처리할 수 있다.)과 Filesort(결과 데이터를 ORDER BY에 맞게 정렬하는 것을 말한다.)에서 처리되는 데이터 수가 적다면 큰 문제가 없겠지만 텍스트 혹은 대용량 데이터(LOB 데이터)와 같이 덩치가 큰 칼럼이 있다면 성능이 급격히 저하돤디.

- Foreign Key 존재 유무를 파악하자
  조인이 많은 쿼리를 살펴보면 가끔 불필요한 조건 검색이 있는 것을 볼 수 있다.
  그 중 하나는 Foregin Key가 있는 경우다. Foregin Key는 테이블에서 다른 테이블의 Primary Key와 대응된다는 것을 의미한다.
  따라서 Foregin Key 가 정의된 테이블에는 반드시 다른 테이블과 연관된 데이터가 있어야 한다.

- Semi Join으로 인한 비효율을 제거하자
  MySQL 5.5 버전까지는 Semi Join('세미조인' 또는 '부분조인'이라고 부름)의 성능이 최적화 되어 있지 않았다.
  (Semi Join 이란 Exists와 IN 같은 조인 안에 SELECT가 있는 것이다.)

* MySQL 5.6 버전 부터는 최적화되어있음

- Outer Join이 반드시 필요한지 파악하자
  무분별하게 Outer Join('아우터 조인' 또는 '외부 조인'이라고 부름)을 수행하면 성능이 상당히 떨어진다.
  추가적인 데이터 조회를 위해 Outer Join을 사용할 때는 특히 주의하여 사용해야 한다.

- 테이블 파티셔닝을 활용해 대용량 데이터를 관리하자
  파티셔닝은 하나의 커다란 데이터를 여러 개의 데이터로 분할 저장함으로써 데이터 선택 효율을 높이는 기법이다.
  데이터를 분할 저장하면 특정 데이터를 찾을 때 필요한 데이터 파일에만 접근하기 때문에 효율이 높아진다.

특히 InnoDB에서는 Primary Key 순으로 데이터가 저장되기 때문에 무작위로 Primary Key를 생성하여 INSERT를 수행하면 성능이 급격히 저하될 수 있다.
이 경우 테이블에 파티셔닝을 적용하면 비효율을 어느 정도 극복할 수 있다. 하지만 파티셔닝 사용에는 다음과 같은 몇가지 제약 사항이 있다.

> 파티셔닝 키는 Primary Key와 연관된 칼럼이어야 한다.
> 파티셔닝 사용 시 Unique Key 혹은 Foreign 와 같은 제약 조건을 추가할 수 없다.(단, Unique Key가 Primary Key로 사용되는 경우는 제외)
> 파티셔닝 적용시 풀텍스트 인덱싱 혹은 스파셜 인덱싱 기능은 사용할 수 없다.
> 데이터 조회 시 반드시 파티셔닝 키가 포함되어야 하며 그렇지 않은 경우 전체 데이터 파일을 스캔한다.

Primary Key 외에 Unique 속성이 반드시 필요하다면 파티셔닝 때문에 로직이 복잡해질 수 있다. 또한 InnoDB인 경우 Primary Key의 크기가 커질 수 있기 때문에 전체적인 인덱스 사이즈도 커질 수 있다. InnoDB에서는 Primary Key이외의 보조 인덱스는 Primary Key를 값으로 가지기 때문이다.(색인을 예로 들면 검색어가 인덱스 키가 되고 페이지 번호가 인덱스 값이 된다.)
