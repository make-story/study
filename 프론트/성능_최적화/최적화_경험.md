# 서버사이드 데이터 호출 최적화

- 해당 데이터 이미지 Load 다른 비동기 데이터에 의한 이미지 Load 보다는 우선 순위. 네트워크 경쟁에세 우선이 됨.
- 서버사이드에서 데이터 호출이 추가되므로 First Contentful Paint (FCP) 시간이 약간 늘어날 수 있음
- 즉, 서버사이드 데이터 호출 + 캐시 프록시 형태로 구축필요

# 첫 화면 이미지 로드 최적화

22/08/09 배포전  
https://www.webpagetest.org/result/220809_BiDc6C_91G/

- FCP : 1.231 s
- LCP(Largest Contentful Paint) : 5.629S s
- CLS(Cumulative Layout Shift) : .086
- TBT(Total Blocking Time) : 2.342S s

22/08/10 배포후  
https://www.webpagetest.org/result/220810_BiDc78_46N/

- FCP : 2.532 s
- LCP(Largest Contentful Paint) : 2.532 s
- CLS(Cumulative Layout Shift) : 0
- TBT(Total Blocking Time) : 1.204 s

## 작업 내용

- 첫 화면 상단에 노출되는 컨텐츠, 사용자가 페이지 진입 후 바로 확인가능한 컨텐츠, 서버사이드 데이터 호출 (데이터 리스트 없을 때, 클라이언트 사이드에서 데이터 호출하는 방어로직 존재)
  - 서버사이드에서 API 호출이 추가되면서, 웹페이지가 사용자에게 전달되는 시간이 약간 증가 (Start Render, FCP)
- 레이지 로드 제거 (첫 화면 상단 사용자에게 바로 노출되는 컨텐츠이기 때문)
- 이미지 높이를 미리 잡고 있을 수 있도록, CSS 로 높이 설정 (Cumulative Layout Shift 향상)
  - https://wit.nts-corp.com/2020/12/28/6240
- loading ('eager' | 'lazy'), importance('auto' | 'low' | 'high') img 속성 활용 (웹 API)

## 레이지 로드 관련 로딩UI

- Skeleton (스켈레톤)
  https://ui.toast.com/weekly-pick/ko_20201110

- Suspense
  React.Suspense
  https://velog.io/@bbaa3218/React-Suspense%EB%9E%80

---

# 리소스

## Gif -> Video

파일 포맷 변환 도구 개발 또는 도구 선정필요

## 이미지 썸네일

### 도구 (thumbor)

https://thumbor.readthedocs.io/en/latest/index.html
https://www.daddyprogrammer.org/post/3086/thumbor-varnish-smart-image-service/

### WEB API (웹표준 방식)

https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images

```html
<img
  srcset="elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w"
  sizes="(max-width: 600px) 480px,
         800px"
  src="elva-fairy-800w.jpg"
  alt="Elva dressed as a fairy"
/>

<img
  srcset="elva-fairy-320w.jpg, elva-fairy-480w.jpg 1.5x, elva-fairy-640w.jpg 2x"
  src="elva-fairy-640w.jpg"
  alt="Elva dressed as a fairy"
/>
```

```html
<picture>
  <source media="(max-width: 799px)" srcset="elva-480w-close-portrait.jpg" />
  <source media="(min-width: 800px)" srcset="elva-800w.jpg" />
  <img src="elva-800w.jpg" alt="Chris standing up holding his daughter Elva" />
</picture>

<picture>
  <source type="image/svg+xml" srcset="pyramid.svg" />
  <source type="image/webp" srcset="pyramid.webp" />
  <img src="pyramid.png" alt="regular pyramid built from four equilateral triangles" />
</picture>
```

과거 브라우저 대응

```html
<style>
  .pc {
  }
  .mobile {
    display: none;
  }
  @media (max-width: 767px) {
    .pc {
      display: none;
    }
    .mobile {
      display: inline;
    }
  }
</style>

<div>
  <img src="https://i.imgur.com/PQNhCln.gif" class="pc" />
  <img src="https://i.imgur.com/YrkG5xB.gif" class="mobile" />
</div>
```

# 도구

- 트리쉐이킹
  https://webpack.kr/guides/tree-shaking/

# 코드

- 다이나믹 임포트

# 캐시

- 서비스 워커 캐시 전략

- Next.js 반환된 동적 페이지 정적파일로 캐싱

---

# Next.js / React

## Next.js dynamic import

https://web.dev/code-splitting-with-dynamic-imports-in-nextjs/  
https://nextjs.org/docs/advanced-features/dynamic-import

`페이지를 렌더링하는 데 필요한 JavaScript의 양을 줄임으로써 초기 로딩 성능을 향상시키는 데 도움`

```javascript
import dynamic from 'next/dynamic';

// 리액트 콤포넌트 동적 로드
// dynamic 호출되는 시점에, 해당 컴포넌트 코드가 포함된 청크파일 로드
const Puppy = dynamic(() => import('../components/Puppy'), {
  loading: () => <p>Loading...</p>,
});

const Index = () => {
  return <Puppy />;
};
```

### 클라이언트 측에서만 구성요소를 렌더링 해야하는 경우

`ssr: false 는 서버단에서 Pre-Rendering 하지 않고 클라이언트에서 렌더링 시키겠다는 의미`

```javascript
const Puppy = dynamic(() => import('../components/Puppy'), {
  ssr: false,
});

const Index = () => {
  // Puppy 컴포넌트는 SSR로 그려지지 않음
  return <Puppy />;
};
```

또는

```javascript
import dynamic from 'next/dynamic';
import React from 'react';

const NonSSRWrapper = props => <React.Fragment>{props.children}</React.Fragment>;
export default dynamic(() => Promise.resolve(NonSSRWrapper), { ssr: false });
```

```javascript
import NonSSRWrapper from './NonSSRWrapper';

const Feed = props => {
  return <NonSSRWrapper> 콘텐츠 </NonSSRWrapper>;
};
```

참고: 부분적 CSR 구현을 하는 이유
클라이언트 단에서만 사용되는 라이브러리의 경우, SSR방식으로 렌더링 할 경우 에러를 동반
Error : 'window is not defined, document is not defined'
그리고 SSR은 클라이언트의 작업을 일정부분 서버에서 진행하기 때문에 서버에 부담이 될 수 있다. 이 경우 퍼포먼스 향상 및 최적화를 위해 Dynamic Import를 사용

### React Suspense는 React 16에서 릴리즈된 기능

```javascript
import React, { Suspense } from 'react';

const PostList = React.lazy(() => import('./PostList.js'));

<AppLayout>
  <Suspense fallback={<div>loading...</div>}>
    <PostList />
  </Suspense>
</AppLayout>;
```

### Prerendering은 그대로 보존하고, 해당 컴포넌트 Chunk File이 필요한 순간에 Lazy 하게 요청하여 가져올 수 있는 방안

https://helloinyong.tistory.com/323

https://scriptedalchemy.medium.com/next-js-and-lazy-hydration-keep-the-html-but-drop-the-javascript-846feb2da1f  
Document는 유지하고 Script 코드는 Lazy 하게 가져와서 Hydration 문제를 해결할 수 있는 방안

- Webpack Plugin 설정
  webpack이 컴파일을 시작할 때, lazy 하게 가져오려는 Chunk File에 별도의 표시

```javascript
// next.config.js

// webpkac Compiler 생성
const mapModuleIds = fn => (compiler) => {
  const { context } = compiler.options;

  compiler.hooks.compilation.tap('ChangeModuleIdsPlugin', (compilation) => {
    compilation.hooks.beforeModuleIds.tap('ChangeModuleIdsPlugin', (modules) => {
      const { chunkGraph } = compilation;

      for (const module of modules) {
        if (module.libIdent) {
          const origId = module.libIdent({ context });

          if (!origId) continue;

          const namedModuleId = fn(origId, module.debugId);

          if (namedModuleId) {
              chunkGraph.setModuleId(module, namedModuleId);
          }
        }
      }
    });
  });
};


const moduleExports = {
  ...
  webpack: (config, options) => {

    const lazyTargets = [
      '/components/organisms/Footer/index.tsx',
      '/components/organisms/BelowContents/index.tsx',
       ...
    ];

    config.plugins.push(
      mapModuleIds((id, debugId) => {
        const isTarget = lazyTargets.some((target) => target.includes(id);

        if (isTarget) {
          return `lazy-${debugId}`;
        }

        return false;
      }),
    );

    return config;
  },
});

module.exports = moduleExports;
```

- Next.js 내부 설정 재정의

  - Prerendering 후 document와 관련된 Script코드를 불러오는 중, 컴파일 시 'lazy-'로 표시한 Dynamic Import Chunk File들은 제외하고 응답할 수 있도록 Next.js 내부 설정
    - 해당 설정을 하기 위해서 \_document.tsx에서 `<script>` 태그를 제어할 수 있도록 next/head를 확장
  - Next.Script를 확장해서, 기존의 모든 Chunk Script를 Next Script 자체에서 관리했는데, Lazy Hudration 할 Chunk Script는 별도로 Webpack에서 관리될 것이기 때문에, Next Script Data에서 'lazy-'로 표시한 Dynamic Import Chunk File들을 제외

```javascript
//_document.tsx

class LazyHead extends Head {
  getDynamicChunks(files) {
    const dynamicScripts = super.getDynamicChunks(files);
    try {
      // get chunk manifest from loadable
      const loadableManifest = __non_webpack_require__('../../react-loadable-manifest.json');
      // search and filter modules based on marker ID
      const chunksToExclude = Object.values(loadableManifest).filter(
        manifestModule => manifestModule?.id?.startsWith?.('lazy') || false,
      );
      const excludeMap = chunksToExclude?.reduce?.((acc, chunks) => {
        if (chunks.files) {
          acc.push(...chunks.files);
        }
        return acc;
      }, []);
      const filteredChunks = dynamicScripts?.filter?.(script => !excludeMap?.includes(script?.key));

      return filteredChunks;
    } catch (e) {
      // if it fails, return the dynamic scripts that were originally sent in
      return dynamicScripts;
    }
  }
}

const backupScript = NextScript.getInlineScriptSource;

NextScript.getInlineScriptSource = props => {
  // dont let next load all dynamic IDS, let webpack manage it
  if (props?.__NEXT_DATA__?.dynamicIds) {
    const filteredDynamicModuleIds = props?.__NEXT_DATA__?.dynamicIds?.filter?.(
      moduleID => !moduleID?.startsWith?.('lazy'),
    );
    if (filteredDynamicModuleIds) {
      // mutate dynamicIds from next data
      props.__NEXT_DATA__.dynamicIds = filteredDynamicModuleIds;
    }
  }
  return backupScript(props);
};

export default class MyDocument extends Document {
  render(): JSX.Element {
    return (
      <Html>
        <LazyHead />
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}
```

`react-loadable-manifest.json은 무엇인가요?`
lazy import를 이용해 별도로 Chunk File로 분리되는 파일들을 정보를 담고 있는 파일이다. 프로젝트 빌드 시에 .next 디렉터리 하단에 생성된다.

`__non_webpack_require__is not defined 에러가 발생합니다.`
해당 webpack관련 types 모듈을 설치하지 않아서다. 아래 모듈을 설치해주면 해결된다.

```
$ yarn add -D @types/webpack-env
```

- react-lazy-hydration 모듈
  HTML Document가 보존된 상태에서 Hydration이 일어날 때 깜박임이 발생하지 않도록 하게 위해 react-lazy-hydration이란 모듈을 활용

```javascript
import LazyHydrate from 'react-lazy-hydration';

const Footer = dynamic(() => import('@/components/organisms/Footer'));

const Home = () => (
  <>
    ...
    <LazyHydrate whenVisible>
      <Footer />
    </LazyHydrate>
  </>
);

export default Home;
```

내부 interactive Observer와 whenVisible 속성을 통해 해당 컴포넌트가 뷰 포트에 들어와 유저 인터렉션이 필요해지는 순간에Hydration을 수행
따라서 HTML은 그대로 남아있고, Hydration이 필요해지는 순간에 웹팩이 동작해서 동적으로 해당 Chunk Script를 요청 후 hydration하여 정상적으로 해당 컴포넌트가 동작하도록 한다.

---
