# `읽기 좋은 자바스크립트 코딩 기법` 책 정리
`스타일 가이드의 핵심은 기본 포맷 규칙`입니다. 규칙에 따라 코드를 어떻게 작성할지 큰 틀에서 정합니다.   

----------


# 참고
코드 스타일 통계  
http://sideeffect.kr/popularconvention/#javascript  


----------


# Douglas Crockford 코딩컨벤션
https://www.crockford.com/code.html  
https://www.itsdday.com/2020/04/javascript-code-conventions.html  
https://faidcy.tistory.com/84  


# Google Javascript Style Guide
https://google.github.io/styleguide/jsguide.html  

- 13 Noteworthy Points from Google’s JavaScript Style Guide  
https://www.freecodecamp.org/news/google-publishes-a-javascript-style-guide-here-are-some-key-lessons-1810b8ad050b/
- 13 Noteworthy Points from Google’s JavaScript Style Guide ver.KOR  
https://smoh.tistory.com/215


# Airbnb Javascript Style Guide
https://github.com/airbnb/javascript  
- Airbnb는 자신들의 Guide를 fork 뜬 후, 각 팀의 Style Guide에 맞게 변경해서 사용하기를 권장한다.


# W3S Javascript Style Guide
https://www.w3schools.com/js/js_conventions.asp   


# MDN Javascript Style Guide
https://developer.mozilla.org/en-US/docs/MDN/Guidelines/Code_guidelines/JavaScript  


# jQuery Javascript Style Guide
https://contribute.jquery.org/style-guide/js/  


# typescript style guide
## Google Typescript Style Guide
https://google.github.io/styleguide/tsguide.html  

## Typescript Style Guide (An unofficial Typescript Style Guide)
https://github.com/basarat/typescript-book/blob/master/docs/styleguide/styleguide.md


# react style guide
## Airbnb React/JSX Style Guide
https://github.com/airbnb/javascript/tree/master/react


# 그 외
## 뱅크샐러드 Coding Style Guide  
https://github.com/banksalad/styleguide  

## NHN  
https://ui.toast.com/fe-guide/ko/  


----------


## 들여쓰기
들여쓰기는 거의 모든 언어에서 첫 번째로 결정하는 부분입니다. 또한 마치 종교적 논쟁처럼 소프트웨어 엔지니어들끼리  
몇 시간 동안 논쟁할 수 있는 주제입니다. 그만큼 민감하지만 가장 먼저 정해야 하는 주제이기도 합니다.  
치일피일 미루다 뒤늦게 정하면, 들여쓰기가 잘못된 파일에 작업할때마다 들여쓰기부터 손봐야 하는 문제가 생길 수 있습니다.  

1. 탭을 이용한 들여쓰기  
이 방법에는 두 가지 장점이 있습니다. 먼저, 탭과 들여쓰기 단계가 일대일로 대응되어 논리적입니다.  
또한 각 텍스트 에디터에서 탭 크기를 원하는 대로 설정할 수 있어서 들여쓰기를 좁게 설정하는 개발자나   
넓게 설정하는 개발자 모두 원하는 대로 볼 수 있습니다.  
그러나 탭을 이용한 들여쓰기는 시스템마다 탭 크기를 다르게 표현한다는 단점이 있습니다. 따라서 에디터나 시스템에서 열었던 파일을  
다른 데서 열었을 때 자신이 보던 방식과 달라 난감할 수 있습니다. 이는 개발자마다 같은 코드를 다른 방식으로 본다는 것이고,  
협업을 위해서는 좋지 않습니다.  

2. 공백을 이용한 들여쓰기  
공백으로 들여쓰기를 처리하는 방법으로, 2개/3개/8개 공백 중 한 가지 방식을 이용해서 들여쓰기하는 것이 일반적입니다.  
이 방법은 자바스크립트뿐만 아니라 프로그래밍 언어에서 전반적으로 사용하는 스타일 가이드라인입니다. 그런데 실무에서는  
보통 2개나 8개 공백의 절충안으로 4개를 공백 들여쓰기에 사용합니다.  
공백을 이용한 들여쓰기의 가장 큰 장점은 어떤 에디터나 시스템에서도 똑같이 보인다는 점입니다. 또 텍스트 에디터에서 탭 키를 누르면  
여러 개의 공백을 입력하도록 설정할 수도 있습니다. 즉 모든 개발자가 소스 코드를 동일하게 볼 수 있습니다.  
그러나 개발자 중 한 명이라도 에디터 설정을 잘못하면 서식에 문제가 생길 수 있습니다.  
개인마다 다른 방법을 추구할 수는 있지만, 팀 내 의견을 하나로 모으는 것이 무엇보다 중요합니다.  


## 문장 종료
세미콜론을 입력하지 않아도 자바스크립트에서는 ASI(Automatic Semicolon Insertion) 메커니즘 덕분에 정상적으로 동작합니다.  
ASI는 코드에서 세미콜론이 필요한 자리를 찾고 없으면 세미콜롬을 넣어주는데, 대부분 정확하게 찾아 문제가 없습니다.  
그러나 ASI가 세미콜론을 찾는 규칙은 기억하기 어려울 정도로 복잡하므로 명시적으로 세미콜론을 넣기를 권장합니다.  


## 빈 줄 넣기  
보통 다음의 경우 빈 줄을 추가하는 것이 좋습니다.  
1. 메서드 사이  
2. 메서드 내 지역 변수와 첫 번째 문장 사이  
3. 한 줄 또는 여러 줄 주석 전  
4. 가독성을 높이기 위해 메서드 내에서 논리적으로 구분되는 곳  
크락포드의 코드 컨벤션도 빈 줄을 현명하게 사용하라는 언급만 있을 뿐, 스타일 가이드 중 빈줄에 대해 상세하게 설명한 가이드는  
아직 없습니다.  


##  이름 규칙
자바스크립트의 기반이 되는 ECMAScript는 '낙타표기법'으로 작성되었습니다.
낙타 표기법은 소문자로 시작하고 새로운 단어를 사용할 때마다 첫 문자는 대문자로 입력하는 방식입니다.

일반적으로 자신이 사용하는 언어의 표준 라이브러리에서 따르는 이름 규칙을 사용해야 합니다.
대부분의 자바스크립트 개발자들은 변수명과 함수명을 지을 때 낙타 표기법을 사용합니다.
구글 자바스크립트 스타일 가이드와 SproutCore 스타일 가이드, Dojo 스타일 가이드 모두 낙타 표기법을 사용하라고 
명시하고 있습니다.

* 2000년도쯤까지는 자바스크립트에서 헝가리안 표기법이 많이 쓰였습니다. 이 표기법은 변수명 앞에 변수의 타입을 붙이는 방식입니다.   
예를 들면, sName은 문자열 변수를 의미하고, iCount는 정수형 변수를 의미합니다.
```javascript
var thisIsMyName;
```


## 변수와 함수
변수명은 명사로, 함수명은 동사로 시작하면 서로 구분하기 쉬워집니다.  

함수명과 메서드(객체에 소속된 함수)의 첫 번째 단어는 동사로 시작해야 합니다.  
가장많이 사용되는 동사는 다음과 같습니다.  
1. can : 불린 값을 반환하는 함수  
2. has : 불린 값을 반환하는 함수  
3. is : 불린 값을 반환하는 함수  
4. get : 불린 이외의 값을 반환하는 함수  
5. set : 값을 저장하기 위해 사용하는 함수  

* jQuery의 함수명은 위에서 설명한 규칙을 따르지 않습니다. jQuery 의 많은 메서드가 getter와 setter의 역할을 동시에 하기 때문입니다.  
```javascript
// 변수명의 좋은 예
var count = 10;
var myName = 'YSM';
var found = true;

// 함수명의 좋은 예
function getName() {

}
```


## 상수
ECMAScript6 이전까지는 자바스크립트에 상수 개념이 없었습니다. 있다 해도 개발자들은 변수를 선언해 상수처럼 사용했습니다.  
값이 변할 수 있는 일반 변수와 한번 초기 값이 설정되면 절대 변경 불가한 상수를 구분하려고 이름 규칙을 다르게 합니다.  
C에서 사용하는 규칙을 가져와 상수는 모든 문자를 대문자로 쓰고, 단어가 바뀔 때는 밑줄을 사용합니다.  


## 생성자
생성자도 다른 이름 규칙처럼 언어의 표준 라이브러리에서 따르는 규칙을 사용해야 합니다. 자바스크립트에서 생성자는  
파스칼 표기법(Pascal Case)을 사용합니다.  
파스칼 표기법은 낙타 표기법과 유사하지만, 낙타 표기법과 다르게 첫 글자는 대문자로 시작합니다.  
예를 들면, anotherName 대신 AnotherName으로 이름을 짓습니다. 이렇게 하면 생성자를 변수나 함수와 쉽게 구분할 수 있습니다.  
생성자는 타입의 인스턴스를 만드는 데 사용되므로 이름은 명사로 짓습니다.  


## 리터럴 값
자바스크립트에는 다양한 타입의 기본 리터럴 값이 있습니다. string, number, boolean, null, undefined, 객체 리터럴과 배열 리터럴도 있습니다.  
이 중 boolean은 따로 설명이 필요 없지만, 그 외 다른 타입을 제대로 사용하기 위해서는 심사숙고해야 합니다.  


## null
undefined와 많이 혼동하는데 null 값은 다음과 같이 한정된 곳에서만 사용해야 합니다.  

1. 나중에 값을 할당할 변수를 초기화할 때  
2. 선언한 변수에 값이 할당되었는지 비교할 때  
3. 인자 값으로 객체(object)를 넘기는 함수를 호출할 때  
4. 함수를 호출한 곳에서 반환값으로 객체(object)를 기대할 때  

다음은 null을 사용하면 안 되는 경우입니다.  
1. 함수의 인자 값을 확인하기 위해 null로 비교해서는 안된다.  
2. 초기화되지 않은 변수를 null로 비교해서는 안된다.  

null 은 object 를 대신한다고 생각하는 것이 가장 좋습니다. 주요 스타일 가이드에서 이 규칙이 다뤄지지는 않지만,   
전체적인 유지보수성을 높이기 위해서는 중요합니다.  
```javascript
// 좋은 예
var person = null;

// 좋은 예
function getPerson() {
	if(condition) {
		return new Person("Nicholas");
	}else {
		return null;
	}
}

// 나쁜 예: 초기화되지 않은 변수를 null로 테스트하고 있음
var person;
if(person != null) {

}
```


## undefined
대부분 undefined와 null을 자주 혼동합니다. 이 둘을 잘 구분하지 못하는 이유는  
null == undefined 가 true 이기 때문입니다.  
그러나 undefined 와 null 의 사용법은 많이 다릅니다. 초기화되지 않은 변수는 초기 값으로 undefined를 갖습니다.  
즉 변수가 실제 값으로 초기화 되기를 기다린다는 의미입니다.  

변수를 null로 초기화하면 나중에 값을 저장할 것이라는 의도를 명확히 할 수 있습니다.  
또 typeof 연산자는 null에대해 "object" 문자열을 반환하여 undefined와 구분할 수 있습니다.  
```javascript
// 좋은 예
var person = null;
if(typeof noVer == 'undefined') { // noVer 변수는 선언되지 않았음을 알 수있다.
	// ...
}
```


## strict 모드
ECMAScript5 부터 자바스크립트 문장을 해석하고 실행할 때 실수를 줄이기 위해  
strict 모드가 도입되었습니다.  

"use strict"를 전역으로 사용하는 건 피해야 합니다.  
만약 총 11개의 자바스크립트 파일 중 하나의 파일에라도 전역 strict 모드가 적용되어 있으면  
나중에 파일을 합친 후에는 나머지 파일에도 전역 strict 모드가 적용되기 때문입니다.  
```javascript
// 나쁜 예 - 전역 strict 모드
"use strict";

// 좋은 예
function doSomething() {
	"use strict";

	// ...
}

// 좋은 예
(function() {
	"use strict";

	function doSomething() {
		// ...
	};

	// ...
})();
```


## One-Global 접근법 (확장성이나 크키가 큰 것)
전역 변수를 최소한으로 사용하는 방법 중 가장 좋은 방법은 전역 객체를 딱 하나만 선언하는 방법입니다.  
One-Global 접근법에서는 네이티브 API가 사용하지 않을만한 이름으로 전역 객체를 만들고  
그 전역 개체 안에 필요한 로직을 모두 추가합니다.  
즉, 여러 개의 전역을 만들지 않고 전역으로 선언하려 했던 객체를 전역 객체의 프로퍼티에 추가합니다.  
```javascript
var MaintainableJS = MaintainableJS || {};
MaintainableJS = {
	book: function() {
		// ...
	}
}
MaintainableJS.Test = function() {
	// ...
}
MaintainableJS.Test.prototype.setPage = function() {
	// ...
}
```


## Zero-Global 접근법 (스크립트가 작은 것)
하나의 스크립트로만 동작하는 페이지에서 사용되는데   
스크립트를 파일 하나에 합쳐서 사용하거나,  
스크립트가 작고 페이지에 영향을 주지 않을 때 주로 사용합니다.  
```javascript
(function(win) {
	"use strict";

	var doc = win.document;

	// ...
})(window); 
// 곧바로 호출된 함수는 window 객체를 인자로 넘기기 때문에 스크립트에서는 전역 객체에 직접 접근할 필요가 없습니다.
// 이제 함수가 window와 doc을 직접 변경하지 않고 모든 변수를 var 키워드를 사용해 선언하면 전역 객체를 사용하지 않고 코드를 작성할 수 있습니다.
```


## 프로퍼티 알아내기
상속받은 프로퍼티는 제외하고 객체 인스턴스에 프로퍼티가 있는지 검사하려면   
hasOwnProperty() 메서드를 사용합니다.  
여기서 주의할 점은 IE8 이하 버전의 DOM 객체는 Object를 상속받지 않아 hasOwnProperty() 메서드가 없습니다.  
이는 DOM 객체에 hasOwnProperty() 메서드를 사용하기 전에 일단 메서드가 있는지부터 확인해야 한다는 뜻입니다.  

IE8 이하 버전에서도 문제없이 동작해야 하므로, 개인적으로 가급적 in 연산자를 사용하고   
인스턴스의 프로퍼티인지 확인이 필요할 때만 hasOwnProperty()를 사용합니다.  

정리하자면, 객체에 프로토타입이 존재하는지 확인할 때는 in 연산자나 hasOwnProperty()를 꼭 사용해야 합니다.  
```javascript
var object = {
	count: 0,
	related: null
};

// 좋은 예
if("count" in object) {
	// 여기가 실행됨
}

// 나쁜 예: false 값으로 검사함.
if(object["count"]) {
	// 여기가 실행되지 않음
}

// 나쁜 예: null과 비교.
if(object["related"] !== null) {
	// 여기가 실행되지 않음
}

// DOM 객체가 아닐 때는 이렇게 사용하는 것이 좋습니다.
if(object.hasOwnProperty("related")) {
	// 여기가 실행됨
}

// DOM 객체인지 확실하지 않을 때는 이렇게 사용하는 것이 좋습니다.
if("hasOwnProperty" in object && object.hasOwnProperty("related")) {
	// 여기가 실행됨
}
```


## 사용자 에러 던지기
ECMA-262에서는 총 7가지 타입의 에러 객체를 정했습니다.  

1. Error
모든 에러의 기본 타입입니다. 엔진에서 이 타입의 에러는 발생하지 않습니다.  

2. EvalError
eval()에서 실행한 코드에 실행 중 에러가 있으면 이 타입으로 에러가 발생합니다.  

3. RangeError
숫자가 범위를 벗어나면 이 타입의 에러가 발생합니다. 예를 들어 -20개의 요소를 가진 배열을 생성하려고 new Array(-20)이라 하면  
RangeError가 발생합니다. 정상적으로 실행된다면 거의 발생하지 않는 에러입니다.  

4. ReferenceError
사용하려는 객체를 사용할 수 없을 때 발생합니다. 예를 들어 null을 참조하는 변수에서 메서드를 호출하면 발생합니다.  

5. SyntaxError
eval()에 전달된 코드가 문법상 문제가 있으면 발생합니다.  

6. TypeError
변수가 알 수 없는 타입일 때 발생합니다. 예를 들어 new 10 또는 "prop" in true 같은 코드를 실행할 때 발생합니다.  

7. URIError
잘못된 형식의 URI 문자열이 encodeURI, encodeURIComponent, decodeURI, decodeURIComponent 에 전달되면 발생합니다.  
```javascript
try {
	// 에러가 발생하는 코드
}catch (ex) {
	if(ex instanceof TypeError) {
		// 에러를 처리함
	}else if(ex instanceof ReferenceError) {
		// 에러를 처리함
	}else {
		// 그외 나머지 에러를 처리함
	}
}
```


----------

