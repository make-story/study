# 정규식 테스트

https://regexr.com/

# 정규식 만드는 과정

1. 먼저 찾으려는(또는 변환하려는 것)을 원본 그대로 넣는다.
<div>ysm</div>

2. 글자, 특수문자부분은 변경한다.
   <\w+>\w+<\/w+>

3. 예외상황 등 부가적으로 발생할 수 있는 부분을 생각해 적용한다.
   <\w+>[\s\n]?\w+[\s\n]?<\/w+>

---

- RegExp의 exec 메소드와 test 메소드 ,그리고 String의 match메소드 , replace메소드 , search메소드 , split 메소드와 함께 쓰입니다 .

\
특수 문자 앞에 위치한 백슬래시는 다음에 나오는 문자는 특별하지않고, 문자 대로 해석되어야 된다고 알려줍니다. 예를 들어, 패턴 /a*/는 특수문자'*'을 0 이상의 'a'들 로 믿습니다. 대조적으로, 패턴 /a\*/ 는 문자열'a*' 같은 문자와 일치할 수 있게'*'의 특수함을 제거합니다.

RegExp("pattern") 표기를 쓰면서 \ 스스로 이스케이프 하는 것을 잊어버리지 마세요. 왜냐하면 \ 는 문자열에서도 이스케이프 문자이기 때문입니다.

^
입력의 시작에 일치합니다.
만약 다중 선 플래그가 참으로 설정되어 있다면, 줄 바꿈 문자 바로 다음에서도 일치합니다.

예를 들어, /^A/ 는 "an A" 의 'A'에 일치하지 않습니다, 그러나 "An E" 의 'A'에서는 일치합니다.

$
입력의 끝을 일치합니다.
만약 다중 선 플래그가 참으로 설정되어 있다면, 줄 바꿈 문자 바로 뒤에도 일치합니다.

예를 들어, /t$/ 는 "eater" 의 't' 에는 일치하지 않습니다, 그러나 "eat" 에서는 일치합니다.

- 0회 이상 연속으로 반복되는 앞선 문자에 일치합니다. {0,} 와 동일합니다.

예를 들어, /bo\*/ 는 "A ghost booooed" 의 'boooo' 에 일치하고, "A bird warbled" 의 'b'에 일치하지만 "A goat grunted" 에서는 아무것도 일치하지 않습니다.

- 1회 상 연속으로 반복되는 앞선 문자에 일치합니다. {1,} 와 동일합니다.

예를 들어, /a+/ 는 "candy"의 'a'에 일치하고 "caaaaaaandy" 의 모든 'a'들에 일치하지만, "cndy" 에서는 아무것도 일치하지 않습니다.

?
0 또는 1회 반복되는 앞선 문자에 일치합니다. {0,1}와 동일합니다.

예를 들어, /e?le?/ 는 "angel"의 'el' 에 일치하고,
"angle"의 'le' 에 일치하고 또한 "oslo" 의 'l'에도 일치합니다.

만약 수량자 \*,+,?,{} 바로 뒤에 사용한다면, 기본적으로 탐욕스럽던(가능한 한 많이 일치시키는)와는 반대로 수량자를 탐욕스럽지 않게 만듭니다 (가능한 가장 적은 문자들에 일치시킵니다)

예를 들어, /\d+/를 "123abc"에 적용시키면 "123"이 일치합니다.
그러나 /\d+?/를 같은 문자열에 적용시키면 오직 "1"만 일치합니다.

.
(소숫점) 다음 줄 문자(개행 문자)를 제외한 어떤 하나의 문자에 일치합니다.

예를 들어, /.n/는 "nay, an apple is on the tree"에서 'an'과 'on'에 일치하지만, 'nay' 에는 일치하지 않습니다.

(x)
패턴 /(foo) (bar) \1 \2/안의 '(foo)' 와 '(bar)'는 문자열"foo bar foo bar"에서 처음의 두 단어에 일치하고 기억합니다.
패턴의 \1 와 \2는 문자열의 마지막 2 단어에 일치합니다.
\1, \2, \n들은 정규식의 일치 부분에 사용되는것을 숙지하세요.
정규식의 바꾸기 부분에서 구문$1, $2, $n는 필수적으로 쓰여져야 됩니다.
e.g.: 'bar foo'.replace( /(...) (...)/, '$2 $1' )

(?:x)
'x'에 일치하지만 일치한 것을 기억하지 않습니다.
괄호는 비포획 괄호(non-capturing parentheses)라고 불리우고, 정규식 연산자가 같이 동작할 수 있게 하위 표현을 정의할 수 있습니다.

정규식 예제/(?:foo){1,2}/을 생각해보세요.
만약 정규식이 /foo{1,2}/라면, {1,2}는 'foo'의 마지막 'o' 에만 적용됩니다.
비포획 괄호과 같이 쓰인다면, {1,2}는 단어 'foo' 전체에 적용됩니다.

x(?=y)
오직 'y'가 뒤따라오는'x'에만 일치합니다. 이것은 lookahead 라고 불립니다.

예를 들어, /Jack(?=Sprat)/ 는 'Sprat'가 뒤따라오는 'Jack' 에만 일치합니다.
/Jack(?=Sprat|Frost)/는 'Sprat' 또는 'Frost'가 뒤따라오는 'Jack'에만 일치합니다.
그러나, 'Sprat' 및 'Frost 는 일치 결과의 일부가 아닙니다.

x(?!y)
오직 'y'가 뒤따라오지 않는 'x'에만 일치합니다. 이것은 negated lookahead 라고 불립니다.

예를 들어, /\d+(?!\.)/는 소숫점이 뒤따라오지 않는 숫자에 일치합니다.
정규식 /\d+(?!\.)/.exec("3.141")는 '3.141' 이 아닌 '141'에 일치합니다.

x|y
'x' 또는 'y'에 일치합니다.

예들 들어, /green|red/는 "green apple"의 'green'에 일치하고,
"red apple."의 'red'에 일치합니다.

{n}
앞 문자가 n 번 나타날 경우에 일치합니다. N은 절대로 양의 정수이어야만 합니다.

예를 들어, /a{2}/는 "candy,"의 'a'에는 일치하지 않지만,
"caandy,"의 모든 a 와, "caaandy."의 첫 두 a 에는 일치합니다.

{n,m}
n과 m은 양의 정수이고, n <= m를 만족해야 합니다.
앞 문자가 최소n개, 최대 m개가 나타나면 일치합니다. m이 생략된다면, m은 ∞로 취급됩니다.

예를 들어, /a{1,3}/는 "cndy"에서 아무것도 일치하지 않지만, "caandy,"의 첫 두 a 와 "caaaaaaandy"의 첫 세 a 에 일치합니다. "caaaaaaandy"에서 더 많은 a 들이 있지만, "aaa"만 일치한다는 점을 주목하세요.

[xyz]
문자셋(Character set) 입니다.
이 패턴 타입은 괄호 안의 이스케이프 시퀀스를 포함한 어떤 한 문자에 일치합니다.
점(.) 이나 별표 (\*) 같은 특수 문자는 문자셋에서는 특수 문자가 아닙니다. 따라서 이스케이프시킬 필요가 없습니다. 다음의 예제에서 보여주는 것 처럼 , 하이픈을 을 이용하여 문자의 범위를 지정해 줄 수 있습니다.

패턴 [abcd] 처럼 일치하는, 패턴 [a-d] 는 "brisket"의 'b' 에 일치하고, "city"의 'c' 에 일치합니다. 패턴 /[a-z.]+/ 와 /[\w.]+/ 는 "test.i.ng" 전체 문자열이 일치합니다.

[^xyz]
음의 문자셋(negated character set) 또는 보수 문자셋(complemented character set)입니다. 괄호 안에 동봉되지 않은 어떤 문자든 일치합니다.
하이픈을 이용하여 문자의 범위를 지정할 수 있습니다. 일반적인 문자셋에서 작동하는 모든것은 여기에서도 작동합니다.

예를 들어, 패턴[^abc]는 패턴[^a-c]와 동일합니다. 두 패턴은 최초로 "brisket"의 'r', "chop."의 'h' 에 일치합니다.

[\b]
백스페이스(U+0008)에 일치합니다.
백스페이스 문자에 일치시키려면, 대괄호("[]")를 이용해야만 합니다. (\b와 혼동하지 마세요.)

\b
단어의 경계와 일치합니다. (단어의 양쪽 끝)
단어의 경계는 단어 문자가 뒤따라오지 않는 위치나, 단어 글자의 앞에서 일치합니다.
단어의 경계는 일치하는 것에 포함되지 않는다는것을 숙지하세요. 다른 말로는, 단어의 경계에 일치하는 것의 길이는 0 입니다. (패턴 [\b]와 혼동하지 마세요.)

예제:
/\bm/는 "moon"의 'm'에 일치합니다 ;
/oo\b/ 는 'oo'를 뒤따라오는 'n' 은 단어 문자이기 때문에, "moon"의 'oo'에 일치하지 않습니다 ;
/oon\b/는 "moon"의 'oon'에 일치합니다. 왜냐하면, 'oon'은 문자열의 끝이라서 뒤따라오는 단어 문자가 없기 때문입니다

/\w\b\w/는 어떤 것에도 일치하지 않습니다.
왜냐하면, 단어 문자는 절대로 비 단어 문자와 단어 문자 두개가 뒤따라올수 없기 때문입니다.

숙지하세요: 자바스크립트의 정규식 엔진은 specific set of characters를 단어 문자로 정의합니다. 이 집단에 속하지 않은 어떤 문자는 단어 분리(word break) 로 여겨집니다. 이 집단의 문자들은 꽤나 한정되어 있습니다: 이 집단은 오로지 로마자 소문자와 대문자, 10진수 숫자, 밑줄 문자로 구성되어 있습니다. "é" 또는 "ü" 같이, 강세 표시가 되어있는 문자들은 안타깝게도 단어 분리(word breaks) 로 취급됩니다.

\B
비 단어 분리(non-word boundary)에 일치합니다. (단어의 반복)
이패턴은 이전의 문자와 다음의 문자가 같은 타입인 위치에 일치합니다.
두개가 모두 단어이거나, 두개가 모두 비 단어 이어야 합니다.
문자열의 시작과 끝은 비 단어로 여겨집니다.

예를 들어, /\B../는 "noonday"의 'oo'에 일치하고, /y\B./는 "possibly yesterday."의 'ye'에 일치합니다.

\cX
X는 A 에서 Z 까지의 문자 입니다.
문자열에서 컨트롤 문자에 일치합니다.

예를 들어, /\cM/는 문자열에서 control-M (U+000D)에 일치합니다.

\d
숫자 문자에 일치합니다. [0-9]와 동일합니다.

예를 들어, /\d/ 또는 /[0-9]/는 "B2 is the suite number."에서 '2'에 일치합니다.

\D
숫자 문자가 아닌 문자에 일치합니다. [^0-9]와 동일합니다.

예를 들어, /\D/ 또는 /[^0-9]/는 "B2 is the suite number."의 'B'에 일치합니다.

\f
폼피드 (U+000C) 문자에 일치합니다.

\n
줄 바꿈 (U+000A) 문자에 일치합니다.

\r
캐리지 리턴(U+000D) 문자에 일치합니다.

\s
스페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자에 일치합니다.

예를 들어, /\s\w\*/는 "foo bar."의 ' bar'에 일치합니다.

\S
공백 문자가 아닌 하나의 문자에 일치합니다.

예를 들어, /\S\w\*/는 "foo bar."의 'foo' 에 일치합니다.

\t
탭 (U+0009) 문자에 일치합니다.

\v
수직 탭(U+000B) 문자에 일치합니다.

\w
밑줄 문자를 포함한 영숫자 문자에 일치합니다. [A-Za-z0-9_] 와 동일합니다.

예를 들어, /\w/는 "apple,"의 'a' 에 일치하고, "$5.28,"의 '5'에 일치하고,"3D."의 '3'에 일치합니다.

\W
비 단어 문자에 일치합니다. [^a-za-z0-9_] 와 동일합니다.

예를 들어, /\W/ 또는 /[^a-za-z0-9_]/는 "50%."의 '%' 에 일치합니다.

\n
n이 양의 정수인 곳은, 정규식 안 n번 괄호의 최근 일치 부분의 역참조 입니다.
(왼쪽 괄호부터 카운트합니다.)

예를 들어, /apple(,)\sorange\1/는
"apple, orange, cherry, peach."의 'apple, orange,' 에 일치합니다.

\0
널 (U+0000)문자에 일치합니다.
다른 숫자가 따라오지 않게 하세요. 왜냐하면 \0<digits>는 8진 이스케이프 시퀀스이기 때문입니다.

\xhh
코드가 hh(두 16진 숫자)인 문자에 일치합니다.

\uhhhh
코드가 hhhh(네개의 16진 숫자)인 문자에 일치합니다.
정규식 내에서, 단순한 문자열로 취급되는 사용자 입력을 이스케이프 하는 것은 간단한 재배치로 할
