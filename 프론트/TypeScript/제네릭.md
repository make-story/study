# 제네릭(Generic) 방식 타입 - 타입을 인수로 받아서 사용

`사용 시점에 타입을 선언할 수 있는 방법을 제공`  
타입을 `T 와 같은 일종의 변수(타입 변수)로 취급하는 것`을 `제네릭(generics)타입`이라고 합니다.

> <u>컴파일러는 T 의 의미를 알 수 있어야 합니다.  
> 즉, T 가 타입 변수(type variable)라고 알려줘야 합니다.</u>  
> const 함수이름 = `<타입변수>`(매개변수: 타입변수): 타입변수 => {};

> T 는 Type의 약자로 다른 언어에서도 제네릭을 선언할 때 관용적으로 많이 사용된다.  
> 이 부분에는 식별자로 사용할 수 있는 것이라면 무엇이든 들어갈 수 있다. 이를테면 $나 \_도 가능하다는 의미다.  
> 하지만 대개의 경우 T를 사용한다. 여기에서 T를 타입 변수(Type variables)라고 한다.

```typescript
function toArray<T>(a: T, b: T): T[] {
  return [a, b];
}

toArray<number>(1, 2);
toArray<string>('1', '2');
toArray<string | number>(1, '2');
toArray<number>(1, '2'); // Error
```

`타입 추론을 활용해, 사용 시점에 타입을 제공하지 않을 수 있음`

```typescript
const arrayLength = <T>(array: T[]): number => array.length;
const isEmpty = <T>(array: T[]): boolean => arrayLength<T>(array) == 0;

let numArray: number[] = [1, 2, 3];
let strArray: string[] = ['Hello', 'World'];

arrayLength(numArray); // 타입 추론
isEmpty([]); // 타입 추론
```

> 두 개 이상의 타입 변수  
> 제네릭 함수나 클래스에서는 두 개 이상의 타입 변수도 사용할 수 있다.

```typescript
function toPair<T, U>(a: T, b: U): [T, U] {
  return [a, b];
}
toPair<string, number>('1', 1); // [ '1', 1 ]
```

## 제약 조건(Constraints)

인터페이스나 타입 별칭을 사용하는 제네릭을 작성할 수도 있습니다.

```typescript
interface MyType<T> {
  name: string;
  value: T;
}

const dataA: MyType<string> = {
  name: 'Data A',
  value: 'Hello world',
};
const dataB: MyType<number> = {
  name: 'Data B',
  value: 1234,
};
const dataC: MyType<boolean> = {
  name: 'Data C',
  value: true,
};
const dataD: MyType<number[]> = {
  name: 'Data D',
  value: [1, 2, 3, 4],
};
```

```typescript
interface MyType<T extends string | number> {
  name: string;
  value: T;
}

const dataA: MyType<string> = {
  name: 'Data A',
  value: 'Hello world',
};
const dataB: MyType<number> = {
  name: 'Data B',
  value: 1234,
};
const dataC: MyType<boolean> = {
  // TS2344: Type 'boolean' does not satisfy the constraint 'string | number'.
  name: 'Data C',
  value: true,
};
const dataD: MyType<number[]> = {
  // TS2344: Type 'number[]' does not satisfy the constraint 'string | number'.
  name: 'Data D',
  value: [1, 2, 3, 4],
};
```

## 제네릭 함수의 타입 추론

`제네릭 형태로 구현된 함수는 원칙적으로는 타입변수를 명시`해줘야 합니다.

```typescript
const identoty = <T>(n: T): T => n;
console.log(identoty<boolean>(true)); // true - 타입 변수 명시
console.log(identoty(true)); // true - 타입 추론 방식
```

하지만 이런 코드는 번거로워서 `타입스크립트는 타입 변수 부분을 생략할 수 있게 합니다.`  
타입스크립트는 타입 변수가 생략된 제네릭 함수를 만나면 타입 추론을 통해 생략된 타입을 찾아냅니다.

## 제네릭 함수의 함수 시그니처

타입스크립트는 어떤 경우 `함수 시그니처의 매개변수 부분에 변수 이름을 기입하라고 요구`합니다.

```typescript
// callback 라는 이름의 매개변수에 함수 시그니처를 사용
const func = (callback: (a: number, number?) => number): void => {}; // 오류발생! - 타입만 있고 변수명은 없음!
```

이런 오류가 발생하면 타입스크립트가 해석하지 못하는 부분에 변수를 삽입하고 이 변수에 타입을 명시해 해결합니다.

```typescript
const func = (callback: (a: number, i?: number) => number): void => {};
```

```typescript
const func = <T>(callback: (arg: T, i?: number) => number): void => {};
```

```typescript
// function 키워드 (함수선언식)
function g1<T>(a: T): void {}
function g2<T, Q>(a: T, b: Q): void {}
```

```typescript
// 화살표 함수
const g3 = <T>(a: T): void => {};
const g4 = <T, Q>(a: T, b: Q): void => {};
```

```typescript
// 타입 별칭(type-alias)
type Type1Func<T> = (T) => void;
type Type2Func<T, Q> = (T, Q) = > void;
type Type3Func<T, Q, R> = (T, Q) => R; // T와 Q타입 값을 입력 받아 R타입 값을 반환
```
