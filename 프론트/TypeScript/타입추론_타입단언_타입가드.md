# 타입추론

`명시적으로 타입 선언이 되어있지 않은 경우, 타입스크립트는 타입을 추론해 제공`  
타입스크립트는 `자바스크립트와 호환성을 위해 타입 주석 부분을 생략`할 수 있습니다.

타입스크립트 컴파일러는 다음과 같은 코드를 만나면 대입 연산자 = 오른쪽 값에 따라 변수의 타입을 지정합니다.  
이를 `타입 추론(type inference)`이라고 합니다.

```typescript
let n = 1; // n의 타입을 number로 판단
let b = true; // b의 타입을 boolean으로 판단
let s = 'hello'; // s의 타입을 string으로 판단
let o = {}; // o의 타입을 object로 판단
```

```typescript
let hello = 'world'; // let hello: string
const hello = 'world'; // const hello: 'world'
```

```typescript
// 변수 num을 초기화하면서 숫자 12를 할당해 Number 타입으로 추론되었고,
let num = 12;
// 따라서 'Hello type!'이라는 String 타입의 값은 할당할 수 없기 때문에 에러가 발생
num = 'Hello type!'; // TS2322: Type '"Hello type!"' is not assignable to type 'number'.
```

`타입스크립트가 타입을 추론하는 경우`

- 초기화된 변수
- 기본값이 설정된 매개 변수
- 반환 값이 있는 함수

타입 추론이 엄격하지 않은 타입 선언을 의미하는 것은 아닙니다.  
따라서 이를 활용해 모든 곳에 타입을 명시할 필요는 없으며, 많은 경우 더 좋은 코드 가독성을 제공할 수 있습니다.

## let, const 선언의 타입 추론

```typescript
// Type assertion
// TypeScript 3.4에 추가된 const assertion 기능을 사용하면, let 변수에 대해서도 const 변수를 사용할 때와 같은 타입 추론 규칙을 적용할 수 있습니다.
let user = {
  name: 'Neo',
  age: 36,
} as const;
user.age = 85; // Error
user.name = 'Evan'; // Error
```

```typescript
const Product = {
  bgImg: `/public/images/@temp_img_discount.png`,
  title: '헤라 루즈 홀릭 런칭',
  tags: '#NEW CLASSIC #NEW COLOR',
  prodImg: `/public/images/@temp_img_prod_s.png`,
  isSoldout: false,
  brandName: '헤라',
  prodName: '헤라 루즈 홀릭 매트 립',
  discountPrice: 38000,
  originalPrice: 50000,
  discountRate: 10,
  prodLink: 'naver.com',
};
const Mock = {
  products: [] as typeof Product[],
};
```

---

# 타입변환 (타입스크립트는 '타입단언'이라는 용어로 사용)

`타입 추론을 통해 판단할 수 있는 타입의 범주를 넘는 경우, 더 이상 추론하지 않도록 지시할 수 있음`  
타입이 있는 언어들은 특정 타입의 변숫값을 `다른 타입의 값으로 변환할 수 있는 기능`을 제공합니다.  
이를 `타입변환(type conversion)`이라고 합니다.

```typescript
let person: object = { name: 'test' };
console.log(person.name); // 'object' 형식에 'name' 속성이 없습니다. 에러!
```

```typescript
function someFunc(val: string | number, isNumber: boolean) {
  // some logics
  if (isNumber) {
    // 1. '변수 as 타입' 방식
    (val as number).toFixed(2);
    // 2. '<타입>변수' 방식
    // (<number>val).toFixed(2);
  }
}
```

```typescript
let person: object = { name: 'test' };
// 타입변환
(<{ name: string }>person).name;
```

`타입스크립트는 독특하게 타입 변환이 아닌 타입 단언(type assertion)이라는 용어를 사용`합니다.

```
(<타입>객체)
또는
(객체 as 타입)
```

이들은 모두 ES5 자바스크립트 구문이 아닙니다.  
따라서 `자바스크립트의 타입 변환 구문과 구분하기 위해 타입 단언이라는 용어를 사용`합니다.

https://iancoding.tistory.com/160

```
// 타입 단언에는 두 가지 종류가 있다.
1: <Fish>pet
2: (pet as Fish)
```

1 번은 런타임과 컴파일 단계에서 모두 돌아가고  
2 번은 컴파일 때만 돌아간다.  
`리액트로 개발할 시 꺽쇠(<>)로 타입캐스팅 하는 것은 TSX 태그 문법이랑 비슷하기 때문에 as 를 추천`한다.

```typescript
interface INameable {
  name: string;
}
let obj: object = { name: 'YSM' };
let name1 = (<INameable>obj).name;
let name2 = (obj as INameable).name;
console.log(name1, name2); // YSM YSM
```

## `<Type>` 과 `as Type`

> 타입 단언, 타입 캐스팅, 다운 캐스팅, 강제형변환  
> 타입 단언 문법은 `<Type>` 과 `as Type` 으로 두 종류  
> JSX 를 사용하는 경우 `<Type>` 키워드는 JSX 의 문법과 겹치기 때문에 불편

```typescript
let hello: number = 1;

(hello as unknown as string).substr(1, 2);
// (<string>hello).substr(1, 2);
// hello의 타입을 string으로 바꾸고 substr 메소드를 실행한다.
// unknown : number와 string은 명확히 다른 타입이기 때문에 unknown을 생략할 수 없다.
```

## as - 타입단언

`as 를 사용해 최종적으로 확실하게 타입을 단언`  
https://heropy.blog/2020/01/27/typescript/

```typescript
let val = 0;
(val as number).toFixed(2);

// <타입>변수
// JSX를 사용하는 경우 특정 구문 파싱에서 문제가 발생할 수 있으며, 결과적으로 .tsx 파일에서는 전혀 사용할 수 없습니다.
(<number>val).toFixed(2);
```

```typescript
//let div = document.querySelector('div'); // let div: HTMLDivElement | null
// 타입을 지정해주기 전 div는 HTMLDivElement | null 일수 가 있어 오류가 생길수 있다.

// 타입 단언
let div = document.querySelector('div') as HTMLDivElement;
```

## Non-null 단언 연산자 - 특히 컴파일 환경에서 체크하기 어려운 DOM 사용에서 유용

`!`를 사용하는 Non-null 단언 연산자(Non-null assertion operator)를 통해  
피연산자가 `Nullish(null이나 undefined) 값이 아님을 단언`할 수 있는데,  
변수나 속성에서 간단하게 사용할 수 있기 때문에 유용

```typescript
// Error - TS2533: Object is possibly 'null' or 'undefined'.
function fnA(x: number | null | undefined) {
  return x.toFixed(2);
}

// if statement
function fnD(x: number | null | undefined) {
  if (x) {
    return x.toFixed(2);
  }
}

// Type assertion
function fnB(x: number | null | undefined) {
  return (x as number).toFixed(2);
}
function fnC(x: number | null | undefined) {
  return (<number>x).toFixed(2);
}

// Non-null assertion operator
function fnE(x: number | null | undefined) {
  return x!.toFixed(2);
}
```

```typescript
// Error - TS2531: Object is possibly 'null'.
document.querySelector('.menu-item').innerHTML;

// Type assertion
(document.querySelector('.menu-item') as HTMLDivElement).innerHTML;
(<HTMLDivElement>document.querySelector('.menu-item')).innerHTML;

// Non-null assertion operator
document.querySelector('.menu-item')!.innerHTML;
```

## 타입 단언에는 DOM에 접근할때 자주 사용됩니다.

```javascript
// 버튼이 있다면 버튼에 접근하지만 버튼이 없다면 null 이 됩니다. (오류발생 가능성)
const button = document.querySelector('button');

// 그렇기 때문에 타입 단언으로 HTMLButtonElement 타입으로 강제로 선언해줍니다.
const button = document.querySelector('button') as HTMLButtonElement;

// 이렇게도 단언해줄 수 있습니다 (값이 무조건 있다고 확신하는 방법)
const button = document.querySelector('button')!; // 끝에 ! 느낌표를 붙혀줍니다.
```

타입 단언에서 !는 무조건 이 요소는 존재한다고 확신할때 사용합니다.

타입 추론 같은 경우는 코드를 깔끔하게 만들고 싶을 때 유용할 수 있겠지만  
타입을 정확히 명시하는 것이 코드를 보며 타입을 바로바로 확인하기 편할 것 같다는 생각이 듭니다.

타입 단언은 해당 타입이 정말 무조건 확신이 있을때가 아니라면 굳이 자주 사용하진 않을 것 같습니다.

---

# 타입가드 (Guards)

타입 가드는 `NAME is TYPE 형태의 타입` 술부(Predicate)를 반환 타입으로 명시한 함수

타입 단언을 여러 번 사용하게 되는 경우 유용

```typescript
// 일반적 타입 단언 사용 방식
function someFunc(val: string | number, isNumber: boolean) {
  if (isNumber) {
    (val as number).toFixed(2);
    isNaN(val as number);
  } else {
    (val as string).split('');
    (val as string).toUpperCase();
    (val as string).length;
  }
}
```

```typescript
// 타입 가드 함수 사용 방식
function isNumber(val: string | number): val is number {
  // 타입 가드 함수
  // typeof, in 그리고 instanceof 연산자 등 사용
  return typeof val === 'number';
}
function someFunc(val: string | number) {
  if (isNumber(val)) {
    val.toFixed(2);
    isNaN(val);
  } else {
    val.split('');
    val.toUpperCase();
    val.length;
  }
}
```

## is - 타입가드

```
typeof 같은 걸로 타입 따져서 분기 처리 하는 역할을 TS 에선 is 이다.

if (isFish(Fish 타입 인 애)) { // isFish에서 Fish 타입이면 타입 가드에 의해서 조건문 통과
  console.log(Fish 타입인 애); // OK
  console.log(Bird 타입인 애); // Error
} else { // Bird 타입인 애가 들어가면 여기로!
  console.log(Fish 타입); // Error
  console.log(Bird 타입); // OK
}
```

```typescript
interface Dev {
  name: string;
  skill: string;
}
interface Person {
  name: string;
  age: number;
}

function introduce(): Dev | Person {
  return { name: 'd', age: 33, skill: 'c' };
}
const tony = introduce(); // Dev | Person 으로 공통된 속성만 사용가능. 즉, tony.skill 불가

// skill을 빼고 싶다면? -> type assertion으로 사용 가능
if ((tony as Dev).skill) {
  console.log((tony as Dev).skill);
} else if ((tony as Person).age) {
  console.log((tony as Person).age);
}
// 너무 assertion을 많이 씀으로 타입 가드 함수를 만든다.

// 타입 가드 정의
// target is Dev -> 넘겨 받은 파라미터가 해당 타입인지를 확인
function isDev(target: Dev | Person): target is Dev {
  // skill이 있다면 Dev이다
  return (target as Dev).skill !== undefined;
}
if (isDev(tony)) {
  // name, skill 사용 가능
  console.log(tony.skill);
} else {
  // name, age 사용 가능
  console.log(tony.age);
}
```

```javascript
function isNumber(x: any): x is number {
  return typeof x === "number";
}

function isString(x: any): x is string {
  return typeof x === "string";
}
```

---

# 타입스크립트 타입 추론과 타입 단언

https://kimyang-sun.tistory.com/entry/TypeScript-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-inference-assertion-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8

## inference : 타입 추론으로서 타입을 따로 지정해주지 않아도 타입스크립트에서 똑똑하게 타입을 추론해줍니다.

```javascript
// Type Inference
// 타입을 명시하지 않아도 처음 생성시 문자열로 생성이 되어 string으로 타입 추론이 됩니다.
let string = 'We are the world!';
string = 100; // 문자열 타입에 숫자를 할당하여 오류가 발생합니다.

// 함수의 인자도 마찬가지로 기본값 매개변수가 숫자라면 숫자로 선언됩니다.
function write(number = 1000) {
  return number; // 1000
}
write('number'); // 숫자가 아닌 문자열을 넣으면 오류가 발생합니다.
```

## assertion : 타입 단언으로서 타입을 강제로 강요하여 선언합니다. (타입을 확신할때 사용)

```javascript
// Type Assertion
let anything; // 타입 추론에 의해 any로 선언됩니다.

anything = 100;
anything = 'baby'

let anything2 = anything // anything2는 anything과 같은 any 타입입니다.
let anything2 = 10; // any 타입이어서 10으로 변화합니다.

let anything3 = anything as string; // string으로 타입 단언을 해줍니다.
anything3 = 100; // 문자열로 단언하여 숫자를 할당하니까 오류가 발생합니다.
```

```typescript
// Type assertion
// TypeScript 3.4에 추가된 const assertion 기능을 사용하면, let 변수에 대해서도 const 변수를 사용할 때와 같은 타입 추론 규칙을 적용할 수 있습니다.
let user = {
  name: 'Neo',
  age: 36,
} as const;
user.age = 85; // Error
user.name = 'Evan'; // Error
```

```typescript
const Product = {
  bgImg: `/public/images/@temp_img_discount.png`,
  title: '헤라 루즈 홀릭 런칭',
  tags: '#NEW CLASSIC #NEW COLOR',
  prodImg: `/public/images/@temp_img_prod_s.png`,
  isSoldout: false,
  brandName: '헤라',
  prodName: '헤라 루즈 홀릭 매트 립',
  discountPrice: 38000,
  originalPrice: 50000,
  discountRate: 10,
  prodLink: 'naver.com',
};
const Mock = {
  products: [] as typeof Product[],
};
```

> 타입 단언 문법은 `<Type>` 과 `as Type` 으로 두 종류  
> JSX 를 사용하는 경우 `<Type>` 키워드는 JSX 의 문법과 겹치기 때문에 불편
