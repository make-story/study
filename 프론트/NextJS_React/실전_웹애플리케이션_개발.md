`타입스크립트, 리액트, Next.js 로 배우는 실전 웹애플리케이션 개발` 책 정리

# p32, Next.js 가 필요해진 이유

Next.js 개발자들의 사상은 클라이언트와 서버 사이에서 코드를 공유할 수 있는 유니버설한 자바스크립트 애플리케이션을 만드는 것입니다.

리액트의 특징인 렌더링 함수와 컴포넌트 라이브 사이클을 활용함으로써 자바스크립트를 사용해 이제까지 보다 효율적으로 애플리케이션을 개발할 수 있는 세계를 구현하고 있습니다.  
또한, Next.js 의 SSR 기능을 활용해 웹 브라우저의 부담을 줄이고, 보안도 강화할 수 있습니다.  
SSR 은 애플리케이션의 모든 부분에 대해, 또는 프로젝트 전체에 대해 수행할 수 있으며, `콘텐츠가 풍부한 페이지를 선택해 SSR 을 수행하는 등으로 유연하게 설계`할 수 있습니다.  
그리고 SSG 를 사용함으로써 보다 뛰어난 성능의 웹 애플리케이션을 구현할 수 있습니다.

# p34, 리액트 컴포넌트의 복원 - 하이드레이션

SSR, SSG 에서는 리액트 컴포넌트의 렌더링은 브라우저에 반환되기 전, 즉 서버 사이드에서 실행됩니다.  
클라이언트 측에서는 인터랙티브한 리액트 애플리케이션으로서 작동하도록 하기 위해 서버 측에서 미리 생성된 정적인 HTML 을 다운로드한 뒤, 동적인 리액트 컴포넌트로 복원합니다.

그 프로세스를 하이드레이션(Hydration)이라 부릅니다. 수분 공급이라는 의미를 가진 용어입니다. 일단 리액트 컴포넌트로써 전개되어 정적으로 된 것을 동적인 것으로 되돌린다는 이미지에서, 수분을 공급한다는 형태를 연상할 수 있어 이런 용어를 사용합니다.

SSR/SSG 로 미리 생성된 HTML 이 브라우저에 로딩되면 즉시 화면에 UI가 표시됩니다.

한편, 하이드레이션을 하려면 자바스크립트를 로딩해야 합니다. 따라서 페이지 초기화 시 HTML 표시와 자바스크립트 실행 시점에 차이가 발생하는 점에 주의해야 합니다.  
하이드레이션을 제공하지 않는 순수한 SPA 의 경우, 자바스크립트 로딩이 완료될 때까지 화면에는 아무것도 표시되지 않는 상태가 됩니다. 그에 비해 하이드레이션을 제공하면 사용자 경험이 그만큼 좋아집니다.

하이드레이션 실행은 ReactDOM 이라는 모듈의 hydeate() 라는 API 로 제공됩니다.

https://ko.reactjs.org/docs/react-dom.html#hydrate  
https://react.dev/reference/react-dom/hydrate

# p132, Next.js 렌더링 방법

## 정적 사이트 생성 (SSG)

SSG에서는 빌드 시 API 등으로 부터 데이터를 얻어, 페이지를 그려 정적 파일로 생성합니다.

빌드 시 getSaticProps 라는 함수가 호출되며, 그 함수 안에서 API 호출 등을 수행하고, 페이지를 그리는 데 필요한 props 를 반환합니다.  
그 뒤, 이 props 를 페이지 컴포넌트에 전달해서 화면을 그립니다.  
화면을 그린 결과는 정적 파일의 형태로 빌드 결과로 저장합니다.  
페이지에 접근이 발생하면, 미리 생성한 정적파일을 클라이언트에 보내고, 브라우저는 그것을 기반으로 화면을 그립니다.  
브라우저에서 초기 화면을 그린 후에는 일반적인 리액트 애플리케이션과 마찬가지로, API 등으로 부터 데이터를 얻어 동적으로 화면을 그릴 수도 있습니다.

SSG 는 접근 시에는 정적 파일을 클라이언트에 전달할 뿐이므로 초기 화면 그리기가 빠릅니다.  
한편, 빌드시에만 데이터를 얻으므로 초기 화면을 그릴 때 오래된 데이터가 표시될 가능성이 있습니다.  
따라서 실시간성 콘텐츠에는 적합하지 않습니다.

빌드 후에 표시 내용이 업데이트되지 않는 페이지나 초기 화면 그리기 이후에 데이터를 표시할 수 있는 페이지에 SSG 가 적합합니다.  
성능이 뛰어나므로, Next.js 에서는 SSR 보다 SSG 를 권장합니다.  
(유성민 개인 생각: SSG 또는 SSR 모두 캐시 앳지서버를 활용하면 효과가 극대화 됨. 즉, 대고객에서는 캐시서버활용이 필수!)

## 클라이언트 사이드 렌더링 (CSR)

본래의 리액트 애플리케이션 흐름에 가까운 화면 그리기 방법입니다.  
페이지를 그리기 위해 필요한 데이터는 나중에 얻어서 반영하기 때문에, SEO 에는 그다지 유효하지 않습니다.

CSR 은 SSG, SSR, ISR 과 조합해서 사용됩니다. CSR 만 사용하는 것이 아니라 기본적으로는 SSG, SSR, ISR 과 조합한다고 생각하는 것이 좋습니다.

초기 화면을 그리는 것이 그렇게 중요하지 않고, 실시간성이 중요한 페이지에 적합합니다.

## 서버 사이드 렌더링 (SSR)

SSR 에서는 페이지 접근이 발생할 때마다 서버에서 getServerSideProps 를 호출하고,  
그 결과 props 를 기반으로 페이지를 서버 측에서 그려서 클라이어느에 전달합니다.

접근 시마다 서버에서 데이터를 얻어 화면을 그리기 때문에, 항상 최신 데이터를 기반으로 페이지 초기 화면을 그릴 수 있어, SEO 에 대한 유효성을 기대할 수 있습니다.  
하지만, 서버에서 어느 정도의 처리를 해야 하므로, 다른 방법에 비해 지연이 높아질 가능성이 있습니다.

최신 가격이 표시되는 제품 페이지 등, 항상 최신 데이터를 표시하고자 하는 경우에 적합합니다.

## 점진적 정적 재생성 (ISR)

ISR 은 SSG 의 응용이라 할 수 있는 렌더링 방법입니다.  
사전에 페이지를 생성해서 전송하면서, 동시에 접근이 발생함에 따라 페이지를 다시 생성해서 새로운 페이지를 전송할 수 있습니다.

페이지 접근이 발생하면 사전에 렌더링해서 서버에 저장한 페이지의 데이터를 클라이언트에 전달합니다.  
이 데이터에 유효 기간을 설정할 수 있으며, 유효 기간이 지난 상태에서 접근이 발생하면 백그라운드에서 다시 getStaticProps 를 실행해서 화면을 그리고, 서버에 저장된 페이지 데이터를 업데이트 합니다.

SSR 과 달리 요청 시 서버 측에서 처리를 하지 않으므로, SSG 와 마찬가지로 지연을 짧게 유지할 수 있고, 어느 정도 최신 데이터를 기반으로 하는 페이지를 초기에 그릴 수 있습니다.  
SSG 와 SSR 의 중간과 같은 렌더링 방법이라 할 수 있습니다.

# p138, Next.js 의 페이지와 데이터 취득

| 종류 | 데이터 취득에 사용하는 주요 함수      | 데이터 취득 시점           | 보충 설명                                           |
| ---- | ------------------------------------- | -------------------------- | --------------------------------------------------- |
| SSG  | getStaticProps                        | 빌드 시(SSG)               | 데이터 취득을 전혀 수행하지 않는 경우도 SSG 에 해당 |
| SSR  | getServerSideProps                    | 사용자 요청 시(서버사이드) | getInitalProps 를 사용해도 SSR                      |
| ISR  | revalidate 를 반환하는 getStaticProps | 빌드 시(ISR)               | ISR 은 배포 후에도 백그라운드 빌드가 실행된다       |
| CSR  | 데이터 패칭 함수(axios, useSWR 등)    | 사용자 요청 시(브라우저)   | CSR 은 SSG/SSR/ISR 과 동시에 사용 가능              |

# p150, 링크

Next.js 에서는 애플리케이션 안의 다른 페이지로의 이동하기 위한 Link 컴포넌트가 있습니다.

Link 컴포넌트를 사용해 페이지를 이동한 경우는, 보통의 페이지 이동과 같이 이동 대상 페이지의 HTML 등을 얻어 화면에 그리는 것이 아니라,  
클라이언트 사이드에서 새로운 페이지를 그립니다.  
새로운 페이지를 그리기 위해 필요한 데이터는 미리 비동기 방식으로 얻습니다.  
그 덕분에 피이지를 재빨리 이동할 수 있습니다.

또한, router 객체의 push 메서드를 호출해서 페이지를 이동할 수도 있습니다.  
그 외에 router 객체에는 페이지 리로드를 수행하는 reload(), 페이지를 돌아가기 위한 back(), 페이지 이동 시작/종료 이벤트를 구독하는 메서드 등이 있습니다.

# p153, 이미지 표시

Next.js 에서 이미지를 표시할 때는 next/image 의 Image 컴포넌트를 사용합니다.  
img 태그가 아닌, Image 컴포넌트를 사용함으로써, 이미지를 읽을 때 서버 사이드에서 이미지를 최적화합니다.

Image 컴포넌트를 사용하면 브라우저의 정보를 기반으로 최적화된 이미지를 제공합니다.  
예를 들어, WebP 대응 브라우저에는 WebP 형식의 이미지를 제공하거나, 브라우저의 화면 크기에 맞춰 적절한 크기의 이미지를 제공하기도 합니다.

또한, 이미지를 그리는 방법 역시 몇 가지가 있습니다.  
Image 컴포넌트는 초기 단계에서 뷰포트에 표시되지 않는 이미지는 그리지 않고, 스크롤해서 뷰포트에서 가까워지는 단계에서 화면을 얻고 그리기 시작합니다.  
(이미지를 로딩하는 동안에는 이미지를 표시할 영역을 확보합니다. 이를 통해 이미지를 그린 전후로 레이아웃이 깨지는 것을 방지합니다.)

그 외에, Image 컴포넌트는 몇 가지 파라미터를 porps 에 전달할 수 있습니다.

## layout 에는 뷰포트의 변화에 따라 이미지를 리사이즈할 것인지를 설정할 수 있습니다.

기본값은 intrinsic 입니다.

- intrinsic 은 뷰표트가 이미지 크기보다 작을 때, 뷰포트에 맞춰 리사이즈한 이미지를 표시한다.
- responsive 는 뷰포트에 맞춰 리사이즈한 이미지를 표시한다.
- fixed 는 width 와 height 에 기반해, 뷰포트의 크기에 관계없이 같은 사이즈 이미지를 표시한다.
- fill 은 부모 요소에 맞춰서 이미지를 표시한다.

## placeholder 에서는 이미지 로딩 중에 표시할 내용을 지정할 수 있습니다.

empty 를 지정하면 이미지의 영역만 확보하고 아무것도 표시하지 않습니다.  
blur 를 지정하면 흐릿한 이미지를 표시합니다.  
import 문으로 읽은 로컬 이미지의 경우에는 흐릭한 이미지가 자동 생성되어 표시되지만, 경로로 지정한 경우나 외부 이미지의 경우는 blurDataURL 에 표시할 흐릿한 이미지의 URL을 지정해야 합니다.

`외부 리소스 이미지를 표시하는 경우에도 src 에 문자열 경로를 지정할 수 있습니다. 이때, 다음 2가지 사항을 주의해야 합니다.`  
첫 번째는 정적 파일과 달리 이미지 크기를 사전에 얻을 수 없기 때문에, layout 이 fill 이외인 경우에는 width 와 height 를 부여해 크기를 지정해야 합니다.  
두 번째는 외부 리소스 이미지를 표시하는 경우, 기본적으로는 최적화한 이미지를 표시할 수 없습니다. 따라서 next.config.js 의 domains 에 최적화를 허가하는 이미지의 도메인을 추가하거나, Image 컴포넌트의 unoptimized 에 true 를 전달해 최적화를 무효화해야 합니다.

# p159, 환경 변수/구성

Next.js 는 내부적으로 환경 변수를 위한 .env 파일을 처리할 수 있습니다.  
프로젝트 루트에 위치한 환경 변수 파일 .env 는 자동으로 로딩되어 코드상에서 참조할 수 있습니다.

.env 를 포함해 다음 형식의 파일을 참조할 수 있습니다.

- .env
- .env.local
- .env.${환경명}
- .env.${환경명}.local

.local 이 붙은 것은 .gitignore 에 추가되는 것을 의도한 것으로 API 키 등의 공개하고 싶지 않은 값을 저장하기 위해 사용합니다.

로딩된 환경 변수는 서버 사이드에서 실행하는 처리에서 참조할 수 있습니다.  
즉, getServerSideProps 등의 함수나 빌드 중 SSG 페이지를 그릴 때, SSR 를 서버 사이드에서 그릴 때 환경 변수의 값을 참조할 수 있습니다.  
(클라이언트에서 사용하려면 next.config.js 에서 주입 필요)

클라이언트 사이드에서도 접근하고 싶은 값에 대해서는 환경 변수 이름 앞에 NEXT*PUBLIC* 을 붙입니다.

# p167, 아토믹 디자인

# p170, 스타일드 컴포넌트를 Next.js에 도입 (\_document.tsx 수정내용 존재)

# p182, 스토리북을 사용한 컴포넌트 관리

# p191, 애드온 (스토리북 기능 확장방법)

# p213, 애플리케이션 개발 (실습!)

# p236, SWR 도입

# p455~ 로딩, 접근성, SEO, 보안
