# 실무에서 바로쓰는 Next.js 책 정리

Next.js 기본철학 Convention-Over-Configuration, 개발자가 해야 할 결정의 수를 줄이면서도 유연성은 잃지 않도록 하는 소프트웨어 설계 패러다임

리액트와 Next.js의 가장 큰 차이점?  
리액트는 자바스크립트 라이브러리이고 Next.js 는 프레임워크라는 점
서버사이드 렌더링, 정적 페이지 생성

# 렌더링 전략

## SSR

서버에서 HTML 페이지를 동적으로 렌더링하고 / 웹 브라우저로 전송할 수 있습니다.  
또한 서버에서 렌더링한 페이지에 스크립트 코드를 집어 넣어서 / 나중에 웹 페이지를 동적으로 처리할 수도 있는데 / 이를 `하이드레이션`이라고 합니다.

사용자가 페이지에 접근하면 / 서버는 페이지를 렌더링해서 결과로 생성한 HTML 페이지를 클라이언트로 전송합니다. / 그리고 브라우저는 페이지에서 요청한 모든 스크립트를 다운로드 한 다음 / DOM 위에 각 스크립트 코드를 `하이드레이션` 합니다.  
리액트 `하이드레이션` 덕분에 이 상태에서 웹 앱은 `싱글 페이지 애플리케이션(SPA) 처럼 작동`할 수 있습니다.
클라이언트 사이드 렌더링(CSR)과 SSR의 장점을 모두 가지는 것이죠.

- SEO 장점

## CSR

서버가 웹 애플리케이션이 필요로 하는 스크립트와 스타일만 포함된 기본 HTML 마크업만 전송  
자바스크립트 번들과 CSS 파일을 다운로드하며 브라우저가 이를 통해 전체 애플리케이션을 렌더링 합니다.

- 네이티브 애플리케이션 처럼 느껴지는 웹 애플리케이션
- 쉬운 페이지 전환 (페이지 새로고침 방식 아니기 때문)
- 지연된 로딩(레이지 로드)과 성능
- 서버 부하 감소
- 서버사이드 렌더 방식의 트러블 슈팅 어려움 감소

## SSG

일부 또는 전체 페이지를 빌드 시점에 미리 렌더링

- 쉬운 확장 (CDN)
- 뛰어난 성능
- 더 안전한 API 요청

`증분 정적 재생성(ISR)` 을 사용하면 Next.js 가 어느 정도의 주기로 정적 페이지를 다시 렌더링하고 해당 내용은 업데이트할지 정할 수 있습니다.

# 라우팅 시스템

`파일시스템 기반 페이지` 와 `라우팅`

- pages 디렉터리
- import { useRouter } from 'next/router';

# 자동 이미지 최적화

- import Image from 'next/image';

# 컴포넌트 구성 / 디렉토리 구조

https://bradfrost.com/blog/post/atomic-web-design

코드를 더 효율적으로 구성하기 위해 `아토믹 디자인 원칙` 에 따라 각 컴포넌트를 서로 다른 수준의 디렉터리에 둡니다.

- atoms
  코드에서 사용되는 가장 기본적인 컴포넌트
  button, input, p 와 같은 표준 HTML
  컬러 팔레트

- molecules
  atoms 에 속한 컴포넌트 여러 개를 조합

- organisms
  moleculs 와 atoms 를 섞어서 더 복잡한 구조의 컴포넌트를 만듦

- templates
  어디에 organisms, atoms, molecules 를 배치할지 결정

- page

# GraphQL API 사용하기

GraphQL 은 API 에서 사용할 수 있는 질의 언어로, REST 나 SOAP 같은 방식과는 다른 새로운 관점으로 API 데이터를 다룹니다.  
GraphQL 을 사용하면 꼭 필요한 데이터만 불러오도록 지정할 수 있으며 / 한 번의 요청으로 여러 곳의 데이터를 불러올 수 있습니다.

```
$ yarn add @apollo/client graphql isomorphic-unfetch
```

Apollo 는 널리 사용되는 GraphQL 클라이언트로, 리액트와 Next.js 를 기본으로 지원합니다.
ApolloClient 가 브라우저의 fetch API 를 사용해서 HTTP 요청을 처리하므로 / 서버에서도 같은 기능을 사용할 수 있는 폴리필인 isomorphic-unfetch 를 추가합니다.

# 테스트

- 단위 테스트
- 엔드 투 엔드 테스트
- 통합 테스트

## Jest

```
$ yarn add -D jest
```

- describe
  테스트와 관련된 그룹을 만듭니다.
  예를 들어 동일한 함수에 대한 다른 테스트나 모듈은 해당 함수 내에 포함시킵니다.

- test
  테스트를 선언하고 실행합니다.

- expect
  함수의 출력과 예상한 결과를 비료할 때 이 함수를 사용합니다.

## Cypress

Cypress 로 단위 테스트, 통합 테스트, 엔드 투 엔드 테스트를 만들고 이를 파이어폭스나 구글 크롬과 같은 크로미엄 기반 브라우저에서 실행할 수 있습니다.

```
$ yarn add -D cypress
```

# 성능 관점에서의 렌더링 전략 (p225)

...

# 도커 컨테이너에서 Next.js 애플리케이션 실행하기

운영체제에 관계없이 모든 서버에서 배포하고 실행할 수 있음(Image, 컨테이너)

Dockerfile

```Dockerfile
FROM node:18-alpine

RUN mkdir -p /app

WORKDIR /app

COPY . /app/

RUN npm install

RUN npm run build

EXPOSE 3000

CMD npm run start
```

1. 애플리케이션을 실행할 때 사용할 이미지를 정합니다. 여기서는 node:14-alpine 이라는 이미지를 사용합니다.
2. 별도의 작업 디렉터리를 만들고 사용하는 것이 좋기 때문에 /app 이라는 디렉터리를 먼저 만듭니다.
3. 앞서 만든 /app 디렉터리를 작업 디렉터리로 지정합니다.
4. 로컬 디렉터리의 모든 콘텐츠를 도커의 작업 디렉터리로 복사합니다.
5. 필요한 모든 의존성 패키지를 설치합니다.
6. 컨테이너의 작업 디렉터리에서 Next.js 애플리케이션을 빌드합니다.
7. 컨테이너 외부에서 애플리케이션에 접근할 수 있도록 3000번 포트를 외부에 노출합니다.
8. Next.js 애플리케이션을 서비스할 서버를 시작합니다.

.dockerignore 파일

```
.next
_next
node_modules
```

도커 컨테이너 이미지를 만듭니다.

```
$ docker build -t my-first-dockerized-nextjs-app
```

컨테이너를 시작

```
$ docker run -p 3000:3000 myfirst-dockerized-nextjs-app
```

상용 서비스에서 컨테이너를 사용하게 되면 애플리케이션을 실행하기 위해 간단한 환경 설정만 하면 된다는 이점이 있습니다.  
애플리케이션을 복제하거나 확장하거나 다시 빌드하고자 할떄는 Dockerfile 을 사용해서 이미지를 만들거나 / 미리 만들어둔 이미지로 애플리케이션을 실행하기만 하면 됩니다.
