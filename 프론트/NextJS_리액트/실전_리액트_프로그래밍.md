`실전 리액트 프로그래밍` 책 정리  

# 리액트 실전 활용법 


-----


## 가독성과 생산성을 고려한 컴포넌트 코드 작성법
되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 사람 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드를 작성하는 게 좋다.

1. 파일의 최상단에는 속성값의 타입을 정의한다.
```javascript
//import ...

// 컴포넌트 속성값 타입 정의
MyComponent.propTypes = {
    // ...
};
```

2. 컴포넌트 함수의 매개변수는 명명된 매개변수로 정의하는 게 좋다.
```javascript
// 컴포넌트 이름을 꼭 작성하지. function() 처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 힘들다.
export default function MyComponent({ prop1, prop2, }) {
    // ...
};
```

3. 컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의한다.
컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하도록 하자.  
그래야 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 있다.   
```javascript
const COLIMNES = [
    { id: 1, name: 'test1' },
    { id: 2, name: 'test2' },
];
const URL_LIST = '/api/products';
function getTotalPrice({ price, total }) {
    // ...
}
```

### 서로 연관된 코드를 한 곳으로 모으기
```javascript
function Profile({ userId }) {
    // 사용자 정보를 가져오는 기능을 한 곳으로 모았다.
    const [ user, setUser ] = useState(null);
    useEffect(() => {
        getUserApi(userId)
        .then(data => seruser(data));
    }, [userId]);

    // 창의 너비를 가져오는 기능을 한곳으로 모았다.
    const [ width, setWidth ] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListener("resize", onResize);
        return () => {
            window.removeEventListener("resize", onResize);
        };
    }, []);

    // ...
}
```


### 관심사 분리를 위한 프레젠테이션(Presentational), 컨테이너(Container) 컴포넌트 구분하기  
댄 아브라모프(Dan Abramov)의 블로그 포스트로 잘 알려진 컴포넌트 구분법이 있다.   
UI 처리, API 호출, DB 관리 등의 코드가 같은 곳에 있으면 복잡하기 때문에 이들은 서로 관심사가 다르다로 보고 분리해서 관리하는 게 좋다.  

프레젠테이션 컴포넌트의 정의는 다음과 같다.  
- 비즈니스 로직이 없다.  
- 상태값이 없다. 단, 마우스 오버(mouse over)와 같은 UI효과를 위한 상태값은 제외한다.



### Presentational & Container 분리는 이제 그만?
Dan Abramov  
https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0

```javascript
export default function ShopProducts() {
	const loading = useSelector(state => state.shop.loading);
	const products = useSelector(state => state.shop.products);
	const dispatch = useDispatch();

	useEffect(() => {
		// products 조회 로직 ...
	}, [dispatch]);
	const onPurchase = (product) => {
		/* 결제 로직 ... */
	};

	return (
		<div>{/* UI ... */}</div>
	);
}
```


-----


## useEffect 함수에서 API를 호출하는 경우
의존성 배열로 API호출 횟수를 최적화하기
```javascript
const [ user, setUser ] = useState();
useEffect(() => {
    // userId 가 변경될 때만 fetchUser 함수 호출
    fetchUser(userId)
    .then(data => setUser(data));
    return () => {
        // abort 를 해주는 것이 좋다!

    };
}, [userId]);
```

의존성 배열을 잘못 관리한 경우
```javascript
const [ needDetail, setNeedDetail ] = useState(false);
useEffect(() => {
    // needDetail 를 함수 내부에서 사용 중이다. needDetail 을 의존성 배열에 추가하지 않으면 문제가 발생한다.
    fetchUser(userId, needDetail)
    .then(data => setUser(data));
}, [userId]);
```
`리액트 팀에서는 이러한 문제를 해결하기 위해 eslint 에서 사용할 수 있는 exhaustive-deps 규칙을 만들어서 제공`한다.  
exhaustive-deps 는 잘못 사용된 의존성 배열을 찾아서 알려 준다.  


## useEffect 훅에서 async await 함수 사용하기  
useEffect 사용의 함수 반환값은 항상 함수 타입이어야 한다. (프로미스 객체 반환 안됨)  
```javascript
useEffect(() => {
    async function fetchAndSetUser() {
        const data = await fetchUser(userId);
        setUser(data);
    }
    fetchAndSetUser();
}, [userId]);
```

```javascript
// fetchAndSetUser 함수 재사용하기
function Profile({ userId }) {
    const [user, setUser] = useState();
    async function fetchAndSetUser(needDetail) {
        const data = await fetchUser(userId, needDetail);
        setUser(data);
    }
    useEffect(() => {
        fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    // ...

    // 위와 같이 구성할 경우,
    // fetchAndSetUser 함수는 렌더링을 할 때마다 갱신되므로 결과적으로 fetchAndSetUser 함수는 렌더링을 할 때마다 호출된다.  
    // 이 문제를 해결하려면 fetchAndSetUser 함수가 필요할 때만 갱신되도록 만들어야 한다.
}
```

```javascript
// userId 가 변경될 때만 fetchAndSetUser 함수 갱신
// useCallback 훅을 이용해서 userId 가 변경될 때만 fetchAndSetUser 함수가 갱신된다.  
function Profile({ userId }) {
    const [user, setUser] = useState();
    // fetchAndSetUser 함수는 userId 가 변경될 때만 호출된다.
    const fetchAndSetUser = useCallback(
        async needDetail => {
            const data = await fetchUser(userId, needDetail);
            setUser(data);
        },
        [userId]
    );
    useEffect(() => {
        fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    // ...
}
```


-----


## useEffect 의존성 배열을 없애는 방법  

### 부수 효과 함수 내에서 분기 처리하기  
```javascript
function Profile({ userId }) {
    const [user, setUser] = useState();
    async function fetchAndSetUser(needDetail) {
        const data = await fetchUser(userId, needDetail);
        setUser(data);
    }
    useEffect(() => {
        // 의존성 배열을 사용하지 않고, if 문으로 분기
        if(!user || user.id !== userId) {
            fetchAndSetUser(false);
        }
    }); // 의존성 배열을 입력하지 않으면 useEffect 함수에서 사용된 모든 변수는 가장 최신화된 값을 참조
}
```

### useState 의 상태값 변경 함수에 함수 입력하기  
```javascript
// 상태값 변경 함수에 함수를 입력해서 의존성 배열을 제거
function MyComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
        function onClick() {
            setCount(prev => prev + 1); // 이전 상태값을 변수로 받아서 바로 처리!
        }
        window.addEventListener("click", onClick);
        return () => window.removeEventListener("click", onClick);
    }); 
}

```


### useRef 활용하기  
해당 속성값이 렌더링 결과에 영향을 주는 값이 아니라면, useRef 훅을 이용해서 의존성 배열을 제거할 수 있다.  
```javascript
// 자주 변경되는 속성값을 의존성 배열에 추가한 코드
function MyComponent({ onClick }) {
    useEffect(() => {
        window.addEventListener("click", () => {
            onClick();
            // ...
        });
        // 연산량이 많은 코드
    }, [onClick]);
    // ...
}
```

```javascript
// useRef 훅으로 부수 효과 함수가 자주 호출되지 않도록 개선
function MyComponent({ onClick }) {
    const onClickRef = useRef();
    useEffect(() => {
        // useRef 에는 렌더링 결과와 무관한 값만 저장하자.
        // 이는 useRef 에 저장된 값이 변경돼도 컴포넌트가 다시 렌더링되지 않기 때문이다.
        onClickRef.current = onClick;
    });
    useEffect(() => {
        window.addEventListener("click", () => {
            onClick.current();
            // ...
        });
        // ...
    });
    // ...
}
```


-----

