# 네이버 - 개념, 구축 (추천 자료)

https://d2.naver.com/helloworld/0923884  
https://d2.naver.com/helloworld/7553804

# 배달의 민족 (추천자료)

https://techblog.woowahan.com/7976/  
https://github.com/kowoohyuk/monorepo-template

https://github.com/make-story/monorepo-template

# 라인

https://engineering.linecorp.com/ko/blog/monorepo-with-turborepo/

# 구글 모놀리식 저장소, 코드베이스

https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext

# 기타

https://codeburst.io/develop-and-deploy-your-own-react-monorepo-app-in-under-2-hours-using-lerna-travis-and-now-2b140d647238

https://velog.io/@jeong3320/JenkinsNext.js-%EC%A0%A0%ED%82%A8%EC%8A%A4%EB%A1%9C-%EB%B0%B0%ED%8F%AC%EC%9E%90%EB%8F%99%ED%99%94-%ED%95%98%EA%B8%B0

https://velog.io/@ongddree/TIL-%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC

---

# Next.js + yarn workspaces

https://medium.com/lemonade-engineering/yarn-workspace%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-monorepo-%EA%B5%AC%EC%84%B1-a7d61b9fa572

https://github.com/th0th/nextjs-typescript-yarn-workspaces

https://github.com/zooniverse/front-end-monorepo

https://betterprogramming.pub/converting-next-into-a-monorepo-with-yarn-workspaces-bf4007fdfa87  
https://github.com/wk0/boilerplate-next/tree/as-workspace

---

# 모노레포란?

모노레포는 단일 리포지터리에 여러 개의 서브 프로젝트가 존재하는 방식입니다.  
`모노레포란 같은 레포지토리에서 서로 다른 프로젝트들을 관리하는 소프트웨어 개발 전략`

모놀리식 방식은 `소스 코드를 모듈화하지 않고 하나의 리포지터리에 모두 넣었다고 생각하시면 됩니다. (동일저장소에 있는 다른 프로젝트 패키지 참조)`

모든 코드가 단일 버전으로 서로 직접 의존하기 때문에 코드 재사용이 용이하고 빌드 및 배포 과정도 단순하지만,  
관심 분리가 어렵고 기능 추가나 삭제가 리포지터리 전체에 영향을 줄 수 있다는 단점이 있습니다.  
이런 단점을 해결하고자 멀티레포 방식이 등장했습니다.

멀티 레포 방식에서는 소스 코드를 모듈화한 뒤  
각 모듈에 독자적인 영역을 부여하고 버전 관리를 통해 관심을 분리해서  
기능 변경이 다른 리포지터리에 직접 영향을 미치지 않도록 개선했습니다.  
하지만 각 모듈이 서로 독립된 영역에 존재하기 때문에 코드 단계에서의 재사용이 어려워졌고 빌드와 배포 과정이 복잡해졌습니다.

모노레포는 이와 같은 모놀리식 리포지터리와 멀티레포의 장점을 모두 취하고자 등장했습니다. 모노레포의 장점은 아래와 같습니다.

- Visibility
  - 리포지터리가 하나이기 때문에 모든 프로젝트의 코드와 자원(assets) 간의 관계와 의존성을 한눈에 확인할 수 있습니다.
- Collaboration
  - 모든 커밋 히스토리가 한 리포지터리에 남기 때문에 히스토리를 추적하거나 전체 리포지터리의 개발 방향을 이해하는 게 쉬워집니다.
  - 여러 곳에서 중복으로 사용하는 자산들(테스트 코드 등)을 공유하고 재사용할 수 있습니다.
- Speed
  - 배포와 빌드, 테스트와 같은 작업을 병렬로 한 번에 처리할 수 있으므로 한 번의 명령으로 여러 개의 리포지터리에서 작업을 진행할 수 있습니다.

https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext

# Turborepo란?

Vercel이 인수(참고)한 Turborepo는 JavaScript와 TypeScript 코드 베이스의 모노레포를 위한 고성능 빌드 시스템입니다.  
Vercel과 AWS, Miro, PayPal, Discord, LINE+의 Universal Video Player 등 여러 프로젝트에서 프로덕션 단계로 사용하고 있으며(참고), 지금도 활발하게 개발이 진행되고 있습니다.

---

# Yarn

`Yarn(1.x) 또는 npm(7.x)`의 workspaces 필드를 사용해 간단히 모노레포를 구성할 수 있다.  
yarn link 또는 npm link 기능을 선언적으로 사용하는 것으로 node_modules 디렉터리에 workspace에 대한 심볼릭 링크가 생성된다.  
이를 통해 하나의 저장소에 있는 여러 프로젝트가 서로 쉽게 상호 참조할 수 있다.

## 용어

- project
  - = 저장소
  - 하나 이상의 worktree 포함
  - 최소 한 개의 workspace(즉, 루트 workspace) 존재
- workspace
  - = 모노레포 패키지
- worktree
  - 자식 workspace를 갖는 workspace

`Yarn Berry (2.x, 3.x)` - Yarn2, Yarn3, Yarn Berry 등은 Yarn 1.x 이후 불리는 표현  
Yarn workspace를 도입하려고 할 때 성능면에서 Yarn Berry를 함께 검토해 볼 수 있다.  
Yarn Berry는 yarn의 두 번째 버전으로, 2018년 9월 yarn의 RFC 저장소에서 시작되었다.  
Yarn 1.x의 주요 개발자인 Mael Nison에 의해 TypeScript로 개발되었고 2020년 1월 25일 정식 버전이 출시되었다.  
Yarn 1.x는 v1.22.17에서 코드 프리징되었고 https://github.com/yarnpkg/berry 에서 2022.03.09 현재 v3.2.0이 출시되었다.

## package.json 생성

```
$ yarn init -y
```

## package.json 값 설정 (root 폴더, workspaces 활성화)

package.json
`name 값이 프로젝트간 내부 코드상의 import 경로에 사용됨`

```javascript
{
  "name": "@monorepo",
  "version": "1.0.0",
  "main": "index.js",
  "author": "Sung-min Yu <yu9221@gmail.com>",
  "license": "MIT",
  "private": true,
  "workspaces": {
    "packages": [
      "packages/**"
    ]
  }
}
```

## 루트 디렉토리에서 packages 디렉토리 생성 후, 그 안에 pack-a 와 pack-b 패키지를 생성

root 폴더 하위 여러 프로젝트 단위 폴더 생성

```
$ mkdir packages packages/pack-a packages/pack-b
$ cd packages/pack-a
$ yarn init -y
$ cd ../pack-b
$ yarn init -y
```

packages/pack-a/package.json

```javascript
 {
  "name": "@monorepo/pack-a",
  "version": "1.0.0",
  "main": "index.js",
  "author": "Sung-min Yu <yu9221@gmail.com>",
  "license": "MIT"
}
```

packages/pack-b/package.json
`pack-b 프로젝트는 pack-a 1.0.0 버전을 의존`

```javascript
 {
  "name": "@monorepo/pack-b",
  "version": "1.0.0",
  "main": "index.js",
  "author": "Sung-min Yu <yu9221@gmail.com>",
  "license": "MIT",
  "dependencies": {
    "@monorepo/pack-a": "1.0.0"
  }
}
```

## yarn workspace 에서 패키지 추가를 위해서는, 기존 yarn add [패키지 이름]이 아닌, 다른 방법(명령어) 사용

### pack-a 에 패키지 추가 예

```
$ yarn workspace pack-a add [패키지 이름]
```

### pack-a 에 패키지 삭제 예

```
$ yarn workspace pack-a remove [패키지 이름]
```

### 루트 디렉토리에 패키지 추가 예

```
$ yarn add [패키지 이름] -W
```

## 특정 프로젝트에서 다른 프로젝트의 모듈(코드) import 하여 사용하는 예

pack-a/Button.js

```javascript
import React from 'react';
export const Button = props => {
  return <button {...props}>{props.children}</button>;
};
```

pack-b/index.js

```javascript
import Head from 'next/head';
import { Button } from '@monorepo/pack-a/Button'; // package.json 의 name 항목의 값 확인 필수!
const Home = () => (
  <div className='container'>
    <Head>
      <title>Create Next App</title>
      <link rel='icon' href='/favicon.ico' />
    </Head>
    <main>
      <h1 className='title'>
        Welcome to <a href='https://nextjs.org'>Next.js!</a>
      </h1>
      <Button>Hello World</Button>
    </main>
  </div>
);
```

### Next.js는 빌드 시 프로젝트 디렉토리 안의 파일들만 트랜스파일 한다.

`next-transpile-modules` 패키지 설정  
외부 모듈도 트랜스파일이 가능

next.config.js

```javascript
const withPlugins = require('next-compose-plugins');
const withTM = require('next-transpile-modules')([
  // 현재 프로젝트 폴더 기준, 외부(다른 프로젝트 경로) 참조
  // 아래 예시의 '@project' 는  package.json name 값
  '@monorepo/pack-a',
]);

module.exports = withPlugins([withTM]);
```

## root 에서 프로젝트 스크립트 실행

```javascript
{
  // ...
  "scripts": {
    "dev:pack-a": "yarn workspace pack-a dev",
    "build:pack-a": "yarn workspace pack-a build",
    "start:pack-a": "yarn workspace pack-a start",
    "test:pack-a": "yarn workspace pack-a test",
    "test:w:pack-a": "yarn workspace pack-a test:w",

    "run:pack-a": "cd packages/blog && yarn develop",
    "run:pack-b": "cd packages/shop && yarn develop",
    "run:all": "npm-run-all --parallel run:pack-a run:pack-b"
  },
  // ...
}
```

## 개별 프로젝트의 스크립트 실행

```
$ yarn workspace pack-a [scripts 명령]
```

---

## yarn workspaces 의 호이스팅(심볼릭링크, 바로가기 형태) 방식 예

root 위치

```
$ yarn workspace pack-a add react
$ yarn workspace pack-b add react
```

위와 같이 실행할 경우,
root 의 node_modules 폴더에 react 패키지가 설치된 것을 볼 수 있다.
(`pack-a, pack-b의 node_modules 디렉토리에 추가되는 것이 아니라, 루트 경로의 node_modules 연결됨. symbolic link`)

## 모든 패키지가 yarn workspaces 의 호이스팅 방식을 지원하는 것은 아님

이를 해결하기 위해서는 nohoist를 사용  
nohoist 항목에 추가된 패키지는 호이스팅 되지 않고 각각의 프로젝트 또는 패키지의 node_modules에 추가

### nohoist 테스트를 위하여 react-router-dom 패키지를 호이스팅되지 않게 추가

root package.json 에 다음과 같이 nohoist 항목을 추가

```javascript
{
  "name": "@monorepo",
  "version": "1.0.0",
  "main": "index.js",
  "author": "Sung-min Yu <yu9221@gmail.com>",
  "license": "MIT",
  "private": true,
  "workspaces": {
    "packages": [
      "packages/**"
    ],
    "nohoist": [
      "**/react-router-dom",
      "**/react-router-dom/**"
    ]
  }
}
```

pack-a에 react-router-dom 패키지를 추가

```
$ yarn workspace pack-a add react-router-dom
```

pack-a에 node_modules 디렉토리가 생기며 안에 react-router-dom 패키지가 있는 것 을 확인

---

## eslint 설정

각 프로젝트별 tsconfig.json 설정을 따르기 위해 setting/overriders에 프로젝트별 설정이 필요  
eslintrc.js

```javascript
{
  files: [
    'packages/디렉토리명/**/*.ts?(x)',
    'packages/디렉토리명/**/*.js?(x)',
  ],
  settings: {
    'import/resolver': {
      typescript: {
        project: path.resolve(
          // tsconfig.json 경로
        ),
      },
    },
  },
},
```

## tsconfig 설정

```javascript
{
  "references": [
    {
      "path": "packages/프로젝트"
    },
    {
      "path": "packages/프로젝트"
    },
  ],
  "compilerOptions": {
    "composite": true,
    "declaration": true,
  }
}
```

### 프로젝트 내부에서 상위 tsconfig 참조해야할 경우

```javascript
{
  "extends": "../../tsconfig.json",
}
```

---

# Lerna, Nx, Turborepo

---
