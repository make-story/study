# 웹뷰에서 핀치줌 구현하기

https://fe-developers.kakaoent.com/2023/230310-webview-pinch-zoom/

```javascript
//index.ts
const screen = document.getElementById('screen') as HTMLElement;
const target = document.getElementById('img-wrapper') as HTMLElement;

// 터치 이벤트 리스너 제어
touchInit(screen, target);
```

```javascript
// touch.ts
export function touchInit(screen: HTMLElement, target: HTMLElement) {
  const state: TransformState = {
    x: 0,
    y: 0,
    scale: 1,
  };

  const setState = ({ x, y, scale }: TransformState) => {
    state.x = x;
    state.y = y;
    state.scale = scale;
    target.style.transform = `translateX(${x}px) translateY(${y}px) scale(${scale})`;
  };

  // 상태 값을 가져오는 함수
  const getState = () => {
    return state;
  };

  pinchZoom({ screen, target, setState, getState });
}
```

```javascript
//pinchZoom.ts
export default function pinchZoom({ screen, target, setState, getState }: Parameters) {
  target.style.transformOrigin = 'top left';

  const handlePinch = ({ zoom, x: centerX, y: centerY }: { zoom: number, x: number, y: number }) => {
    if (zoom === 0) {
      return;
    }

    const { x, y, scale } = getState();

    const zoomWeight = 0.02;
    const nextScale = scale + (zoom > 0 ? zoomWeight : -zoomWeight);

    const biasX = ((centerX - x) * nextScale) / scale - (centerX - x);
    const biasY = ((centerY - y) * nextScale) / scale - (centerY - y);
    const nextX = x - biasX;
    const nextY = y - biasY;

    const nextState = {
      x: nextX,
      y: nextY,
      scale: nextScale,
    };

    setState(nextState);
  };

  screen.addEventListener('touchstart', ev => touchStartHandler({ ev }));
  screen.addEventListener('touchmove', ev => touchMoveHandler({ ev, onPinch: handlePinch }));
  screen.addEventListener('touchend', ev => touchEndHandler({ ev }));
  screen.addEventListener('touchcancel', ev => touchEndHandler({ ev }));
}
```

```javascript
let prevDiff = -1;
const evHistory: Touch[] = [];

// 터치 시작
function touchStartHandler({ ev }: TouchStart) {
  const touches = ev.changedTouches;
  if (evHistory.length + touches.length <= 2) {
    for (let i = 0; i < touches.length; i++) {
      const touch = touches[i];
      evHistory.push(touch);
    }
  }
}

// 터치 끝
function touchEndHandler({ ev }: TouchEnd) {
  const touches = ev.changedTouches;
  for (let i = 0; i < touches.length; i++) {
    const touch = touches[i];
    const index = evHistory.findIndex(cachedEv => cachedEv.identifier === touch.identifier);
    if (index > -1) {
      evHistory.splice(index, 1);
    }
  }
}

// 터치 이동시 핀치 발생 체크
function touchMoveHandler({ ev, onPinch }: TouchMove) {
  const touches = ev.changedTouches;
  for (let i = 0; i < touches.length; i++) {
    const touch = touches[i];
    const index = evHistory.findIndex(cachedEv => cachedEv.identifier === touch.identifier);
    if (index !== -1) {
      evHistory[index] = touch;

      // 두 개의 터치가 진행중인 경우 핀치 줌으로 판단한다
      if (evHistory.length === 2) {
        const xDiff = evHistory[0].clientX - evHistory[1].clientX;
        const yDiff = evHistory[0].clientY - evHistory[1].clientY;
        const curDiff = Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        // 첫 핀치의 경우 비교군이 없으므로 prevDiff가 -1인 경우 생략한다.
        if (prevDiff > 0) {
          const zoom = curDiff - prevDiff;

          const x = (evHistory[0].clientX + evHistory[1].clientX) / 2;
          const y = (evHistory[0].clientY + evHistory[1].clientY) / 2;
          const { top, left } = (ev.currentTarget as HTMLElement).getBoundingClientRect();
          onPinch({ zoom, x: x - left, y: y - top });
        }

        prevDiff = curDiff;
      }
    }
  }
}
```

# react-zoom-pan-pinch

https://morioh.com/p/861bccf43955
