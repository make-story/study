# `자바스크립트 코딩의 기술` 책 정리

## 참고

https://junhobaik.github.io/es2016-es2020/

## 정리

- ES5  
  http://makestory.net/media/#/view/60
- ES6  
  http://makestory.net/media/#/view/276
- ES7  
  http://makestory.net/media/#/view/671
- ES10  
  http://makestory.net/media/#/view/785

`모던 자바스크립트를 작성한다는 것은 간결함, 가독성, 예측 가능성을 갖춘 코드를 작성하는 것을 의미` - 자바스크립트 코딩의 기술 책 p153 내용 중

---

# 유용한 자바스크립트 참고

- Optional chaining  
  ?. 연산자는 . 체이닝 연산자와 유사하게 작동하지만, 만약 참조가 nullish (null 또는 undefined)이라면, 에러가 발생하는 것 대신에 표현식의 리턴 값은 undefined로 단락된다.

```javascript
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};

const dogName = adventurer.dog?.name;
console.log(dogName);
// expected output: undefined

console.log(adventurer.someNonExistentMethod?.());
// expected output: undefined
```

- Nullish 병합 연산자  
  일반적으로 논리 연산자 || 를 사용해 Falsy 체크(0, "", NaN, null, undefined를 확인)하는 경우가 많습니다.  
  여기서 `0이나 "" 값을 유효 값으로 사용하는 경우 원치 않는 결과가 발생`할 수 있는데,  
  `이럴 때 유용한 Nullish 병합(Nullish Coalescing) 연산자 ??를 사용`합니다.

```javascript
const foo = null ?? 'Hello nullish.';
console.log(foo); // Hello nullish.

const bar = false ?? true;
console.log(bar); // false

const baz = 0 ?? 12;
console.log(baz); // 0
```

---

# 1. const로 변하지 않는 값을 표현하라

const 는 블록의 문맥 내에서 재할당할 수 없는 변수 선언입니다.  
즉, 한 번 선언하면 변경할 수 없습니다. 그렇지만 값이 변경되지 않는 것, 즉 불면값이 되는 것은 아닙니다.  
const 에 배열을 할당하는 경우에도 배열의 항목은 바뀔 수 있습니다.

```javascript
const discountable = [];
for (let i = 0; i < cart.length; i++) {
  if (cart[i].discountAvailable) {
    discountable.push(cart[i]);
  }
}

// 또는

const discountable = cart.filter(item => item.discountAvailable);
```

# 2. let 과 const 로 유효 범위 충돌을 줄여라

let 은 재할당할 수 있다는 점에서 var 와 유사합니다.  
그렇지만 var 는 어휘적 유효 범위(lexical scope)를 따르는 반면,  
let 은 블록 유효 범위(block scope)를 따릅니다.

```javascript
let i = 0;
for (i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log('i', i);
  });
}
// i 10
// i 10
// i 10
// i 10
// i 10
// i 10
// i 10
// i 10
// i 10
// i 10
```

```javascript
for (let i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log('i', i);
  });
}
// i 0
// i 1
// i 2
// i 3
// i 4
// i 5
// i 6
// i 7
// i 8
// i 9
```

# 3. 블록 유효 범위 변수로 정보를 격리하라

```javascript
// 기존
function addClick(items) {
  for (var i = 0; i < items.length; i++) {
    items[i].onclick = (function (i) {
      return function () {
        return i;
      };
    })(i);
  }
  return items;
}
const example = [{}, {}];
const clickSet = addClick(example);
clickSet[0].onClick();
```

```javascript
// 변경
function addClick(items) {
  for (let i = 0; i < items.length; i++) {
    items[i].onclick = function () {
      return i;
    };
  }
  return items;
}
const example = [{}, {}];
const clickSet = addClick(example);
clickSet[0].onClick();
```

---

# 4. 템플릿 리터럴로 변수를 읽을 수 있는 문자열로 변환하라

```javascript
function greet(name) {
  return `Hi, ${name}`;
}
greet('YSM');

function yell(name) {
  return `HI, ${name.toUpperCase()}!`;
}
yell('Ysm');

function leapYearConverter(age) {
  return `윤년에 태어났다면 ${Math.floor(age / 4)}살이아.`;
}
leapYearConverter(34);
```

# 5. 배열로 유연한 컬렉션을 생성하라 - p46 책 내용 확인 필요

자바스크립트에는 데이터 컬렉션을 다루는 구조로 배열과 객체, 이렇게 두 가지가 있었습니다.  
그런데 모던 자바스크립트에 새로운 구조가 등장했습니다.  
이제는 `맵(Map), 세트(Set), 워크맵(WeakMap), 위크셋(WeakSet), 객체, 배열을 사용`할 수 있습니다.

## 이터러블

간단히 말해 컬렉션의 현재 위치를 알고 있는 상태에서 컬렉션의 항목을 한 번에 하나씩 처리하는 방법

# 6. Includes() 로 존재 여부를 확인하라

```javascript
// 기존
const sections = ['contact', 'shipping'];
function displayShipping(sections) {
  return sections.indexOf('shipping') > -1; // true 또는 false
}
```

```javascript
// 변경
const sections = ['contact', 'shipping'];
function displayShipping(sections) {
  return sections.includes('shipping'); // true 또는 false
}
```

# 7. 펼침 연산자로 배열을 본떠라

```javascript
// 기존
function removeItem(items, removable) {
  const index = items.indexOf(removable);
  return items.slice(0, index).concat(items.slice(index + 1));
}
```

```javascript
// 변경
function removeItem(items, removable) {
  const index = items.indexOf(removable);
  return [...items.slice(0, index), ...items.slice(index + 1)];
}
```

```javascript
const book = ['A', 'B', 99.9];
function formatBook(title, author, price) {
  return `${title} by ${author} $${price}`;
}
formatBook(...book);
```

# 8. puch() 메서드 대신 펼침 연산자로 원본 변경을 피하라

push() 메서드는 새로운 항목을 배열 뒤에 추가해 원본 배열을 변경합니다.  
즉, 항목을 추가하면 원본 배열을 조작하는 셈이지요.  
다행히 `펼침 연산자를 이용하면 원본 배열이 조작되는 부수 효과를 방지`할 수 있습니다.

```javascript
// 배열의 앞에 추가하기
const titles = ['A', 'B'];
titles.shift('AB'); // 기존
const moreTitles = ['A', 'B'];
const evenMoreTitles = ['C', ...moreTitles]; // 추천
// 복사하기
const toCopy = ['A', 'B'];
const copied = toCopy.slice(); // 기존
const moreCopies = ['A', 'B'];
const moreCopied = [...moreCopies]; // 추천
```

# 9. 펼침 연살자로 정렬에 의한 혼란을 피하라

`펼침 연산자로 원본 배열의 사본을 생성하고, 사본을 조작`

```javascript
// 사본 형태로 조작
const staff = [
  {
    years: 10,
  },
  {
    years: 5,
  },
  {
    years: 10,
  },
];
[...staff].sort(function (a, b) {
  if (a.years === b.years) {
    return 0;
  }
  return a.years - b.years; // 오름차순
});
```

---

`중요!!! 부분!!! - 특수한 컬렉션을 이용해 코드 명료성을 극대화하라`

# 10. 객체를 이용해 정적인 키-값을 탐색하라

원칙적으로 `객체는 변화가 없고 구조화된 키-값 데이터를 다루는 경우에 유용`합니다.  
반면에 자주 갱신되거나 실행되기 전에는 알 수 없는 동적인 정보를 다루기에는 적합하지 않습니다.

```javascript
const colors = {
  red: '#d10202',
};
```

(개발자는 적색에 적절한 색상 코드를 찾기 위해 사람이 인지가능한 명시적 key 값으로 바로 접근)  
`핵심은 객체가 정적인 정보에 적합하는 것입니다.`

`계속해서 갱신, 반복, 대체, 정렬해야 할 정보에는 적절하지 않습니다. 이때는 맵을 사용하는 것이 낫습니다.`

객체는 정보의 경로를 알고 있을 때 적절한 방법입니다.  
설정 파일을 종종 객체로 작성하는데, 설정 파일이 런타임 전에 설정되고 단순한 정적인 정보를 담은 키-값 저장소이기 때문입니다.

그렇지만 정적인 객체도 프로그래밍으로 정의할 수 있습니다.  
예를 들어 함수 내에 객체를 생성하고 다른 함수에 넘겨줄 수 있습니다.  
정보를 수집하고 전달해 다른 함수에서 사용하는 것입니다.

`정리: 변하지 않는 것은 객체({})를 사용, 변하는 것은 맵(new Map)을 사용`

# 11. Object.assign() 으로 조작 없이 객체를 생성하라

```javascript
// 기존 객체 추가/변경 방식
const defaults = {
  author: '',
  title: '',
  year: 2017,
  rating: null,
};

const book = {
  author: 'Joe Morgan',
  title: 'Simplifying JavaScript',
};

function addBookDefaults(book, defaults) {
  const fields = Object.keys(defaults);
  const updated = {};
  for (let i = 0; i < fields.length; i++) {
    const field = fields[i];
    updated[field] = book[field] || defaults[field];
  }
  return updated;
}

// 추천 방식
Object.assign(defaults, book);

// 원본객체를 갱신하지 않고 조작 방법
const updated = Object.assign({}, defaults, book);
```

```javascript
// 중첩된 객체 복사 방법
const defaultEmployee = {
  name: {
    first: '',
    last: '',
  },
  years: 0,
};
const employee = Object.assign({}, defaultEmployee);
```

중첩된 객체가 있는 객체를 복사하는 것을 `깊은 복사(deep copy)` 또는 `깊은 병합(deep merge)`이라고 합니다.  
위 예제 코드에서 year 속성은 문제없이 복사할 수 있지만, `name 속성은 복사(깊은복사)할 수 없습니다.`

```javascript
const employee = Object.assign({}, defaultEmployee, {
  name: Object.assign({}, defaultEmployee.name),
});
```

# 12. 객체 펼침 연산자로 정보를 갱신하라

```javascript
const book = {
  title: 'A',
  author: 'B',
};
const update = { ...book, year: 1984 };
```

```javascript
// 중첩된 객체 복사하는 방법
const defaultEmployee = {
  name: {
    first: '',
    last: '',
  },
  years: 0,
};
const employee = {
  ...defaultEmployee,
  name: {
    ...defaultEmployee.name,
  },
};
```

# 13. 맵으로 명확하게 키-값 데이터를 갱신하라

`맵은 객체와 다르게 키-값 쌍을 자주 변경하는 경우에 적합하도록 특별히 설계`되었습니다.  
인터페이스가 명확하고, 메서드는 예측 가능한 이름을 가지고 있으며, 반복과 같은 동작이 내장되어 있습니다.

## '브라우저 엔진'

맵은 좀 더 특화된 컬렉션이므로 자바스크립트 엔진 개발자들은 코드가 좀 더 빠르게 동작하도록 최적화 할 수 있습니다.  
객체에서 키 탐색은 선형 시간이 소요됩니다. 반면에 맵이 브라우저에 내장 구현된 경우 맵의 키 탑색은 로그 시간이 될 수 있습니다.  
즉, 큰 객체가 큰 맵보다 비용이 더 큽니다.  
리액트 같은 몇몇 프로젝트에서 단순히 성능 개선을 목적으로 객체 대신 브라우저에 내장된 맵으로 전환한 사례도 있습니다.  
https://github.com/facebook/react/pull/7232#issuecomment-231516712  
객체와 뱁을 두고 성능을 가늠할 필요는 없지만, 브라우저 엔진에서 둘을 서로 다르게 다룬다는 점을 기억하길 바랍니다.

```javascript
let filters = new Map().set('견종', '래브라도레트리버').set('크기', '대형견').set('색상', '갈색');
filters.get('크기'); // 대형견
```

```javascript
let filters = new Map([
  ['견종', '래브라도레트리버'],
  ['크기', '대형견'],
  ['색상', '갈색'],
]);
filters.get('색상'); // 갈색

filters.delete('색상');
filters.get('색상'); // undefined

filters.clear();
filters.get('크기'); // undefined

filters.keys();
```

```javascript
const petFilters = new Map();
function addFilters(filters, key, value) {
  filters.set(key, value);
}
function deleteFilters(filters, key) {
  filters.delete(key);
}
function clearFilters(filters) {
  filters.clear();
}
```

```javascript
let errors = new Map([
  [100, '이름이 잘못되었습니다'],
  [110, '이름에는 문자만 입력할 수 있습니다.'],
]);
errors.get(100);
```

# 14. 맵과 펼침 연산자로 키-값 데이터를 순회하라 - p104 책 내용 확인 필요

맵 + 펼침연산자 활용

```javascript
const filters = new Map().set('견종', '래브라도레트리버').set('크기', '대형견').set('색상', '갈색');
```

```javascript
function ckeckFilters(filters) {
  for (const entry of filters) {
    console.log(entry);
    // ['견종', '래브라도레트리버']
    // ['크기', '대형견']
    // ['색상', '갈색']
  }
}
```

```javascript
function getAppliedFilters(filters) {
  const applied = [];
  for (const [key, value] of filters) {
    applied.push(`${key}:${value}`);
  }
  return `선택한 조건은 ${applied.join(', ')} 입니다`;
}
```

```javascript
// Map 정렬
function sortByKey(a, b) {
  return a[0] > b[0] ? 1 : -1;
}
function getSortedAppliedFilters(filters) {
  const applied = [];
  for (const [key, value] of [...filters].sort(sortByKey)) {
    applied.push(`${key}:${value}`);
  }
  return `선택한 조건은 ${applied.join(', ')} 입니다`;
}
```

```javascript
// 함수형(선언적) 프로그래밍
function getSortedAppliedFilters(filters) {
  const applied = [...filters]
    .sort(sortByKey)
    .map(([key, value]) => {
      return `${key}:${value}`;
    })
    .join(', ');
  return `선택한 조건은 ${applied.join(', ')} 입니다`;
}
```

# 15. 맵 생성시 부수 효과를 피하라

```javascript
let filters = new Map().set('색상', '검정색');
let filters2 = new Map().set('색상', '갈색');
let update = new Map([...filters, ...filters2]);
update.get('색상'); // 갈색
```

`맵을 병합하고 새로운 맵을 생성하는 것`

```javascript
function applyDefaults(map, defaults) {
  return new Map([...defaults, ...map]);
}
```

# 16. 세트를 이용해 고윳값을 관리하라

```javascript
const colors = ['검정색', '검정색', '갈색'];
const unique = new Set(colors); // {'검정색', '갈색'}
```

```javascript
function getUnique(attributes) {
  return [...new Set(attributes)];
}
```

```javascript
let names = new Set();
names.add('joe');
names.add('bea');
names.add('joe');
// Set { 'joe', 'bea' }
```

```javascript
const dogs = [
  {
    name: '맥스',
    color: '검정색',
  },
  {
    name: '도니',
    color: '검정색',
  },
  {
    name: '섀도',
    color: '갈색',
  },
];
function getUniqueColors(dogs) {
  const unique = new Set();
  for (const dog of dogs) {
    unique.add(dog.color);
  }
  return [...unique];
}
```

---

# 17. 거짓 값이 있는 조건문을 축약하라

`거짓 값의 목록`  
https://developer.mozilla.org/ko/docs/Glossary/Falsy

- false
- null
- 0
- NaN
- ''
- ""

참 값의 목록  
https://developer.mozilla.org/ko/docs/Glossary/Truthy

```javascript

```

# 18. 삼항 연산자로 빠르게 데이터를 확인하라

```javascript
// 비효율
let permissions;
if (title === '과장') {
  permissions = ['근로시간', '수당'];
} else {
  permissions = ['근로시간'];
}
```

```javascript
// 추천
const permissions = title === '과장' ? ['근로시간', '수당'] : ['근로시간'];
```

다만 한 가지 주의할 점이 있습니다.  
`삼항 연산자를 여러 개 연결해서 사용할 수는 있지만 가급적 피하는 것이 좋습니다.`
(삼항 연산자 코드가 복잡해지는 경우, 독립적인 함수로 만들고 이를 호출하는게 좋음)

```javascript
// 비추천
const permissions =
  title === '부장' || title === '과장'
    ? title === '과장'
      ? ['근로시간', '초과근무승인', '수당']
      : ['근로시간', '초과근무승인']
    : ['근로시간'];

// 위 코드 보다는 확인을 위한 코드를 완전히 블록 외부로 분리해서 독립적인 함수로 이동시키는 것이 좋습니다.
function getTimePermissions({ title }) {
  if (title === '과장') {
    return ['근로시간', '초과근무승인', '수당'];
  }
  if (title === '부장') {
    return ['근로시간', '초과근무승인'];
  }
  return ['근로시간'];
}
const permissions = getTimePermissions({ title: '사원' });
```

# 19. 단락 평가를 이용해 효율성을 극대화하라

```javascript
const name = 'joe' || 'I have no name';
```

---

# 20. 화살표 함수로 반복문을 단순하게 만들어라

배열 메서드와 화살표 함수를 사용하면 편리하게 데이터 컬렉션을 갱신할 수 있습니다.

```javascript
const formatUser = name => `${name}님이 로그인했습니다.`;
```

# 21. 배열 메서드로 반복문을 짧게 작성하라

## map( callback(currentValue[, index[, array]])[, thisArg] )

- 동작 : 형태를 바꿀 수 있지만 길이는 유지됩니다.

## sort( [compareFunction] )

- 동작 : 형태나 길이는 변경되지 않고 순서만 바꿉니다.

## filter( callback(element[, index[, array]])[, thisArg] )

- 동작 : 길이를 변경하지만 형태는 바꾸지 않습니다.

## find( callback[, thisArg] )

- 동작 : 배열을 반환하지 않습니다. 한 개의 데이터가 반환되고 형태는 바뀌지 않습니다.

## forEach( callback(currentvalue[, index[, array]])[, thisArg] )

- 동작 : 형태를 이용하지만 아무것도 반환하지 않습니다.

## reduce( callback[, initialValue] )

- 동작 : 길이와 형태를 바꾸는 것을 비롯해 무엇이든 처리할 수 있습니다.

```javascript

```

# 22. map() 메서드로 비슷한 길이의 배열을 생성하라

```javascript
const band = [
  {
    name: 'corbett',
    instrument: 'guitar',
  },
  {
    name: 'evan',
    instrument: 'guitar',
  },
  {
    name: 'sean',
    instrument: 'bass',
  },
];
const instruments = band.map(member => member.instrument);
// ['guitar', 'guitar', 'bass']
```

# 23. filter() 와 find() 로 데이터의 부분집합을 생성하라

`중요! 클로저 활용`

```javascript
const instructors = [
  {
    name: '짐',
    libraries: ['미디어교육정보 도서관'],
  },
  {
    name: '새라',
    libraries: ['기념 도서관', '문헌정보학 도서관'],
  },
];

const findByLibrary =
  (libarary = '기념 도서관') =>
  instructor => {
    return instructor.libraries.includes(libarary);
  };
const librarian = instructors.find(findByLibrary('미디어교육정보 도서관'));
/*
{
	name: '짐',
	libraries: ['미디어교육정보 도서관']
}
*/
```

# 24. forEach() 로 동일한 동작을 적용하라

```javascript
const names = ['walter', 'white'];
let capitalized = [];
names.forEach(name => capitalized.push(name.toUpperCase()));
// ['WALTER', 'WHITE']
```

# 25. 체이닝으로 메서드를 연결하라

`중요!`

```javascript
const sailors = [
  {
    name: 'test1',
    active: true,
    email: 'test1@test.com',
  },
  {
    name: 'test2',
    active: true,
    email: '',
  },
  {
    name: 'test3',
    active: false,
    email: '',
  },
];
// 체이닝
sailors
  .filter(sailor => sailor.active)
  .map(sailor => sailor.email || `${sailor.name}@test.com`)
  .forEach(sailor => sendEmail(sailor));
```

# 26. reduce() 로 배열 데이터를 변환하라

```javascript
const developers = [
  {
    name: 'Jeff',
    language: 'php',
  },
  {
    name: 'Ashley',
    language: 'python',
  },
  {
    name: 'Sara',
    language: 'python',
  },
];
// 언어 카운트
const aggregated = developers.reduce((specialities, developer) => {
  const count = specialities[developer.language] || 0;
  return {
    ...specialities,
    [developer.language]: count + 1,
  };
}, {});
```

# 27. for...in 문과 for...of 문으로 반복문을 정리하라

for...of 문을 사용하면 특수한 객체를 배열로 변환하는 대신, for 문과 도일한 개념을 사용하면서 색인에 대한 참조를 제거할 수 있습니다.

```javascript
const firms = new Map().set(10, 'Ivie Group').set(23, 'Soundscaping Source').set(31, 'Big 6');
function checkConflicts(firms, isAvailable) {
  for (const firm of firms) {
    const [id, name] = firm;
    if (!isAvailable(id)) {
      return `${name}는 사용할 수 없습니다.`;
    }
  }
  return 'All firms are available';
}

checkConflicts(firms, id => id !== 23);
```

for...in 문은 for...of 문과 매우 유사합니다.  
객체에 필요한 작업을 직접실행하기 때문에 Object.keys()를 실행해서 객체의 키를 배열로 변환하는 과정을 생략할 수 있습니다.  
더 정확히 말하면 객체의 속성을 순회합니다.

여기서 한가지 주의해야할 사항이 있습니다.  
`객체를 순회하면서 객체를 조작하지 마세요.`  
`객체를 조작하는 것은 매우 위험하고, 특히 반복 중인 속성 외의 다른 속성을 추가하거나 수정하는 경우에는 버그가 빠르게 퍼질 수 있습니다.`

---

# 28. 매개변수 기본값을 생성하라

```javascript
function convertWeight(weight, ounces = 0, roundTo = 2) {
  const total = weight + ounces / 16;
  const conversion = total / 2.2;
  // ...
}
// 기본값 작동
convertWeight(4);
convertWeight(4, undefined, 2);
```

# 29. 해체 할당으로 객체 속성에 접근하라

```javascript
const landscape = {
  photographer: 'Nathan',
};
const { photographer } = landscape;
console.log(photographer); // Nathan
```

```javascript
const landscape = {
  location: [32.7122222, -103.1405556],
};
const {
  location: [latitude, longitude],
} = landscape;
console.log(latitude); // 32.7122222
console.log(longitude); // -103.1405556
```

# 30. 키-값 할당을 단순화하라

해체 할당, 펼침 연산자 적극활용
객체를 빠르게 만드는 방법

```javascript
function getRegion({ location, ...details }) {
  const { city, state } = determineCityAndState(location);
  return {
    city,
    state: state.abbreviation,
    ...details,
  };
}
```

# 31. 나머지 매개변수로 여러 개의 인수를 변수로 전달하라

나머지 매개변수를 이용해  
개수를 알 수 없는 다수의 매개변수를 전달하는 방법

```javascript
function getArguments(...args) {
  return args;
}
getArguments('A', 'B'); // ['A', 'B']
```

```javascript
function validateCharacterCount(max, ...items) {
  return items.every(item => max < item.length);
}
validateCharacterCount(10, 'wvoquie'); // true
validateCharacterCount(10, 'Hobbs', 'Eagles'); // true
const tags = ['Hobbs', 'Eagles'];
validateCharacterCount(10, ...tags); // true
```

```javascript
const queue = ['A', 'B', 'C'];
const [first, ...remaining] = queue;
console.log(first); // A
console.log(remaining); // ['B', 'C']
```

======================================================================

# 32. 테스트하기 쉬운 함수를 작성하라

테스트할 수 있는 코드를 작성하는 것에 집중해야 합니다.  
테스트 가능한 코드를 작성하면 코드가 점차 개선되고,  
테스트를 작성하기 쉬워지며,  
사용자 경험도 개선될 것입니다.

대표적인 테스트 프레인워크

- 재스민(Jasmine) https://jasmine.github.io
- 모카(Mocha) https://mochajs.org
- 제스트(Jest) https://facebook.github.io/jest/

책에서 활용하는 도구는 '모카'

외부 참조가 있는 함수 - 테스트할 때 어려운 부분

```javascript
import { getTaxInformation } from './taxService';

function formatPrice(user, { price, location }) {
  const rate = getTaxInformation(location); // <label id="test.external" />
  const taxes = rate ? `plus $${price * rate} in taxes.` : 'plus tax.';

  return `${user} your total is: ${price} ${taxes}`;
}

export { formatPrice };
```

`코드의 결합을 제거하려면 getTaxInformation() 을 인자로 전달하는 것만으로 충분합니다. - 고차함수`

```javascript
function formatPrice(user, { price, location }, getTaxInformation) {
  const rate = getTaxInformation(location);
  const taxes = rate ? `plus $${price * rate} in taxes.` : 'plus tax.';
  return `${user} your total is: ${price} ${taxes}`;
}

export { formatPrice };
```

# 33. 화살표 함수로 복잡도를 낮춰라

인수를 해체 할당하는 방법,  
객체를 반환하는 방법,  
고차 함수를 마드는 방법

```javascript
const comic = {
  first: 'Peter',
  last: 'Bagge',
  city: 'Seattle',
  state: 'Washington',
};
//const getName = { first, last } = `${first} ${last}`; // 에러!
const getName = ({ first, last }) => `${first} ${last}`;
getName(comic);

// 개게를 반환하는 경우에는 객체를 괄호로 감싸야 합니다.
const getFullName = ({ first, last }) => ({ fullname: `${first} ${last}` });

// 고차함수는 그저 다른 함수를 반환하는 함수일 뿐이므로 초기 매개변수는 다를 것이 없습니다.
// 그리고 다른 때와 마찬가지로 함수 몸체에서 다른 함수를 반환하게 만들면 됩니다.
const discounter = disount => price => price * (1 - discount);
discounter(0.1)(100); // 90
```

# 34. 부분 적용 함수로 단일 책임 매개변수를 관리하라

부분 적용 함수(partially applied function)로 매개변수를 집중시키는 방법

고차 함수는 매개변수를 가두는 방법을 통해 특별한 값을 제공하므로,  
나중에 원래의 인수에 접근할 수 있게 해두고 함수 실행을 마칠 수 있습니다.  
또한, 매개변수를 분리해 함수의 의도를 명확하게 유지할 수 있습니다.

`고차 함수는 다른 함수를 반환하는 함수`입니다.  
즉, 함수 실행이 완전히 끝날 때까지 최소한 두 단계를 걸친 매개변수가 존재합니다.  
부분 적용 함수를 사용할 경우, 일부 매개변수를 전달하면 해당 매개변수를 잠그는 함수가 반환되어 여기에 더 많은 매개변수를 사용할 수 있습니다.  
즉, 부분 적용함수를 이용하면 한 번에 전달해야 할 함수 인수의 수(항수)가 줄어드는 대신 인수를 더 전달해야 하는 다른 함수를 반환합니다.

`여러 매개변수가 있는 특정함수를 호출할 때마다 전달하는 첫 번째 매개변수가 항상 동일할 때 사용 추천!`

```javascript
const building = {
	hours: '8 a.m.'
	address: '',
};

const manager = {
	name: 'Augusto',
	phone: '000-000-0000',
};

const program = {
	name: 'Presenting',
	room: '415',
	horus: '3 - 6',
};

const exhibit = {
	name: 'Emerging',
	contact: 'Dyan',
};

// 하나의 정보 집합으로 결합하는 함수 - 일반적 방식
function mergeProgramInformation(building, manager, event) {
	const { hours, address } = building;
	const { name, phone } = manager;
	const defaults = {
		hours,
		address,
		contact: name,
		phone,
	};

	return { ...defaults, ...event };
}

// 코드를 살펴보면, 함수를 호출할 때마다 전달하는 첫 번째 매개변수는 building 으로 항상 동일합니다.
const programInfo = mergeProgramInformation(building, manager, program);
const exhibitInfo = mergeProgramInformation(building, manager, exhibit);
```

```javascript
// 하나의 정보 집합으로 결합하는 함수 - 추천 방식
function mergeProgramInformation(building, manager) {
  const { hours, address } = building;
  const { name, phone } = manager;
  const defaults = {
    hours,
    address,
    contact: name,
    phone,
  };

  return program => {
    return { ...defaults, ...program };
  };
}

const programInfo = mergeProgramInformation(building, manager)(program);
const exhibitInfo = mergeProgramInformation(building, manager)(exhibit);
```

# 35. 커링과 배열 메서드를 조합한 부분 적용 함수를 사용하라

함수의 부분 적용을 통해 변수를 저장해두는 방법

고차 함수를 이용하면 매개변수를 별도로 분리할 수 있습니다.  
그렇지만 `함수를 완전히 분리하기 전에 함수에 필요한 인수의 수를 줄일 수 있도록 인수를 분리하는 것이 훨씬 더 중요`합니다.
한 번에 인수를 하나만 받는 것을 '커링'이라고 하며, 이는 하나의 인수만 전달하는 메서드를 다룰 때 매우 유용합니다.  
자바스크립트는 순수한 형태의 커링을 완벽하게 지원하지는 않지만, 부분 적용을 이용해서 일련의 단일 매개변수로 매개변수 숫자를 줄이는 방법이 일반적입니다.

## 커링과 부분 적용

부분 적용(partial application) 함수는 매개변수를 여러 번 받을 수 있습니다.  
그래서 종종 커링과 혼동됩니다.  
실제로 커링과 부분 적용 함수는 매우 비슷하지만, 이 둘은 엄연히 다릅니다.

`부분 적용함수와 커링 함수는 모두 원래보다 필요한 인수의 수가 적은 함수를 반환해 인수 수를 줄입니다.`  
함수에는 함수가 받을 수 있는 전체 인수의 수가 있으며 항수라고 부릅니다.

부분 적용 함수는 원래의 함수보다 항수가 적은 함수를 반환합니다.  
인수가 총 세 개 필요한 경우에 인수 두 개를 먼저 전달했다면, 여기서 반환된 함수에는 인수가 하나만 있으면 됩니다.  
원래의 함수는 세 개의 인수가 필요했습니다. 여기에 부분 적용 함수를 이용하면 항수가 하나인 함수를 반환합니다.

반면에 커링 함수는 여러 개의 인수를 받는 함수에서 정확히 인수 하나만 받는 일련의 함수를 반환할 때 사용합니다.  
가령 인수 세 개가 필요한 함수가 있다면, 먼저 인수 하나를 받는 고차함수가 다른 함수를 반환하고, 반환된 함수도 인수 하나를 받습니다.  
이 함수에서 끝으로 인수 하나를 받는 마지막 함수가 반환됩니다.

```javascript
// partial
// 함수를 한 번 호출해 저장해둔 매개변수를 다시 사용하는 것은 내부 변수를 미리 알고 있는 함수를 선언하는 것과 같습니다.
const setStrongHallProgram = mergeProgramInformation(building, manager);
const programInfo = setStrongHallProgram(program);
const exhibitInfo = setStrongHallProgram(exhibit);
```

위와 동일

```javascript
// curry
const setStrongHallProgram = program => {
	const defaults = {
		hours: '8 a.m.'
		address: '',
		name: 'Augusto',
		phone: '000-000-0000',
	};
	return { ...defaults, ...program };
}
const programs = setStrongHallProgram(program);
const exhibit = setStrongHallProgram(exhibit);
```

```javascript
const dogs = [
  {
    이름: '맥스',
    무게: 10,
    견종: '보스턴테리어',
    지역: '위스콘신',
    색상: '검정색',
  },
  {
    이름: '도니',
    무게: 90,
    견종: '보스턴테리어',
    지역: '캔자스',
    색상: '검정색',
  },
  {
    이름: '새도',
    무게: 40,
    견종: '보스턴테리어',
    지역: '위스콘신',
    색상: '갈색',
  },
];

// 일반적 방식
function getDogNames(dogs, filter) {
  const [key, value] = filter;
  return dogs.filter(dog => dog[key] === value).map(dog => dog['이름']);
}

getDogNames(dogs, ['색상', '검정색']); // ['맥스', '도니']
```

```javascript
// 추천
function getDogNames(dogs, filterFunc) {
  return dogs.filter(filterFunc).map(dog => dog['이름']);
}

getDogNames(dogs, dog => dog['무게'] < 20); // ['맥스']
```

```javascript
// 추천
const weightCheck = weight => dog => dog['무게'] < weight;

getDogNames(dogs, weightCheck(20)); // ['맥스']
getDogNames(dogs, weightCheck(50)); // ['맥스', '새도']
```

# 36. 화살표 함수로 문맥 혼동을 피하라 - this

화살표 함수를 이용해 문맥 오류를 피하는 방법

화살표 함수는 함수를 호출할 때 this 바인딩을 새로 만들지 않습니다.

```javascript
const validator = {
  message: 'is invalid.',
  setInvalidMessages(...fields) {
    return fields.map(function (field) {
      return `${field} ${this.message}`;
    });
  },
};

validator.setInvalidMessages('도시');
// 타입 오류: undefined 의 속성 'message'를 읽을 수 없습니다.
```

함수를 호출할 때 마다 호출되는 위치를 바탕으로 this 바인딩을 만듭니다.  
map() 메서드에 콜백 함수로 전달한 경우에는 map() 메서드의 문맥에서 호출되므로 이 경우에는 this 바인딩이 validator 객체가 아닙니다.  
이때의 문맥은 전역객체가 됩니다. 브라우저에서는 window 가 Node.js REPL 환경에서는 global 이 될 것입니다.

화살표 함수를 이용하면 이런 문제를 해결할 수 있습니다.  
화살표 함수는 함수를 호출할 때 this 바인딩을 새로 만들지 않습니다.

```javascript
const validator = {
  message: 'is invalid.',
  setInvalidMessages(...fields) {
    return fields.map(field => {
      return `${field} ${this.message}`;
    });
  },
};

validator.setInvalidMessages('city');
// ['city is invalid.]
```

======================================================================

# 37. 읽기 쉬운 클래스를 만들어라

```javascript

```

# 38. 상속으로 메서드를 공유하라

```javascript

```

# 39. 클래스로 기존의 프로토타입을 확장하라

```javascript

```

# 40. get 과 set 으로 인터페이스를 단순하게 만들어라

```javascript

```

# 41. 제너레이터로 이터러블 속성을 생성하라

```javascript

```

# 42. bind() 로 문맥 문제를 해결하라

```javascript

```

======================================================================

# 43. 프라미스를 이용해 비동기적으로 데이터를 가져오라

```javascript

```

# 44. async / await 함수를 명료하게 생성하라

```javascript

```

# 45. fetch 로 간단한 AJAX 호출을 처리하라

```javascript

```

# 46. localStorage 로 상태를 장기간 유지하라

```javascript

```

---

# 47. 가져오기와 내보내기로 기능을 분리하라

```javascript

```

# 48. npm 으로 커뮤니티 코드를 끌어와라

```javascript

```

# 49. 컴포넌트 아키텍쳐를 이용해 애플리케이션을 만들어라

```javascript

```

# 50. 빌드 도구를 이용해 컴포넌트를 결합하라

```javascript

```

# 51. CSS 애니메이션을 활용하라

```javascript

```
