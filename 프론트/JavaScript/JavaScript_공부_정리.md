# -동등연산자(==), 일치(===)연산자

- ==연산자는 비교하려는 피연산자의 타입이 다를 경우 타입 변환을 거친 다음 비교
- ===연산자는 피연산자의 타입이 다를경우에 타입을 변경하지 않고 비교

```javascript
console.log(1 == '1'); // true
console.log(1 === '1'); // false
```

# 함수객체가 가지고 있는 것

length (인자의 개수를 나타낸다)  
모든 함수는 객체로서 prototype 프로퍼티를 가지고 있다.  
ECMA 표준에서는 함수 객체의 부모 역할을 하는 프로토타입 객체를 Function. prototype 객체라고 명명하고 있으며, 이것 역시 함수 객체라고 정의하고 있다. (크롬브라우저에서는 Empty() 함수라고 명하고 있음)

# 빌트인

자바스크립트는 빌트인 덕분에 동적생성, 타입변환 등이 유동적으로 가능하다.  
빌트인은 배열, 함수, 정규식 등이 브라우저 내장된 객체를 이용해 객체인스턴스가 생성되는 개념

# 실행 콘텍스트 생성 기준

1. 함수코드 (function code)
2. 글로벌코드 (global code)
3. eval코드 (eval code)

ECMA 에서는 실행컨텐스트가 형성되는 경우를 세가지로 규정  
1 전역코드, 2 eval함수, 3 함수안의 코드를 실행

# 자바스크립트 함수 실행단계

1. 실행 콘텍스트 환경을 설정
2. 함수 안의 전체코드에서 함수선언문의 함수를 Function Object로 생성합니다.
3. 다시 함수의 처음으로 올라가 변수를 바인딩 합니다.
4. 다시 함수의 처음으로 돌아가 코드를 실행합니다.

# 호이스팅

함수 호이스팅은 자바스크립트의 변수생성(Instantiation)과 초기화 (Initialization)의 작업이 분리되어 진행되기 때문에 발생

# 스코프

```javascript
// 스코프 퀴즈 - var
(function () {
  var a = 'bbb';
  console.log('A: ' + a); // bbb
  function test1() {
    console.log('B: ' + a); // undefined
    (function () {
      console.log('C: ' + a); // undefuned
      a = 'ccc';
    })();
    var a;
    console.log('D: ' + a); // ccc
  }
  function test2() {
    console.log('E: ' + a); // ddd
  }
  test1();
  a = 'ddd';
  test2();
})();
```

```javascript
// 클로저 방식에서의 스코프 생성시점 증명 예제
// 함수객체가 실행될때 상위 스코프리스트 기반으로 내부스코프를 연결리스트로 붙여 스코프리스트 만듦
var test = 'test';
function a(c) {
  // a 함수객체가 실행되는 시점에 글로벌 스코프와 test 변수 스코프정보 담고 있음
  var b = 'a';
  return function () {
    // 무명함수객체가 실행되는 시점에 상위 함수 스코프기반으로 연결리스트 형태로 내부스코프 b변수 정보를 추가하여 스코프리스트 만듦
    alert(test);
    return c();
  };
}
function e() {
  // a함수의 파라미터로 e 함수를 넘겼지만, e 함수객체가 실행되는 시점에 b 변수는 없다. (즉, 함수가 실행되는 시점의 스코프체이닝에는 b변수가 없다.)
  alert(b); // 렉시컬 환경에 따라 실행 안된다.
}
var hi = a(e);
hi();
```

# 반복문 작동원리

```
for(초기화(순서1); 반복조건(순서2); 반복이 될 때마다 실행되는 코드(순서4, 이후 2,3,4반복)) {
    반복해서 실행될 코드(순서3)
    break 문을 만나면 '반복이 될 때마다 실행되는 코드'를 거치지 않고 for문을 바로 빠져나간다.
}
```
