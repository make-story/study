`함수형 자바스크립트 입문` 책 정리

# 커링(curring)과 부분적용(partial application)

> 단항함수
> 함수인자를 하나만 취하는 함수를 단항함수(unary function) 라 한다.

```javascript
const identity = x => x;
```

---

## 커링

`커링은 n개 인자의 함수를 중첩된 단항 함수로 변화시키는 과정이다.`

```javascript
const add = (x, y) => x + y;
```

커링된 add 함수

```javascript
const addCurried = x => y => x + y;
addCurried(4)(4); // 8
```

커링 함수 정의

```javascript
const curry = binaryFn => {
  return function (firstArg) {
    return function (secondArg) {
      return binaryFn(firstArg, secondArg);
    };
  };
};
```

커리 함수를 사용해 add 함수를 다음과 같은 형태로 변환할 수 있음

```javascript
let autoCurriedAdd = curry(add);
autoCurriedAdd(2)(2); // 4
```

## 커링을 사용하는 경우

n개 인자 함수를 단항 함수로 변환하는 curry 함수

```javascript
let curry = fn => {
  if (typeof fn !== 'function') {
    throw Error('No function procided');
  }

  return function curriedFn(...args) {
    if (args.length < fn.length) {
      return function () {
        // concat 함수를 사용해 전달된 인자를 한 번에 연결시키고
        // curriedFn 을 재귀적으로 호출한다.
        return curriedFn.apply(null, args.concat([].slice.call(arguments)));
      };
    }
    return fn.apply(null, args);
  };
};
```

logger 함수

```javascript
const loggerHelper = (mode, initialMessage, errorMessage, lineNo) => {
  if (mode === 'DEBUG') {
    console.debug(initialMessage, `${errorMessage} at line: ${lineNo}`);
  } else if (mode === 'ERROR') {
    console.error(initialMessage, `${errorMessage} at line: ${lineNo}`);
  } else if (mode === 'WARN') {
    console.warn(initialMessage, `${errorMessage} at line: ${lineNo}`);
  } else {
    throw 'Wrong mode';
  }
};
```

curry 를 활용해 앞의 두 인자를 반복하면서 해결해보자.

```javascript
let errorLogger = curry(loggerHelper)('ERROR')('Error At Stats.js');
let debugLogger = curry(loggerHelper)('DEBUG')('Debug At Stats.js');
let warnLogger = curry(loggerHelper)('WARN')('Warn At Stats.js');

// 커링된 함수를 쉽게 참조해 각 문맥 안에서 사용할 수 있다.
errorLogger('Error message', 21); // 에러
debugLogger('Debug message', 233); // 디버그
warnLogger('Warn message', 34); // 경고
```

## 커링의 실제 사용

### 배열 요소에서 숫자 검색

```javascript
let match = curry(function (expr, str) {
  return str.match(expr);
});

let hasNumber = match(/[0-9]+/);

let filter = curry(function (f, ary) {
  return ary.filter(f);
});

let findNumbersInArray = filter(hasNumber);

findNumbersInArray(['js', 'number1']); // ["number1"]
```

### 배열 제곱

```javascript
let map = curry(function (f, ary) {
  return ary.map(f);
});

let squareAll = map(x => x * x);
squareAll([1, 2, 3]); // [1, 4, 9]
```

---

## 부분 적용

10밀리초마다 일련의 연산을 처리한다고 가정해보자

```javascript
setTimeout(() => console.log('Do X task'), 10);
setTimeout(() => console.log('Do Y task'), 10);
```

partial 함수 정의

```javascript
const partial = function (fn, ...partialArgs) {
  let args = partialArgs;
  return function (...fullArguments) {
    let arg = 0;
    for (let i = 0; i < args.length && arg < fullArguments.length; i++) {
      if (args[i] === undefined) {
        args[i] = fullArguments[arg++];
      }
    }
    return fn.apply(null, args);
  };
};
```

partial 함수를 사용해보자

```javascript
let delayTenMs = partial(setTimeout, undefined, 10);
delayTenMs(() => console.log('Do Y task'));
```

```javascript
let obj = { foo: 'bar', bar: 'foo' };
JSON.stringify(obj, null, 2);
// JSON.stringify 로 호출된 함수의 마지막 두 인자는 항상 null 과 2 로 동일할 것이다.
// partial 을 사용해 이런 부분을 제거 할 수 있다.
let prettyPrintJson = partial(JSON.stringify, undefined, null, 2);
prettyPrintJson({ foo: 'bar', bar: 'foo' });
```
