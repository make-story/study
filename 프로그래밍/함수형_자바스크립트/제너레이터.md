`함수형 자바스크립트 입문` 책 정리

# 제너레이터를 통한 정지, 재개, 비동기

제너레이터는 ES6에서 함수의 새로운 스팩이다.  
제너레이터는 실제 함수형 프로그래밍 기술은 아니지만, 함수의 한 부분이다. (함수형 프로그래밍은 함수에 관한 것이다.)

## 비동기 코드와 문제점

콜백 지옥 문제(callback hell problem)를 살펴본다.  
대부분의 비동기 코드 패턴은 제너레이터나 Async/Await 를 사용해 각자의 방법으로 콜백 지옥 문제를 해결한다.

## 제너레이터의 기본

### 제너레이터 생성

```javascript
function* gen() {
  return 'first generator';
}
```

함수 이름 앞에 별표가 있는데, 제너레이터 함수임을 나타낸다.

### 제너레이터의 경고

제너레이터로 작업하는 동안 살펴볼 몇 가지 중요한 사항이 있다.  
첫 번째는 제너레이터에서 값을 얻어야 하므로 next 를 여러 번 호출할 수 없다는 점이다.

```javascript
// 제너레이터 인스턴스 변수를 얻는다.
let generatorResult = gen();

// 첫 번째
generatorResult.next().value; // first generator

// 두 번째
generatorResult.next().value; // undefined
```

이 코드에서 보듯이 next 를 두 번째로 호출하면 'first generator' 가 아닌 'undefined'를 반환한다.  
이는 제너레이터가 시퀀스와 유사하기 때문이다.  
시퀀스의 값은 사용되면 다시 사용할 수 없다.

시퀀스를 다시 사용하려면 또 다른 제너레이터 인스턴스를 생성해야 한다.

```javascript
// 제너레이터 인스턴스 변수를 얻는다.
let generatorResult = gen();
let generatorResult2 = gen();

// 첫 번째 시퀀스
generatorResult.next().value; // first generator

// 두 번째 시퀀스
generatorResult2.next().value; // first generator
```

### yield 키워드

간단한 제너레이터 시퀀스

```javascript
function* generatorSequence() {
  yield 'first';
  yield 'second';
  yield 'third';
}
```

```javascript
// 제너레이터 인스턴스 변수를 얻는다.
let genSeq = generatorSequence();

// 첫 번째 next 를 호출
genSeq.next().value; // 'first'

// next 를 한 번 더 호출할 경우
genSeq.next().value; // 'second'
```

yield 는 제너레이터 함수의 실행을 중지시키고 호출자에게 결과를 다시 보낸다.  
따라서 genSeq 를 첫 번째 호출할 때 함수는 'first' 값을 가진 yield 를 볼 수 있고, 함수를 정지모드로 하며 값을 반환한다.  
(그리고 정확히 정지되는 곳을 기억한다.)  
다음번에 genSeq 를 호출하면(동일한 인스턴스 변수를 사용한다) 제너레이터 함수는 정지된 곳에서 재개된다.

### 제너레이터의 done 속성

제너레이터는 n개의 시퀀스를 생성할 수 있는데,  
제너레이터 함수의 사용자로서 next 호출이 정지됐음을 어떻게 알 수 있을까?  
이미 사용한 제너레이터 시퀀스에서 next 를 호출하면 undefined 값을 반환하기 때문에 알 수 있다.

next 함수를 호출할 때마다 다음과 같은 객체를 반환한다는 점을 기억하자.

```javascript
{ value: 'value', done: false }
```

value 는 제너레이터에서 반환된 값이지만, done 은 어떨까?  
done 는 제너레이터 시퀀스가 전부 사용됐는지 아닌지 말해주는 속성이다.

done 이 true 일 때 제너레이터 인스턴스에서는 next 호출을 멈춰야 한다.

제너레이터가 ES6 의 핵심 부분이 됐으므로, 제너레이터를 반복할 수 있는 for 루프가 있다. (결국 시퀀스다).

```javascript
for (let value of genSeq()) {
  console.log('for of value of genSeq is', value);
  // first
  // second
  // third
}
```

### 제너레이터에 데이터 전달

제너레이터에 데이터를 전달하는 것은 처음에는 헷갈리겠지만,  
비동기 프로그래밍을 쉽게 만들어준다.

제너레이터에 데이터 전달 예제

```javascript
function* sayFullName() {
  let firstName = yield;
  let secondName = yield;
  console.log(`${firstName} ${secondName}`);
}
```

```javascript
// 제너레이터 인스턴스 생성
let fullname = sayFullName();

// 제너레이터 인스턴스가 생성된 후 여기에 next를 호출해보자.
fullname.next();
fullname.next('anto');
fullname.next('aravinth');
// anto aravinth
```

## 비동기 호출 조작에 제너레이터 사용

### 비동기를 위한 제너레이터: 실세계 경우
