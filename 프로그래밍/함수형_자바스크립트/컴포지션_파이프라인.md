`함수형 자바스크립트 입문` 책 정리

# compose 함수

compose 함수 정의

```javascript
const compose = (a, b) => c => a(b(c));
```

두 함수 a와 b를 받아 하나의 인자 c를 갖는 함수를 반환한다.

c에 값을 넣어 compose 함수를 호출하면,  
c의 입력을 갖는 함수 b를 호출하고,
함수 b의 출력은 함수 a의 입력으로 간다.

이것이 바로 compose 함수의 정의다.

## compose 함수 다루기

compose 없이 다음과 같이 할 수 있다.

```javascript
let data = parseFloat('3.56');
let number = Math.round(data);
```

compose 함수로 해결해보자.

```javascript
let number = compose(Math.round, parseFloat); // number = (c) => Math.round(parseFloat(c)) 의미와 동일
number('3.56'); // 4
```

## 여러 함수 합성

compose 함수를 다시 작성해 여러 함수를 합성해보자.

```javascript
const compose =
  (...fns) =>
  value =>
    reduce(fns.reverse(), (acc, fn) => fn(acc), value);
```

함수를 합성해 문자 열에서 주어진 단어 개수를 세어보자.

```javascript
let splitIntoSpaces = str => str.split(' ');
let count = array => array.length;
const countWords = compose(count, splitIntoSpaces);

// 단어 개수 세기
countWords('hello your reading about composition'); // 5
```

주어진 문자열에서의 단어 개수가 홀수인지 짝수인지 알고자 한다.

```javascript
let oddOrEven = ip => (ip % 2 === 0 ? 'even' : 'odd');

const oddOrEvenWords = compose(oddOrEven, count, splitIntoSpaces);
oddOrEvenWords(hello your reading about composition); // odd
```

---

# 파이프라인과 시퀀스

`compose 의 데이터 플로우가 오른쪽에서 왼쪽`  
유닉스 명령어에서 |(파이프기호) 를 사용할 때 데이터 플로우는 윈쪽에서 오른쪽이다.  
`compose 함수와 동일한 동작을 하지만 데이터 플로우가 반대인 pipe`

## 파이프 구현

pipe 함수는 compose 함수의 복제 형태다.

```javascript
const pipe =
  (...fns) =>
  value =>
    reduce(fns, (acc, fn) => fn(acc), value);
```

fns 역함수의 호출은 pipe 안에 더 이상 없는데, 이는 왼쪽부터 오른쪽 순서로 함수를 실행하겠다는 의미다.

```javascript
const oddOrEvenWords = pipe(splitIntoSpaces, count, oddOrEven);
oddOrEvenWords(hello your reading about composition); // odd
```

## 컴포지션은 결합 법칙이 성립한다.

함수형 컴포지션은 항상 결합 법칙을 따른다.  
예를 들어 일반적으로 결합 법칙은 표현의 결과를 괄호 숭서에 상관없이 동일하게 한다.

```javascript
compose(f, compose(f, h)) === compose(compose(f, g), h);
```

```javascript
// compose(compose(f, g), h)
let oddOrEvenWords = compose(compose(oddOrEven, count), splitIntoSpaces);
oddOrEvenWords('hello your reading about composition'); // ['odd']

// compose(f, compose(g, h))
let oddOrEvenWords = compose(oddOrEven, compose(count, splitIntoSpaces));
oddOrEvenWords('hello your reading about composition'); // ['odd']
```

## 파이프라인 연산자

파이프라인 연산자는 자바스크립트 함수 코드의 가독성과 확장성을 높인다.

https://velog.io/@keumky1/%ED%95%A8%EC%88%98%ED%98%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Pipe%EB%A1%9C-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EC%9E%90

파이프라인 연산의 예제를 살펴보자.

```javascript
const double = n => n * 2;
const increment = n => n + 1;
const ntimes = n => n * n;

ntimes(double(increment(double(double(5))))); // 1764
```

이 문장의 문제는 가독성인데, 연산자의 시퀀스와 연산자의 개수는 가독성을 떨어뜨린다.  
코드 가독성을 높이고자 ECMAScript 2017(ECMA8)에 추가된 연산자의 이름은 파이프라인(또는 이항 연산자)이며, `|>` 이다.  
이항 연산자는 좌변을 평가해 우변에 좌변의 값을 단항 함수 호출로 적용한다.

```javascript
5 |> double |> double |> increment |> double |> ntimes; // 1764
```

파이프연산 사용자 함수로 구현

```javascript
function pipe(...funcs) {
  return initial =>
    funcs.reduce((result, func) => {
      return func(result);
    }, initial);
}

const person = { name: 'kyo', age: 20, birthDay: '05-04', hobby: 'game' };
const getAge = pipe(p => p.age, console.log);
getAge(person);
```

---

# tab 함수를 사용한 디버깅

identity 라는 간단한 함수를 만들어 보자.

```javascript
const identity = it => {
  console.log(it);
  return it;
};

compose(oddOrEven, count, identity, splitIntoSpaces)('Test string');
```

count 함수가 받은 입력 인자를 출력한다.  
이러한 간단한 함수는 함수가 받은 데이터를 디버깅하는 데 많은 도움을 준다.
