# 마이크로프론트엔드

https://www.youtube.com/watch?v=VnJLFwnuLV4&list=PLZl3coZhX98p5lWeGKAdUgA93bioesqjc&index=5

Webpack 이 플러그인으로 제공하는 Module Federation 활용

https://fe-developers.kakaoent.com/2022/220623-webpack-module-federation/

`하나의 앱을 독립적 배포가 가능한 모듈단위(J번들)로 나누어 개발하고, 브라우저 런타임에 동적으로 통합`

---

# `모던 웹을 위한 마이크로 프론트엔드` 책 내용 기반

## 책 예제

https://github.com/PacktPublishing/The-Art-of-Micro-Frontends

https://bit.ly/3cbhbL7  
https://www.youtube.com/playlist?list=PLeLcvrwLe185OWoZT0hfN5zesgVangK5M

https://thesametech.com/micro-frontend-migration-journey-part-1/

Node.js 14 이상 환경

---

# 마이크로서비스의 장점 (p9)

- 장애는 단일 서비스와 직접적으로 관련된다.
- 여러 팀이 독립적으로 작업할 수 있다.
- 배포 규모가 작다.
- 프레임워크와 프로그래밍 언어를 자유롭게 선택할 수 있다.
- 초기 출시 시간이 더 짧다.
- 아키텍처 경계가 뚜렷하다.

# 마이크로서비스의 단점

장애가 단일 서비스에만 관련된 경우 디버깅이 복잡해진다.  
장애가 발생한 서비스에 종속된 서비스는 이상하게 작동한다.  
서비스 장애가 발생한 근본 원인을 찾고 상황을 완화하는 방법을 찾기가 더 어렵다.

- 오케스트레이션 복잡성 증가
- 다중 장애 지점
- 디버깅 및 테스트가 더 어려움
- 책임감 부족
- 서로 다른 서비스간 결과적 비일관성
- 버전 관리 어려움

# 관심사 분리(SoC, p54)

분할을 논의할 때 분할할 도메인보다 분할의 종류에 집중하는 상황에 놓이게 될 것이다.  
흥미롭게도 마이크로 프론트엔드의 초창기에는 대부분 사람들이 기술적인 분할에 열광했다. 그러나 마이크로 프론트엔드의 진정한 이점은 비즈니스 중심의 분할 결정에서 나타난다.

## 기술적 분할

## 기능적 분할

## 웹컴포넌트 활용 방식

웹컴포넌트: template tag(slot 포함) + shadow dom + custom element

커스텀엘리먼트 사용 및 필요한 웹컴포넌트 파일(js 파일)동적 로드

---

라이브러리 A : 윈쪽 레이아웃
라이브러리 B : 상단 레이아웃
라이브러리 C : 메인 컨텐츠

모노레포로 구성하고 각 라이브러리별로 빌드

---

# 사례

## 토스, 마이크로프론트 리액트 점진적 도입

https://toss.im/slash-21/sessions/2-5

## 카카오

https://www.youtube.com/watch?v=DOS0YPwdnhk

## AWS

https://www.youtube.com/watch?v=FUPlSphkPPs

---

# 구현방법

https://dhdnjswo5000.tistory.com/60

## Webpack Module Federation(웹팩 모듈 연합) 런타임 통합

웹팩모듈연합은 이러한 웹팩의 최신버전인 웹팩5의 추가기능  
이것을 사용하면 해당 앱이 다른앱의 코드를 동적으로 로드

https://medium.com/bb-tutorials-and-thoughts/7-different-ways-to-implement-micro-frontends-with-react-907b5e262230

## iframe 런타임 통합

```html
<html>
  <body>
    <iframe id="micro-frontend-container"></iframe>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        "/": "https://browse.example.com/index.html",
        "/order-food": "https://order.example.com/index.html",
        "/user-profile": "https://profile.example.com/index.html",
      };

      const iframe = document.getElementById("micro-frontend-container");
      iframe.src = microFrontendsByRoute[window.location.pathname];
    </script>
  </body>
</html>
```

분기할 페이지의 도메인들을 객체로 정의해 놓고 해당 window의 location에 따라 iframe의 src를 바꿔주고 있다.  
iframe이 쉽고 간단하지만 iframe이 웹을 크롤링할때 문제를 끼칠수 있고 보안적 문제들이 존재하는 단점이 있다.

## 자바스크립트 런타임 통합

각 앱페이지를 script 태그를 사용하여 로드시키고 분기처리 해준다.

```html
<html>
  <body>
    <script src="https://browse.example.com/bundle.js"></script>
    <script src="https://order.example.com/bundle.js"></script>
    <script src="https://profile.example.com/bundle.js"></script>

    <div id="micro-frontend-root"></div>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        // 각 페이지의 진입점(렌더시킬 함수)로 분기됨
        "/": window.renderBrowseRestaurants,
        "/order-food": window.renderOrderFood,
        "/user-profile": window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];
      // 각 페이지를 위의 div아래 붙여 렌더시켜줌
      renderFunction("micro-frontend-root");
    </script>
  </body>
</html>
```

iframe과 달리 꼭 해당 페이지를 보여주지 않고 단지 로드만 시킬수 있고 진입점 함수를 이용해 해당 페이지와 통신도 가능하다.

## nginx 서버 통합

nginx는 기존 Apach에 비해 경량화된 서버이다.  
브라우저에서 라우팅한 경로를 Nginx서버에서 라우팅해준다.  
즉 서버에서 분기에 따라 html파일을 결정해 통합 후 뿌려준다.

## 빌드타임 통합

각 앱들이 별도로 빌드 후 컨테이너앱에서 한꺼번에 통합하여 빌드하는 방식으로, 먼저 각 앱들을 패키지로 개시한다.

```json
{
  "name": "@feed-me/container",
  "version": "1.0.0",
  "description": "음식 배달 웹 앱",
  "dependencies": {
    "@feed-me/browse-restaurants ": "^1.2.3",
    "@feed-me/order-food": "^4.5.6",
    "@feed-me/user-profile": "^7.8.9"
  }
}
```

최종 컨테이너 앱을 빌드할때 나눠진 앱들의 패키지들을 의존성으로 추가함으로써 실행했을때 어떻게 작동할지 모두 알고 있으므로 런타임 통합에 비해 안정적인 통합 방식이다.

## 각 앱들사이에 어떻게 통신 시킬 수 있을까?

- 커스텀 이벤트 사용
- iframe 또는 웹워커의 경우 postMessage 사용
