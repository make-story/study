# 마이크로 프론트엔드

Vue, React, WebComponent 등 활용  
페이지에서 각 레이아웃별 조립 가능한 환경 테스트

https://themobilereality.com/blog/microfrontend-guide

https://www.youtube.com/watch?v=VnJLFwnuLV4&list=PLZl3coZhX98p5lWeGKAdUgA93bioesqjc&index=5

## 참고

`micro-frontend.git/README.md` 참고!!!!

## @module-federation

https://www.npmjs.com/search?q=%40module-federation

## Next.js @module-federation/nextjs-mf

https://www.npmjs.com/package/@module-federation/nextjs-mf

---

# 도구

## Bit

https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc

Bit를 사용하면 개발자가 빌드 타임에 프런트엔드를 효율적으로 구성

## Webpack 5 and Module Federation

JavaScript architecture invented by Zack Jackson (잭 잭슨이라는 사람이 제안)

Webpack 이 플러그인으로 제공하는 Module Federation (모듈 페터레이션) 활용

https://webpack.kr/plugins/module-federation-plugin/

https://fe-developers.kakaoent.com/2022/220623-webpack-module-federation/

https://blog.bitsrc.io/revolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0

마이크로 프런트엔드의 빌드타임 통합방식은 모노레포를 사용함으로써 가능했지만 결국 여러 패키지를 한 번에 같이 빌드해야 했던 한계가 있었다.  
이제는 Module Federation 이 등장함으로써 보다 자연스럽게 런타임에 통합할 수 있다.

Module Federation 은 단일 Webpack 빌드에 포함된 모듈뿐만 아니라 여러 서버에 배포되어 있는 원격 모듈을 하나의 애플리케이션에서 로딩할 수 있는 기능이다.

## single-spa

https://single-spa.js.org/

스스로를 “프런트엔드 마이크로서비스를 위한 자바스크립트 프레임워크”로 정의

여러 독립적인 프론트엔드 앱을 하나의 애플리케이션으로 통합하는 데 사용됩니다.  
다양한 프레임워크와 라이브러리를 지원하며, 모듈 간의 통신 및 라우팅을 관리할 수 있습니다.

## qiankun

https://qiankun.umijs.org/

마이크로 프론트엔드 아키텍처를 지원하는 JavaScript 라이브러리로, 다양한 프레임워크 간의 통합을 용이하게 합니다.  
주로 React, Vue, Angular와 같은 프레임워크 간의 상호 운용성을 강조합니다.

## Podium.io

https://podium-lib.io/

https://www.npmjs.com/package/@podium/podlet

웹 컴포넌트를 사용하여 여러 프론트엔드 앱을 조립하고, 이를 하나의 페이지에 통합하는 데 도움이 되는 도구입니다.  
서로 다른 프레임워크 간에 독립적인 모듈을 통합할 수 있습니다.

# Luigi

https://luigi-project.io/

## Tailor

https://github.com/zalando/tailor

Zalando에서 개발한 마이크로 프론트엔드를 위한 도구로, 서로 다른 서비스의 프론트엔드 모듈을 통합하여 하나의 애플리케이션으로 렌더링할 수 있습니다.

## SystemJS

https://github.com/systemjs/systemjs

Micro Frontend 프레임워크는 아니지만 MF 구현의 핵심인 독립 모듈의 브라우저 간 관리를 위한 솔루션을 제공합니다.

## Piral

https://github.com/smapiot/piral

## Open Components

https://github.com/opencomponents/oc

"프론트 엔드 세계에서 서버리스"를 목표로 선언

OC는 필요한 모든 것을 한 곳에서 제공하는 마이크로 프런트엔드용 프레임워크를 목표로 하며 구성 요소 처리부터 레지스트리, 템플릿, 심지어 CLI 도구까지 모든 도구를 포함

## frint

https://github.com/frintjs/frint

https://frint.js.org/repl/

"확장 가능하고 반응성이 뛰어난 애플리케이션을 구축하기 위한 모듈식 JavaScript 프레임워크"

---

# Webpack ModuleFederationPlugin

## 용어

- 로컬 모듈
  단일 Webpack 빌드에 포함되는 모듈이다.
  서로 다른 Webpack 빌드의 결과물은 서로 다른 로컬 모듈이다.
  로컬 모듈은 단일 빌드 안에서만 로딩할 수 있다.

- 원격 모듈
  다른 Webpack 빌드에서 만든 모듈을 대상으로 런타임에 로딩할 수 있는 모듈을 말한다.
  즉 A 빌드와 B 빌드의 결과물은 서로 원격 모듈이 될 수 있다.
  각 빌드는 개별 서버에 배포될 수 있으며 런타임에 Dynamic Imports하듯이 원격 모듈을 로딩할 수 있다.

- 컨테이너(Container)
  각각의 빌드를 말하며 하나의 빌드가 하나의 웹 애플리케이션을 나타낸다.
  A 컨테이너는 B 컨테이너의 원격 모듈을 로딩할 수 있으며 B에서 A 방향으로도 로딩할 수 있다.

- Expose
  컨테이너가 외부에 노출한 원격 모듈의 목록을 나타내는 설정이다.
  간단하게는 내보낼 모듈이름: 로컬 모듈 경로로 표현할 수 있으며 Webpack 설정의 일부를 보면 이해가 빠를 것이다.

- 공유 모듈
  여러 컨테이너에서 같이 사용하는 모듈을 말하며 런타임에 한 번만 로딩된다.
  예를 들어 여러 컨테이너에서 react를 사용한다면, react 모듈을 여러 번 로딩할 필요는 없다.

- 리모트 앱
  모듈을 Expose하는 컨테이너

- 호스트 앱
  원격 모듈을 사용하는 컨테이너

```javascript
new ModuleFederationPlugin({
  name: 'app2',
  exposes: {
    './Button': './src/Button',
  },
});
```

app 라는 컨테이너는 로컬 모듈 "./src/Button" 을 "./Button" 이라는 이름의 원격 모듈로 Expose(노출)한다는 의미다.  
원격 모듈을 사용하는 컨테이너(app1)에서는 다음과 같이 설정한다.

```javascript
new ModuleFederationPlugin({
  name: "app1",
  remotes: {
    app2: `app2@http://localhost:3002/remoteEntry.js`,
  },
}),

// import하여 Button 컴포넌트를 사용할 수 있다.
const RemoteButton = React.lazy(() => import("app2/Button"));
```

## 동작원리

리모트 앱을 빌드하면 remoteEntry.js라는 파일이 생성되며 Expose한 원격 모듈을 호스트 앱에서 로딩할 수 있도록 인터페이스를 정의한다.

호스트 앱은 리모트 앱의 remoteEntry.js 파일을 로딩한다.

리모트 앱의 remoteEntry.js 파일은 호스트 앱에 로딩되면서 컨테이너명(예: app2)으로된 전역 변수를 설정한다.

`정리하면 호스트 앱이 리모트 앱의 remoteEntry.js를 로딩하고 예를 들어 'app2'와 같이 리모트 앱의 컨테이너 이름을 파악한다. 그러면 비동기 로컬 모듈처럼 원격 모듈을 로딩할 수 있다.`

`컨테이너 이름을 만들 때 주의할 것이 있다. Module Federation은 컨테이너의 이름을 나타낼 때 예를 들어 'app2'라는 전역 변수를 사용하기 때문에 컨테이너의 이름은 전역에서 유니크하도록 작명해야 한다!`

## 배포 시 remoteEntry.js 경로 처리

빌드 및 배포할 때 리모트 앱의 remoteEntry.js 파일 경로를 목적별 서버(예> local, dev, alpha, stage, real 등)에 맞게 작성해야 한다.

불편한 점은 목적별 서버가 다르기 때문에 remoteEntry.js 파일의 URL이 달라진다는 점이다.  
그래서 webpack 설정 파일을 따로 두거나 환경 변수로 받아서 환경별로 빌드해야 한다.

https://module-federation.myshopify.com/products/practical-module-federation

목적별 서버 지정

```javascript
// webpack.config.js
new ModuleFederationPlugin({
  remotes: {
    app2: `app2@${getRemoteEntryUrl(3002)}`,
  },
}),
...

function getRemoteEntryUrl(port) {
  const { isLocal, hostName } = process.env;

  if (!isLocal) {
    return `http://localhost:${port}/remoteEntry.js`;
  }

  return `https://${hostName}/remoteEntry.js`;
};
```

# Module Federation 제공되는 코드에 타입스크립트 지원

배달의 민족 마이크로프론트엔드 동영상 참고  
https://www.youtube.com/watch?v=-jYSGaPAEHE&list=PLgXGHBqgT2TundZ81MAVHPzeYOTeII69j&index=19

1. 라이브러리 활용
   https://www.npmjs.com/package/@module-federation/typescript/v/3.0.1

2. @types/\* 내부 타입정의 NPM 제공

양방향 (호스트 - 모듈) 타입스크립트 제공 라이브러리  
https://github.com/module-federation/universe/tree/main/packages/native-federation-typescript

---

# `모던 웹을 위한 마이크로 프론트엔드` 책 내용 기반

## 책 예제

https://github.com/PacktPublishing/The-Art-of-Micro-Frontends

https://bit.ly/3cbhbL7  
https://www.youtube.com/playlist?list=PLeLcvrwLe185OWoZT0hfN5zesgVangK5M

https://thesametech.com/micro-frontend-migration-journey-part-1/

---

# 마이크로서비스의 장점 (p9)

- 장애는 단일 서비스와 직접적으로 관련된다.
- 여러 팀이 독립적으로 작업할 수 있다.
- 배포 규모가 작다.
- 프레임워크와 프로그래밍 언어를 자유롭게 선택할 수 있다.
- 초기 출시 시간이 더 짧다.
- 아키텍처 경계가 뚜렷하다.

# 마이크로서비스의 단점

장애가 단일 서비스에만 관련된 경우 디버깅이 복잡해진다.  
장애가 발생한 서비스에 종속된 서비스는 이상하게 작동한다.  
서비스 장애가 발생한 근본 원인을 찾고 상황을 완화하는 방법을 찾기가 더 어렵다.

- 오케스트레이션 복잡성 증가
- 다중 장애 지점
- 디버깅 및 테스트가 더 어려움
- 책임감 부족
- 서로 다른 서비스간 결과적 비일관성
- 버전 관리 어려움

# 관심사 분리(SoC, p54)

분할을 논의할 때 분할할 도메인보다 분할의 종류에 집중하는 상황에 놓이게 될 것이다.  
흥미롭게도 마이크로 프론트엔드의 초창기에는 대부분 사람들이 기술적인 분할에 열광했다. 그러나 마이크로 프론트엔드의 진정한 이점은 비즈니스 중심의 분할 결정에서 나타난다.

## 기술적 분할

## 기능적 분할

## 웹컴포넌트 활용 방식

웹컴포넌트: template tag(slot 포함) + shadow dom + custom element

커스텀엘리먼트 사용 및 필요한 웹컴포넌트 파일(js 파일)동적 로드

# Mosaic 9 (p112)

...

# 포디움(Podium)

...

# 클라이언트 측 구성 (p138, 9장)

아키텍처 관점에서 다음 두 가지 방법 중 하나를 선택해야 한다.

- 웹 컴포넌트마다 하나의 스크립트를 갖는 것
- 마이크로 프론트엔드 마다 하나의 스크립트를 갖는 것

전자가 일반적으로 좋은 생각이지만 후자는 훨씬 간단하고 더 좋은 성능을 제공한다.

## 동적으로 마이크로 프론트엔드 구성 (p151)

### 마이크로 프론트엔드 레지스트리를 사용

```json
{
  "scripts": [
    "http://localhost:2001/product-page.js",
    "http://localhost:2002/basket-info.js",
    "http://localhost:2002/buy-button.js"
  ]
}
```

```javascript
fetch('./scripts.json')
  .then(res => res.json())
  .then(({ scripts }) =>
    scripts.forEach(url => {
      const script = document.createElement('script');
      script.src = url;
      document.body.appendChild(script);
    }),
  );
```

### 런타임에 마이크로 프론트엔드 업데이트하기

...

---

라이브러리 A : 윈쪽 레이아웃
라이브러리 B : 상단 레이아웃
라이브러리 C : 메인 컨텐츠

모노레포로 구성하고 각 라이브러리별로 빌드

---

# 사례

## 토스, 마이크로프론트 리액트 점진적 도입

https://toss.im/slash-21/sessions/2-5

## 카카오

https://www.youtube.com/watch?v=DOS0YPwdnhk

## AWS

https://www.youtube.com/watch?v=FUPlSphkPPs

---

# 구현방법

https://dhdnjswo5000.tistory.com/60

## Webpack Module Federation(웹팩 모듈 연합) 런타임 통합

웹팩모듈연합은 이러한 웹팩의 최신버전인 웹팩5의 추가기능  
이것을 사용하면 해당 앱이 다른앱의 코드를 동적으로 로드

https://medium.com/bb-tutorials-and-thoughts/7-different-ways-to-implement-micro-frontends-with-react-907b5e262230

## iframe 런타임 통합

```html
<html>
  <body>
    <iframe id="micro-frontend-container"></iframe>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        '/': 'https://browse.example.com/index.html',
        '/order-food': 'https://order.example.com/index.html',
        '/user-profile': 'https://profile.example.com/index.html',
      };

      const iframe = document.getElementById('micro-frontend-container');
      iframe.src = microFrontendsByRoute[window.location.pathname];
    </script>
  </body>
</html>
```

분기할 페이지의 도메인들을 객체로 정의해 놓고 해당 window의 location에 따라 iframe의 src를 바꿔주고 있다.  
iframe이 쉽고 간단하지만 iframe이 웹을 크롤링할때 문제를 끼칠수 있고 보안적 문제들이 존재하는 단점이 있다.

## `자바스크립트 런타임 통합`

각 앱페이지를 script 태그를 사용하여 로드시키고 분기처리 해준다.

```html
<html>
  <body>
    <script src="https://browse.example.com/bundle.js"></script>
    <script src="https://order.example.com/bundle.js"></script>
    <script src="https://profile.example.com/bundle.js"></script>

    <div id="micro-frontend-root"></div>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        // 각 페이지의 진입점(렌더시킬 함수)로 분기됨
        '/': window.renderBrowseRestaurants,
        '/order-food': window.renderOrderFood,
        '/user-profile': window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];
      // 각 페이지를 위의 div아래 붙여 렌더시켜줌
      renderFunction('micro-frontend-root');
    </script>
  </body>
</html>
```

iframe과 달리 꼭 해당 페이지를 보여주지 않고 단지 로드만 시킬수 있고 진입점 함수를 이용해 해당 페이지와 통신도 가능하다.

## nginx 서버 통합

nginx는 기존 Apach에 비해 경량화된 서버이다.  
브라우저에서 라우팅한 경로를 Nginx서버에서 라우팅해준다.  
즉 서버에서 분기에 따라 html파일을 결정해 통합 후 뿌려준다.

## `빌드타임 통합`

각 앱들이 별도로 빌드 후  
컨테이너앱에서 한꺼번에 통합(필요 모듈 import)하여 빌드하는 방식으로,  
먼저 각 앱들을 패키지로 개시(NPM 패키지 배포)한다.

```json
{
  "name": "@feed-me/container",
  "version": "1.0.0",
  "description": "음식 배달 웹 앱",
  "dependencies": {
    "@feed-me/browse-restaurants ": "^1.2.3",
    "@feed-me/order-food": "^4.5.6",
    "@feed-me/user-profile": "^7.8.9"
  }
}
```

최종 컨테이너 앱을 빌드할때  
나눠진 앱들의 패키지들을 의존성으로 추가함으로써  
실행했을때 어떻게 작동할지 모두 알고 있으므로(명시적 import)  
런타임 통합에 비해 안정적인 통합 방식이다.

## 각 앱들사이에 어떻게 통신 시킬 수 있을까?

- 커스텀 이벤트 사용
- iframe 또는 웹워커의 경우 postMessage 사용
