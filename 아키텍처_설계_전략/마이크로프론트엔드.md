# 마이크로프론트엔드

https://www.youtube.com/watch?v=VnJLFwnuLV4&list=PLZl3coZhX98p5lWeGKAdUgA93bioesqjc&index=5

# 도구

## Bit

https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc

Bit를 사용하면 개발자가 빌드 타임에 프런트엔드를 효율적으로 구성

## Webpack 5 and Module Federation

JavaScript architecture invented by Zack Jackson (잭 잭슨이라는 사람이 제안)

Webpack 이 플러그인으로 제공하는 Module Federation (모듈 페터레이션) 활용

https://fe-developers.kakaoent.com/2022/220623-webpack-module-federation/

https://blog.bitsrc.io/revolutionizing-micro-frontends-with-webpack-5-module-federation-and-bit-99ff81ceb0

JavaScript 애플리케이션이 런타임 시 다른 애플리케이션에서 동적으로 코드를 가져올 수 있습니다.

또한 종속성 공유를 활성화하여 코드 종속성 문제와 번들 크기 증가 문제를 해결합니다.  
예를 들어, React 구성 요소를 다운로드하는 경우 애플리케이션은 React 코드를 두 번 가져오지 않습니다.  
모듈은 이미 가지고 있는 React 소스를 스마트하게 사용하고 구성 요소 코드만 가져옵니다.

### Webpack Module Federation 도입 전에 알아야 할 것들

https://fe-developers.kakaoent.com/2022/220623-webpack-module-federation/

## single-spa

https://single-spa.js.org/

스스로를 “프런트엔드 마이크로서비스를 위한 자바스크립트 프레임워크”로 정의

여러 독립적인 프론트엔드 앱을 하나의 애플리케이션으로 통합하는 데 사용됩니다.  
다양한 프레임워크와 라이브러리를 지원하며, 모듈 간의 통신 및 라우팅을 관리할 수 있습니다.

## qiankun

https://qiankun.umijs.org/

마이크로 프론트엔드 아키텍처를 지원하는 JavaScript 라이브러리로, 다양한 프레임워크 간의 통합을 용이하게 합니다.  
주로 React, Vue, Angular와 같은 프레임워크 간의 상호 운용성을 강조합니다.

## Podium.io

https://podium-lib.io/

https://www.npmjs.com/package/@podium/podlet

웹 컴포넌트를 사용하여 여러 프론트엔드 앱을 조립하고, 이를 하나의 페이지에 통합하는 데 도움이 되는 도구입니다.  
서로 다른 프레임워크 간에 독립적인 모듈을 통합할 수 있습니다.

# Luigi

https://luigi-project.io/

## Tailor

https://github.com/zalando/tailor

Zalando에서 개발한 마이크로 프론트엔드를 위한 도구로, 서로 다른 서비스의 프론트엔드 모듈을 통합하여 하나의 애플리케이션으로 렌더링할 수 있습니다.

## SystemJS

https://github.com/systemjs/systemjs

Micro Frontend 프레임워크는 아니지만 MF 구현의 핵심인 독립 모듈의 브라우저 간 관리를 위한 솔루션을 제공합니다.

## Piral

https://github.com/smapiot/piral

## Open Components

https://github.com/opencomponents/oc

"프론트 엔드 세계에서 서버리스"를 목표로 선언

OC는 필요한 모든 것을 한 곳에서 제공하는 마이크로 프런트엔드용 프레임워크를 목표로 하며 구성 요소 처리부터 레지스트리, 템플릿, 심지어 CLI 도구까지 모든 도구를 포함

## frint

https://github.com/frintjs/frint

https://frint.js.org/repl/

"확장 가능하고 반응성이 뛰어난 애플리케이션을 구축하기 위한 모듈식 JavaScript 프레임워크"

---

# `모던 웹을 위한 마이크로 프론트엔드` 책 내용 기반

## 책 예제

https://github.com/PacktPublishing/The-Art-of-Micro-Frontends

https://bit.ly/3cbhbL7  
https://www.youtube.com/playlist?list=PLeLcvrwLe185OWoZT0hfN5zesgVangK5M

https://thesametech.com/micro-frontend-migration-journey-part-1/

---

# 마이크로서비스의 장점 (p9)

- 장애는 단일 서비스와 직접적으로 관련된다.
- 여러 팀이 독립적으로 작업할 수 있다.
- 배포 규모가 작다.
- 프레임워크와 프로그래밍 언어를 자유롭게 선택할 수 있다.
- 초기 출시 시간이 더 짧다.
- 아키텍처 경계가 뚜렷하다.

# 마이크로서비스의 단점

장애가 단일 서비스에만 관련된 경우 디버깅이 복잡해진다.  
장애가 발생한 서비스에 종속된 서비스는 이상하게 작동한다.  
서비스 장애가 발생한 근본 원인을 찾고 상황을 완화하는 방법을 찾기가 더 어렵다.

- 오케스트레이션 복잡성 증가
- 다중 장애 지점
- 디버깅 및 테스트가 더 어려움
- 책임감 부족
- 서로 다른 서비스간 결과적 비일관성
- 버전 관리 어려움

# 관심사 분리(SoC, p54)

분할을 논의할 때 분할할 도메인보다 분할의 종류에 집중하는 상황에 놓이게 될 것이다.  
흥미롭게도 마이크로 프론트엔드의 초창기에는 대부분 사람들이 기술적인 분할에 열광했다. 그러나 마이크로 프론트엔드의 진정한 이점은 비즈니스 중심의 분할 결정에서 나타난다.

## 기술적 분할

## 기능적 분할

## 웹컴포넌트 활용 방식

웹컴포넌트: template tag(slot 포함) + shadow dom + custom element

커스텀엘리먼트 사용 및 필요한 웹컴포넌트 파일(js 파일)동적 로드

# Mosaic 9 (p112)

...

# 포디움(Podium)

...

# 클라이언트 측 구성 (p138, 9장)

아키텍처 관점에서 다음 두 가지 방법 중 하나를 선택해야 한다.

- 웹 컴포넌트마다 하나의 스크립트를 갖는 것
- 마이크로 프론트엔드 마다 하나의 스크립트를 갖는 것

전자가 일반적으로 좋은 생각이지만 후자는 훨씬 간단하고 더 좋은 성능을 제공한다.

## 동적으로 마이크로 프론트엔드 구성 (p151)

### 마이크로 프론트엔드 레지스트리를 사용

```json
{
  "scripts": [
    "http://localhost:2001/product-page.js",
    "http://localhost:2002/basket-info.js",
    "http://localhost:2002/buy-button.js"
  ]
}
```

```javascript
fetch('./scripts.json')
  .then(res => res.json())
  .then(({ scripts }) =>
    scripts.forEach(url => {
      const script = document.createElement('script');
      script.src = url;
      document.body.appendChild(script);
    }),
  );
```

### 런타임에 마이크로 프론트엔드 업데이트하기

...

---

라이브러리 A : 윈쪽 레이아웃
라이브러리 B : 상단 레이아웃
라이브러리 C : 메인 컨텐츠

모노레포로 구성하고 각 라이브러리별로 빌드

---

# 사례

## 토스, 마이크로프론트 리액트 점진적 도입

https://toss.im/slash-21/sessions/2-5

## 카카오

https://www.youtube.com/watch?v=DOS0YPwdnhk

## AWS

https://www.youtube.com/watch?v=FUPlSphkPPs

---

# 구현방법

https://dhdnjswo5000.tistory.com/60

## Webpack Module Federation(웹팩 모듈 연합) 런타임 통합

웹팩모듈연합은 이러한 웹팩의 최신버전인 웹팩5의 추가기능  
이것을 사용하면 해당 앱이 다른앱의 코드를 동적으로 로드

https://medium.com/bb-tutorials-and-thoughts/7-different-ways-to-implement-micro-frontends-with-react-907b5e262230

## iframe 런타임 통합

```html
<html>
  <body>
    <iframe id="micro-frontend-container"></iframe>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        '/': 'https://browse.example.com/index.html',
        '/order-food': 'https://order.example.com/index.html',
        '/user-profile': 'https://profile.example.com/index.html',
      };

      const iframe = document.getElementById('micro-frontend-container');
      iframe.src = microFrontendsByRoute[window.location.pathname];
    </script>
  </body>
</html>
```

분기할 페이지의 도메인들을 객체로 정의해 놓고 해당 window의 location에 따라 iframe의 src를 바꿔주고 있다.  
iframe이 쉽고 간단하지만 iframe이 웹을 크롤링할때 문제를 끼칠수 있고 보안적 문제들이 존재하는 단점이 있다.

## `자바스크립트 런타임 통합`

각 앱페이지를 script 태그를 사용하여 로드시키고 분기처리 해준다.

```html
<html>
  <body>
    <script src="https://browse.example.com/bundle.js"></script>
    <script src="https://order.example.com/bundle.js"></script>
    <script src="https://profile.example.com/bundle.js"></script>

    <div id="micro-frontend-root"></div>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        // 각 페이지의 진입점(렌더시킬 함수)로 분기됨
        '/': window.renderBrowseRestaurants,
        '/order-food': window.renderOrderFood,
        '/user-profile': window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];
      // 각 페이지를 위의 div아래 붙여 렌더시켜줌
      renderFunction('micro-frontend-root');
    </script>
  </body>
</html>
```

iframe과 달리 꼭 해당 페이지를 보여주지 않고 단지 로드만 시킬수 있고 진입점 함수를 이용해 해당 페이지와 통신도 가능하다.

## nginx 서버 통합

nginx는 기존 Apach에 비해 경량화된 서버이다.  
브라우저에서 라우팅한 경로를 Nginx서버에서 라우팅해준다.  
즉 서버에서 분기에 따라 html파일을 결정해 통합 후 뿌려준다.

## `빌드타임 통합`

각 앱들이 별도로 빌드 후  
컨테이너앱에서 한꺼번에 통합(필요 모듈 import)하여 빌드하는 방식으로,  
먼저 각 앱들을 패키지로 개시(NPM 패키지 배포)한다.

```json
{
  "name": "@feed-me/container",
  "version": "1.0.0",
  "description": "음식 배달 웹 앱",
  "dependencies": {
    "@feed-me/browse-restaurants ": "^1.2.3",
    "@feed-me/order-food": "^4.5.6",
    "@feed-me/user-profile": "^7.8.9"
  }
}
```

최종 컨테이너 앱을 빌드할때  
나눠진 앱들의 패키지들을 의존성으로 추가함으로써  
실행했을때 어떻게 작동할지 모두 알고 있으므로(명시적 import)  
런타임 통합에 비해 안정적인 통합 방식이다.

## 각 앱들사이에 어떻게 통신 시킬 수 있을까?

- 커스텀 이벤트 사용
- iframe 또는 웹워커의 경우 postMessage 사용
