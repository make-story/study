# 모노레포 최적화 방법

https://toss.tech/article/monorepo-pipeline

## 병렬화를 통한 CI/CD 속도 최적화

yarn을 쓰고 있다면, yarn workspace since run --jobs 옵션을 통해 빌드를 병렬로 수행할 수 있어요.  
하지만 각 서비스가 빌드되는 환경이 하나의 컴퓨팅 환경이라면, CPU와 Memory와 같은 컴퓨팅 리소스를 공유하게 되는 문제가 있어요.  
한정된 CPU와 Memory를 쓰는 환경에서, 병렬의 숫자를 늘리면 오히려 더 느려지게 됩니다.  
결국 빌드 대상이 많아지면, 병렬을 해도 순차적으로 실행한 경우와 비슷한 시간이 소요됩니다.

모든 빌드를 서로 독립된 환경에서 실행하도록 파이프라인을 고치면 이런 문제를 뿌리째 뽑을 수 있어요!  
CircleCI 의 Dynamic Configuration 을 이용

https://circleci.com/docs/dynamic-config/

`study.git/인프라/CircleCI/CircleCI.md` 참고!

## 모노레포를 미리 복제하기

미리 복제한 환경으로 빌드를 시작하면, 처음부터 git을 내려받을 필요가 없게 되어 오래 기다릴 필요도 없습니다!

```dockerfile
FROM docker.io/cimg/node:20.14.0
SHELL ["/bin/bash", "-c"]

# 중략
WORKDIR ${HOME}/project

# 가볍게 50개 커밋 내역만 먼저 clone 받기
RUN git clone --depth 50 $CIRCLE_REPOSITORY_URL

# 코드 변경 계산에 적당할 정도로 1000개 커밋 내역까지 이어서 내려받기
RUN git fetch --depth 1000 --force origin main

# 현재 환경을 main 브랜치로 설정
RUN git checkout --force -B main

# yarn install 미리 해두기 (생략 가능)
RUN yarn
```

## Node File Trace

Node File Trace 를 통해서 애플리케이션 런타임에 필요한 의존성만 뽑아낼 수 있는데,  
최소한의 JavaScript 파일만 모아서 빌드 환경을 만들면 획기적으로 가벼워 Docker 빌드와 K8S로의 배포 시간이 빨라집니다.

Next.js 에서 이러한 아이디어를 next.config.js 의 output: 'standalone' 으로 제공해 주고 있습니다.

하지만 저희가 쓰기에는 한 가지 아쉬운 점이 있었는데요, 이 기능은 node_modules라는 특별한 디렉토리에 의존되어 있었어요.  
Yarn PnP 를 사용해 node_modules 가 아닌 .yarn/cache라는 곳에 의존성이 저장되어서 이 기능을 그대로 사용할 수가 없었어요.
