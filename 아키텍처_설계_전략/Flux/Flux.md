## MVC -> Flux

https://taegon.kim/archives/5288

MVC 패턴에서 컨트롤러(Controller)는 모델(Model)의 데이터를 조회하거나 업데이트하는 역할을 하며, 모델(Model)의 변화는 뷰(View)에 반영한다.  
또한, 사용자는 뷰를 통해 데이터를 입력하는데 사용자의 입력​은 모델에 영향을 주기도 한다.​

대표적인 사례가 바로 페이스북의 안 읽은 글 갯수(unread count) 표시이다.  
사용자가 읽지 않았던 글을 읽으면 읽지 않은 글 갯수에서 읽은 글 수만큼 빼면 되는 일견 단순해보이는 기능인데도,  
페이스북 서비스에서 이를 MVC로 구현하기는 어려웠다고 한다.  
어떤 글을 '읽음' 상태로 두면, 먼저 글을 다루는 thread 모델을 업데이트 해야하고 동시에 unread ​count 모델도 업데이트 해야한다.  
대규모 MVC 애플리케이션에서 이 같은 의존성과 순차적 업데이트는 종종 데이터의 흐름을 꼬이게 하여 예기치 못한 결과를 불러일으킨다.

---

# FSA(Flux Standard Action)

https://haruair.github.io/flux/docs/overview.html

https://www.infoq.com/news/2014/05/facebook-mvc-flux/

https://github.com/redux-utilities/flux-standard-action

https://baeharam.netlify.app/posts/architecture/flux-redux

## 액션 생성자(Action creator)

액션이란 어떤 행위인지와 그 행위로부터 넘겨받은 값들을 가진 하나의 객체를 말한다.  
따라서 어떤 액션인지를 가리키는 type 과 넘겨받은 값인 payload 를 가진다.  
액션 생성자는 기존 상태를 변경하기 위한 액션의 생성을 담당하며 해당 액션을 생성해서 디스패쳐에 넘겨준다.

## 디스패쳐(Dispatcher)

디스패쳐는 모든 액션들을 받아서 의존성을 적절히 처리해준 다음 모든 스토어에게 넘긴다.  
여기서 중요한 점은 모든 스토어가 모든 액션을 받는다는 것이다.

## 스토어(Store)

스토어는 모든 액션을 받아서 자신에게 적합한 액션이 어떤 건지 필터링한다.  
이후 상태값을 변경하고 자신에게 연결된 컨트롤러 뷰에게 상태가 변화되었음을 알린다.

## 컨트롤러 뷰(Controller View)와 뷰(View)

여기서 컨트롤러 뷰는 전체적으로 화면에 나타는 자식 뷰들과 스토어를 연결하는 매개체이다.  
자식 뷰들은 컨트롤러 뷰에게 변화된 상태를 받고 그 상태에 따라 다시 렌더링이 된다.

---

# Redux

## 액션 생성자(Action creator)

액션 생성자는 사용자가 요청한 액션을 만들어서 포맷에 맞게 돌려준다.

## 스토어(Store)

Flux에선 다수의 스토어를 가질 수 있지만 Redux는 단 하나의 스토어를 가진다.  
대신에 상태 트리(State tree) 라고 불리는 상태값을 유지한다.

## 리듀서(Reducer)

디스패쳐가 없는 대신 리듀서가 상태변화로직을 담당한다.  
리듀서는 전체 리듀서를 관리하는 루트 리듀서와 하위의 서브 리듀서로 나뉜다. 루트 리듀서는 상태 객체의 키(key)를 기준으로 조각조각 나누어서 서브 리듀서에게 보낸다.  
서브 리듀서는 이전 상태를 변경하지 않고 복사해서 변경한다.  
이렇게 상태 객체를 업데이트 시키고 이를 루트 리듀서에게 돌려준다. 이것이 바로 Redux의 키 아이디어이다.
루트 리듀서는 서브 리듀서들로 받은 상태 객체들을 취합해서 스토어로 보낸다.

## 뷰 레이어 바인딩(View-Layer binding)

스토어와 뷰를 연결하기 위한 것으로 뷰에서 스토어의 상태 값들에 접근하기 위해 필요하다.  
공급 컴포넌트(Provider Component)를 통해서 스토어가 뷰에 상태를 공급하며 뷰에선 특정 함수(예를 들면 connect )를 통해서 스토어에 연결된다.

## 예제

2개의 카운터가 있다고 해보자. 하나는 1씩 증가/감소 시키고 다른 하나는 2씩 증가/감소시킨다.  
이를 redux로 구현하면 다음과 같이 구현할 수 있다.

1. 각각의 액션 및 액션 생성자를 정의한다.
2. 각각의 서브 리듀서를 정의한다.
3. 서브 리듀서를 루트 리듀서로 합친다.
4. 루트 리듀서를 스토어에 등록해서 스토어를 생성한다.
5. 공급 컴포넌트로 스토어의 상태를 뷰에 공급한다.
6. 뷰에서 상태값을 사용할 때 스토어에 연결하여 사용한다.

---

객체는 액션을 구분할 고유한 문자열을 가진 `type` 필드가 반드시 있으며,  
`payload` 필드에 데이터를 담아 전달한다.  
그 외에 `meta`, `error` 필드를 가질 수도 있다.

```
{
    type: ACTION_NAME,
    payload: 'createAction 활용할 경우, 두 번째 파라미터 함수 반환 값',
    meta: '사용자값',
    error: '사용자값',
}
```
