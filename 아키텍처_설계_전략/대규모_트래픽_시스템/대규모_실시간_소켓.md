# 일반적 실시간 소캣 서버 구성

https://channel.io/ko/blog/real-time-chat-server-1-redis-pub-sub

- 레디스
  레디스는 소켓 서버 간 세션 정보를 공유하기 위해 사용됩니다.
  예를 들면, 접속한 소켓 서버가 서로 다른 클라이언트 간의 통신을 하려고 할 때 레디스 Pub/Sub 을 이용 하여 데이터를 전달합니다. 이를 위해 실제 레디스에 소켓 서버가 붙어 모든 데이터를 전송합니다.

- 소켓 서버
  소켓 서버는 실제 클라이언트와 통신하는 주체이며, 레디스에 붙어 여러 패킷을 관리하는 서버가 됩니다.
  레디스와 통신하기 위해 사용하는 Adapter 는 Socket.IO 공식 레포에 있는 socket.io-redis-adpater 를 사용했습니다.

- 클라이언트
  클라이언트는 소켓 서버에 붙어 동작합니다. 실시간으로 변경된 데이터를 전달 받거나, 유저의 온라인 여부 파악을 위해 heartbeat 를 전송합니다.

- 메인 서버
  저희 구조의 특이한 점으로는 일반적으로 소켓 서버의 클라이언트로서 메인 서버(채팅 세션 및 메세지 관리)가 존재하지 않고 레디스에 직접 붙어 PUBLISH 를 한다는 점입니다. 이에는 몇 가지 이유가 있는데,
  메인 서버 → 레디스 인스턴스로의 단방향 적인 데이터 흐름만 존재
  만약 소켓 서버 클라이언트로 존재한다면, 레디스 커넥션보다 관리가 어려운 웹 소켓 커넥션 관리 및 쓰레드 풀 운영을 해야함.

## Socket.io Adapter

https://channel.io/ko/blog/tech-socketio-redis-adapter-improvement

Socket.iO Adapter란, 다중화된 socket.io 서버가 redis나 mongoDB 같은 다른 백엔드와 통신하기 위한 모듈입니다.

Socket.io 내부에서는 default로 In-memory Adapter를 사용하고 있습니다. In-memory Adapter에서는 단순하게 rooms, sids Set을 만들어서 클라이언트의 join, leave 마다 각각 addAll() del() 혹은 delAll() 메서드를 대응시켜 알맞은 socket을 추가 및 삭제하며 관리합니다.

## 레디스의 부하

순간적으로 발생하는 큰 트래픽은 레디스에게 더욱 큰 부하를 주게 되었고, 이는 예기치 않게 메인서버 로직에도 영향

https://making.pusher.com/redis-pubsub-under-the-hood/

https://github.com/redis/redis/blob/6.2/src/pubsub.c

https://socket.io/docs/v4/redis-adapter/

## MQ 활용!

https://channel.io/ko/blog/tech-backend-aws-sqs-introduction

많은 양의 트래픽을 감당하기 위한 해결책 중 하나로 중간에 message queue를 두어 buffering하는 것을 고려

message queue로 활용할 수 있는 여러 가지 component 중, AWS SQS를 선택

`study.git/아키텍처_설계_전략/대규모_트래픽_시스템/AWS_SQS.md` 참고!
