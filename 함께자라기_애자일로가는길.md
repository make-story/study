# `함께 자라기 애자일로 가는 길` 책 정리

-----  

# 당신은 몇 년 차?
## 소프트웨어 개발에서 경력과 실력  
경험 많은 사람(경험이 부족한 사람과 비교해)을 전문가로 본 연구에서는 그들이 `문제를 이해하는 데 더 많은 시간과 노력을 기울이는 것`으로 밝혀졌습니다.  
이 결과는 요구사항 분석에 시간을 더 써야 한다는 이야기의 근거로 사용되기도 했죠.  
하지만 실력이 뛰어난 사람은 실력이 보통 정도인 사람과 비교해 `문제를 이해하는 데 시간을 적게 쓰는 것`(통계적으로 유의미할 정도는 아니였으나)으로 나왔습니다.  
이렇게 우리는 경력과 실력을 동등하게 보는 함정에 빠지면 잘못된 전문가상(전문가의 이미지가 전문가의 현실을 바꾸는 상황)을 갖는다는 것을 알 수 있습니다.

## 중요하다고 생각하는 것이 중요하지 않다  
최소한도의 경력 수준만 넘겼으면 오히려 몇 년 일했는지는 모르는 것이 더 낫다고 생각하고요.  
경력은 오히려 경계해야 할 대상 중 하나인 셈이지요.  
그러면 대안이 뭘까요? 구조화된 인터뷰(특별히 구조화된 행동중심적 인터뷰를 권함, "지난 프로젝트에서 동료가 어려움을 겪을 때 어떤 행동을 하셨는지 구체적 예를 들어주세요")와 실제 작업을 해보도록 하는 작업 샘플 테스트, 그리고 가능 하다면 실제 업무를 주고 시험적으로 짧은 기간 동안 일을 해보게 하는 것(시험외주, Trial Sourcing, 소프트웨어 개발 용역 외주를 줘야 할 때 개발 업체 선정에 유일하게 효과적인 방법으로 나와 있음) 등을 권합니다. 그리고 전체 구인 과정에서 실제로 함께 일할 사람들이 인터뷰에 참여하도록 하는 것을 강력히 권합니다.

## 잘 뽑는 것 이상으로 중요한 것  
품질 석학 에드워드 데밍(Edwards Deming)은 직원들이 문제가 아니라, 그 사람들이 속한 시스템, 그리고 그걸 만들고 책임지는 경영진이 문제라고 했습니다.

## 개발자둘이 할 수 있는 것  
"소프트웨어 개발에서 점차 경력 연수를 중시하는 문화가 사라질 것이다. 따라서 개발자들은 자신의 경력 연차 외에 다른 것에도 신경을 써야 한다."  
1만 시간 법칙에서 1만 시간은 `자신의 기량을 향상시킬 목적으로 반복적으로 하는 수련`을 한 시간을 일컫습니다. 그런 수련을 안데쉬 에릭손(Anders K. Ericsson)는 의도적 수련(deliberate practice)이라고 합니다. 그냥 경험이 아니고 매우 특수한 형태의 수련 방법입니다.  
\
애자일은 학습을 소프트웨어 개발의 가장 큰 병목 중 하나로 봅니다.  
일반적인 프로젝트에서는 모든 피드백의 주기가 느립니다. 예를 들면, 내가 설계 단계에서 했던 결정의 피드백을 몇 달 후(테스트 단계)에 받습니다. 그때쯤 되면 이미 내가 예전에 왜 그런 결정을 했는지조차도 가물거리겠죠. 설사 그때 기억이 난다고 해도, "아, 그런 거였군"하고 아무렇지 않게 지나치기 쉽습니다. 내가 과거에 잘못한 실수는 한참 전에 지나가 벼렸고 이제 와서 이걸 교정할 기회가 없기 때문입니다.  
하지만 애자일 프로젝트에서는 지금 내가한 행동의 피드백을 10분 후, 한 시간 후, 하루 후, 일주일 후 등 여러 주기를 통해 지속적으로 얻을 수 있습니다. 그리고 그때 저지른 실수는 바로 다음 주기에서 교정할 수 있습니다.

-----  

# 자기계발은 복리로 돌아온다
자기계발이 왜 중요하다고 생각하냐면, 현재 나에게 무엇을 투자했느냐가 1년, 혹은 2년 후의 나를 결정한다고 느끼기 때문입니다.  
잡코리아와 비즈몬이 2006년 남녀 직장인 996명을 대상으로 조사한 직장인들의 자기계발 시간 통계 입니다.  
1~2시간 38.9%, 1시간 정도 27.8%, 2~3시간 14.8%, 30분 이하 12.0%, 3시간 6.5%  
잡코리아의 2012년 조사자료도 1~2시간이 압도적으로 많다는 점에서 큰 차이가 없습니다.  
1~2시간 54.1%, 1시간 미만 33.8%, 2~3시간 9.4%, 3시간 이상 2.8%  
하루 평균 1시간도 투자하지 않는 사람은 자기계발이란 면에서 직장인의 하위 ₩/3에 속하는 셈입니다.  
무서운 사실은 이게 축적이 되면 엄청난 차이를 만들 거라는 점이지요. 자기가 습득한 `지식이나 능력은 복리로 이지가 붙기 때문`입니다.

-----  

# 학습 프레임과 실행 프레임
"업무적으로 꼭 해야 하는 건 아니지만 당신이 도와주는 사람은 누구이고, 또 당신이 도움을 요청하는 사람은 누구입니까?" 연구에 따르면 업무 성과가 뛰어난 개발자들은 이 질문에 답을 더 잘할 수 있습니다.  
`"아직 1년도 되지 않아서` 책 보고 코드 보고 업무를 배워가는 중입니다. 그래서 딱히 누구에게 물어보지 않고 또 아직 업무 파악이 안 된지라 누굴 도와주거나 할 입장도 아닙니다."
`"아직 1년도 되지 않아서` 많이 물어보며 배유고 있습니다. A 선임, B 책임, ... 그리고 제가 공하고 싶은 내용을 주제로 팀 내 스터디를 운영하고 있습니다. 같이 공부해 가는 거지요. 제가 출퇴근 시간에 지하철에서 많이 봤던 모 프레임워크와 관련된 문제로 다른 팀원이 어려워하는 걸 우연찮게 알게 되었습니다. 그래서 도와드렸죠. `아직 1년도 안 되어서` 시간이 있으니까 적극적으로 다른 분들 일을 도와드리려고 나서고 있습니다. A선임, B 책임, ... "  

-----  

# 달인이 되는 비결
"달인이 되는 비결은 매우 단순합니다. ... 매일 세수하고 양치하듯이 꾸준하게 반복하는 것이 바로 그것입니다."  
꾸준한 반복으로 달인이 되려면 적어도  
1. `실력을 개선하려는 동기`가 있어야 하고
2. `구체적인 피드백을 적절한 시기`에 받아야 한다.  

-----  

# 수십 년 동안 전문가가 안 되는 비결
## 타당성과 피드백을 높이기  
일하는 방식, 개발하는 방식을 바꾸면 이 타당성과 피드백을 어느 정도 높일 수 있다. 그리고 전문성을 현재보다 좀 더 빨리 발전시킬 수 있다고 생각합니다.  
예컨대, 타당성을 높이려면 변수를 제한하고 실험을 하면서 규칙성과 인과관계를 찾으려는 노력을 하면 됩니다. 피드백을 높이려면 동료나 상사, 고객에게서, 혹은 내가 개발하고 있는 프로그램에서 직접 피드백을 적극적으로 구하면 됩니다.  

-----  

# 당신이 제자리걸음인 이유  
## 실력이 늘지 않는 이유  
의도적 수련의 필수 요건 중 하나가 `'적절한 난이도'`입니다.  
`자신이 업무 시간 중에 불안함이나 지루함을 느끼는 때가 대부분이라면, 실력이 도무지 늘지 않는 환경에 있다는 겁니다.` 더 무서운 건 점차 이런 환경에 익숙해지고 행동이 습관화된다는 점이죠. 그때는 자기 인식도 잘 되지 않습니다.  
\
## 지루함을 느끼는 경우: 실력 낮추기  
프로그래머의 예를 들자면, 평상시 즐겨 쓰던 보조 도구를 일부러 안 쓰는 겁니다.  
마우스를 즐겨 쓴다면 키보드로만 개발하려고 용을 써 보거나, 디버거를 늘 쓰는 경우 디버거를 안 쓰는 것이죠.  
\
## 지루함을 느끼는 경우: 난이도 높이기  
흔하게 쓰는 방법은 자기에게 요구되는 수준을 더 높게 여기는 겁니다.  
하루 만에 개발하라고 주어진 업무인데 지루한 느낌이 드니 한 시간 만에 할 수 있는 방법을 고안해 보기, 100rps(Request per Second, 초당 응답수)면 되는 시스템을 1,000rps 기준으로 만들기, 평소 코드를 검토할 때 버그를 시간당 하나 찾았다면 오늘은 두 개 찾기, 익숙한 작업을 새로운 언어로 진행해 보기 등.  
또 다른 방법으로는 공식적으로는 안 해도 되는 업무를 자신의 의지로 추가로 하는 경우가 있습니다. 보통은 자신의 업무를 개선하는 일인데요, 리팩토링을 하거나 자동화 테스트를 달거나, 혹은 자신만의 도구(혹은 방법)를 개발하거나 하는 것들이죠.  
\
## 불안함을 느끼는 경우: 실력 높이기  
실력을 어떻게 당장 올릴 수 있을까요. 크게 보면 사회적 접근과 도구적 접근, 내관적 접근 세 가지가 가능합니다.  
사회적 접근은, 나보다 뛰어난 전문가의 도움을 얻는 겁니다. 잘하는 사람한테 가서 짝 프로그래밍을 해당라고 부탁하거나 IRC(인터넷 채팅)에서 전문가의 도움을 얻는 것도 괜찮은 방법이고요. 괜찮은 튜토리얼 문서가 있다면 그 문서에서 보여주는 진행 순서대로 따라가 보는 것도 좋겠죠.  
도구적 접근은 다른 도구의 도움을 받는 겁니다. 내 능력을 확장시켜 줄 수 있는 도구들을 찾아 쓰면 됩니다. 예컨대 괜찮은 디버거, 자동 통합 도구, 코드 분석툴, REPL(Read-Eval-Print Loop, 프로그래밍 환경에서 프로그래머가 한 줄 입력하면 그걸 읽어서 평가하고 결과를 출력하는 걸 반복하는 구조)환경 등을 사용하거나 오픈소스 라이브러리를 빌려 쓰는 것도 좋은 방법입니다.  
내관적 접근은 비슷한 일을 했던 경험을 머릿속에서 되살려 보는 겁니다. 그때 그 일을 어떻게 했는지 떠올려 보면서 비유적으로 문제를 해결합니다. 보통 이런 과정을 거치면 자기효용감(self-efficacy)이 증대하면서 스스로 인식하는 자기 실력이 향상되기 쉽고, 결과적으로 몰입 영역으로 들어가기 좋죠.  
\
## 불안함을 느끼는 경우: 난이도 낮추기  
간단하면서 효과적인 방법은, 자신이 맡은 일의 가장 간단하면서 핵심적인 결과물, 즉 아기버전(혹은 0.0.1 버전)을 첫 번째 목표로 삼는 겁니다. 애자인에서 말하는 WTSTTCPW와 같습니다. 테트리스를 만들어야 하는데 불안함이 엄습해 온다면, 일단 화면 한가운데에 네모난 사각형 하나 그리기를 목표로 합니다. 그걸 완성하면 난이도를 조금 올려서, 좌우 화살표를 누르면 방향에 따라 그 사각형이 움직이게 합니다. 이때 주의할 것은 자료구조나 회전 알고리즘을 먼저 완성하는 게 아니라는 점입니다. 테트리스의 핵임은 살아 있으면서도 간단한, 아기 버전의 테트리스틑 만드는 것입니다.

-----  

# 프로그래밍 언어 배우기의 달인  
## 튜토리얼(개별 작업 단위보다 더 큰 목표를 달성하기 위한 방법)을 읽는 것 자체는 다른 프로그래머랑 비슷해 보입니다.  
여기에 차이가 있다면 읽을 때 다음 작성할 프로그램을 염두에 둔다는 점입니다. 그래서 튜토리얼을 읽다가도 이 정도면 그 프로그램을 작성할 수 있겠다는 생각이 들면 그 자리에서 읽기를 멈추고 코딩을 시작합니다.  
프로그램을 완성하면 잠시 멈췄던 자리로 돌아와서 읽기를 계속합니다. 이때에는 다음 프로그램을 목표로 두면서 말이죠. 이런 것을 `적극적 읽기`라고 합니다. 무언가를 읽을 때 구체적인 질문이나 목적을 가지고 있는 방법을 말합니다.   

-----  

# 실수는 예방하는 것이 아니라 관리하는 것이다.  
## 두 가지의 실수 문화  
마이클 프레제(Michael Frese)는 회사에서의 실수 문화에 대해 연구를 했습니다. 그에 따르면 실수 문화에는 크게 두 가지가 있습니다. 실수 예방과 실수 관리.  
실수 예방은 행동에서 실수로 가는 경로를 차단하려고 합니다. 즉, 실수를 저지르지 말라고 요구합니다. 근데, 사실 이것이 불가능에 가깝습니다. 전문가도 1시간에 평균 3~5개의 실수를 저지른다고 합니다.  
그런데, 왜 우리 세상은 그렇게 엉망이 아닐까요? 그것은 전문가들이 실수를 조기에 발견하고 빠른 조치를 취할 수 있기 때문입니다. 이렇게 "실수는 어떻게든 할 수밖에 없다. 대신 그 실수가 나쁜 결과로 되기 전에 일찍 발견하고 빨리 고치면 된다."는 겁니다. 이 태도를 실수 관리라고 합니다. 사실 하나의 결로가 더 있는데, 이미 결과가 난 실수에 대해서는 학습을 통해 "다음 행동할 때 이렇게 하자"는 계획을 세우기도 합니다.(이를 2차적 실수 예방이라고 함)  
실수 예방 문화에서는 실수를 한 사람을 비난하고, 처벌하고, 따라서 실수를 감추고 그에 대해 논의하기 꺼리며 문제가 생겼을 때 협력도 덜하게 됩니다. 실수에서 배우지 못하겠지요.  
반대로 실수 관리 문화에서는 실수가 나쁜 결과를 내기 전에 빨리 회복하도록 돕고, 실수를 공개하고, 실수에 대해 서로 이야기하고 거기에서 배우는 분위기가 생깁니다.  
이 부분이 굉장히 중요합니다. 실수 연구의 역사를 보면, 초기에는 기술적인 부분만 보다가 그 다음에는 인간적인 부분(결국 80%가 사람실수)을 보다가(특히 1979년 쓰리마일섬의 사고가 계기가 되었음),  
이제는 문화적인 부분(컬럼비아호 사고가 계기가 되었음)을 이야기 합니다. 심리적 안정감이라고 하는 것이 이 문화의 일부입니다.  

-----  

# 나홀로 전문가에 대한 미신  
보통은 어떤 사람이 전문가라고 하면 그 사람의 뇌 안에서 무슨 일이 벌어질까에만 주목하는 면이 있습니다. 때로는 '고독한 천재'같은, 전문지식은 뛰어나지만 사회성은 부족한 사람을 전문가의 대표 이미지로 떠올리기도 하죠. 그런데 현실에서의 전문가가 정말 그런 사람일까요?  
테스트 주도 게발(Test-Driven Development, TDD)이라는 프로그래밍 기법의 전문가를 예로 들어봅시다.  
TDD가 뭔지 모르시는 분들은 그냥, 컴퓨터 프로그래밍을 더 효과적으로 하게 도와주는 프로그래밍 방식이라고 생각하면 됩니다.  
일반적인 TDD 교육을 통해 사람들이 기대하는 과정은 보통 이럴 것입니다.  
1. TDD를 제대로 이해하고 조직에 돌아간다.
2. 나 스스로 TDD를 제대로 실천해서 객관적 성과를 낸다.
3. TDD가 좋다고 사람들을 설득한다.
4. TDD를 가르쳐 준다.
5. 모두가 TDD를 열심히 한다.
6. 좋은 성과를 낸다.

여기에서 보통 문제가 되는 부분은 3, 4, 5, 6번 입니다. 그리고 1과 2를 잘한다고 해서 3번 이후가 꼭 쉬워지는 것이 아닙니다.  
하지만 교육에서는 통상 1번에만 집중을 합니다. 이럴 경우, 실무로 돌아갔을 때 흔히 접하는 문제는 예컨대 다음과 같습니다.

- 회사로 돌아가서 실무에 적용하려고 하는데 상사나 동료의 지원 없이 추가적으로 일을 하려니, 시간이 모자라 계속 미루게 되어 결국 적용하지 못한다.  
- 팀원, 팀장들에게 전파 교육을 하려 하지만 팀원, 팀장들 가운데 몇몇은 추가 업무를 왜 하는지 필요성도 못 느끼는 상태에서 강제로 해야 한다는 스트레스를 받아서 부작용이 생긴다.(그래서 결과적으로 해당 기법은 실무에 써먹을 수 없다는 평가가 나온다.)  
- 배운 것을 팀 내에서는 열심히 적용했으나 지원해주는 임원이 없어 확대하는 데 실패하고, 조직 내에서는 한 팀의 별난 문화로 차부되어 실행범위가 축소된다.  
- 배운 대로 팀에서 실천했더니 "다른 부서는 그런 거 없이도 잘하는데 너희는 왜 그런 거 하면서 제때 아웃풋이 안 나오냐"며 이해할 수 없다고 말하는 상사나 협력 팀의 리더와 갈등을 겪는다.  
- 기술적으로 어떻게 해야 할지 모르겠는데, 주변에 물어볼 사람이 없어 인터넷 검색하느라 몇 시간씩 보낸다. 하지만 결국 원하는 정보를 찾지 못해서 적용을 포기한다.  
- 회사에서는 여력이 없어 배운 것을 집에서 시도해 보려 했더니, 가족들의 여러 요구로 인해 집중할 수 없어 화를 내거나, 가족의 요구대로 하느라 내가 할 일은 시작도 못 하거나, 그냥 포기하고 잠을 자게 된다.  

이런 문제들은 보통 사회적 측면에 대한 것입나다.  
왜 이것이 중요할까요? 뭘 하든지 나 혼자가 아니라 항상 누군가가 등장하고, 일의 성패에 다른 사람이 관련되어 있기 때문입니다.  

이제까지의 말을 정리하자면 다음과 같습니다.  
1) 아무리 기술적인 실천법이라고 해도  
2) 그 기술은 사회적 맥락속에서 실천되어야 하며  
3) 그 기술의 성공을 위해서는 사회적 자본과 사회적 기술이 함께 필요하다.  

하지만 안타깝게도 현실에서는 `팀원들이 맘에 안들고, 그들도 나를 맘에 들어 하지 않는 상황, 즉 사외적 맥락이 나쁜 상황에서 타개책으로 TDD의 기술적 측면만 매몰되는 경우`가 있습니다. 사실 그런 상황에서는 무엇을 골라도 실패가 보장되어 있습니다.  
너무도 중요하기 때문에 다시 한번 반복하겠습니다.  
`어떤 기술적 실천법이라도 그걸 현실에서 적용하기 위해서는 사회적 자본과 기술이 필요`합니다. 설사 나 혼자 하는 실천법이라고 해도 말이죠.  
예컨대 상사가 내가 하는 일을 보고 반대하면 그를 설득해야 하며, 하다가 모르는 것이 생기면 주변에 물어봐야 하므로.  

## 사회적 자본과 기술  
그렇다면 이토록 중요한 사회적 자본과 기술은 대채 무엇을 말하는 걸까요?  
응용통계학자 출신인 존 카트맨(Gottman, John M)은 자신의 책 < The Science of Trust > (신뢰의 과학) 에서 다음 연구를 인용합니다.  
신뢰가 깨져 있는 맞벌이 부부가 있었습니다. 하루는 남편이 일찍 퇴근을 했습니다. 싱크대에 그릇이 쌓여 있는 걸 보고는 남편은 웬일인지 설거지를 합니다. 여기까지를 몰래카메라로 촬영해서 제삼자에게 보여주면 대부분 남편이 선의의 행동을 했다고 평가를 내립니다.  
반전은 부인이 집에 들어오면서부터입니다. `부인은 남편에게 화를 냅니다` "집안일을 제대로 안 한다고 항의하려는 거냐", "나보고 좀 이렇게 하라는 뜻이냐" 등등.   
사트맨은 이 상황을 이렇게 풀이합니다.  
`신뢰가 깨어져 있는 상태에서는 어떤 행동을 해도 악의적으로 보인다`는 것입니다.  

직장에서도 비슷한 예를 들 수 있습니다.  
팀장이 선의로 팀원들에게 책을 선물합니다. 그런데 팀장과 팀원 사이의 신뢰는 이미 깨져 있는 상태입니다. 그러면 팀원들은 팀장의 행동을 악의적으로 느낄 수도 있습니다. "나 보고 이런 거 모르니 공부하라는 얘기야? 자기는 쥐뿔도 모르면서..."라고 생각할 수 있는 것이죠.

이 신뢰를 `사회적 자본`의 일종이라고 합니다.  
소위 말하는 사회 연결망도 사회적 자본의 일종입니다. 사회적 자본이 좋은 사람들은 통상 사회적 기술이 뛰어납니다. 쉽게 말하면 신뢰 구축을 보다 잘하는 사람이겠죠. 반대로 사회적 기술에서 '음의 기술'을 가진 사람도 존재합니다. 예컨대, 커뮤니케이션할수록 신뢰가 깨지는 사람을 말하죠.  

## 고독한 전문가라는 미신  
전문가가 해당 도메인 지식만 뛰어난 사람이라는 것은 대표적인 미신입니다. `전문가는 사회적 자본과 사회적 기술 또한 뛰어납니다.`  
벨 연구소는 수십 년에 걸쳐 '뛰어난 연구자'의 특성에 대해 연구했습니다.  
그 결과 뛰어난 연구자와 그렇지 않은 연구자를 가르는 결정적인 요인 중 하나는 사회적 자본, 특히 소셜 네트워크의 차이였습니다.  
뛰어난 연구자는 같은 부탁을 해도 `훨씬 더 짧은 시간 안에 타인의 도움을 얻었습니다.`  
최근에 소프트웨어 공학에서 이뤄진 연구의 결과도 비슷합니다. `뛰어난 소프트웨어 개발자일수록 타인과 인터랙션에 더 많은 시간을 쓰며,` 초보 개발자들에게 조언을 할 때 사회적인 측면(예컨대 "모르면 주변에 물어봐라", "남을 도와줘라" 등)이 포함됩니다. 기술적인 조언만 하는 게 아니라는 뜻 입니다.  

특히, 이 초보 개발자에게 해줄 조언 부분이 재미있습니다.  
한 연구에서는 경력이 있는 개발자들에게 특정 문제를 해결할 때 초보 개발자에게 해 줄 조언을 적어보라고 했습니다.  
평균 7년 경력의 개발자들이었는데(경력과 실력은 상관성이 없었음) `뛰어난 개발자들은 약 70%가 동료와의 협력을 언급하는 반면, 실력이 그저 그런 개발자들은 20%도 안 되는 사람들만이 동료와의 협력을 언급`했습니다. 이 정도면 차이가 꽤 크니 면접에서 개발자의 실력을 가릴 때 이용하면 도움이 될 수 있겠죠.  

사회적 자본과 기술이 그렇게 중요하다면 왜 개발자를 포함한 다른 이들은 학교에서 그걸 배우지 못했을까요? 그것은 전문가에 대한 잘 못된 모형 때문입니다.  
전문가를 혼자서 일하는 고독한 천재 같은 걸로 오해하는 거죠. 기존 전문성 연구(Expertise Research)들은 통상 연구비를 낮추고 변수를 줄이기 위해서도 개인을 골방에 넣고 그의 독자적 행동과 선택을 연구했습니다. 이런 연구에서 나온 전문가, 비전문가의 차이로 전문가 이미지가 형성되었고, 교육 과정도 거기에 기반해 짜여진 것이 아직도 많습니다.  

2000년대 들어오면서 연구자들은 소프트웨어 전문가들이 사회적 작용을 하는 좀 더 현실적인 상황에서(주로 더 많은 사람이 동시에 참여) 어떤 행동을 하는지 연구를 했고, 기존 연구들의 결과가 뒤집어졌거나 새로운 요인이 발견된 경우가 많았습니다. 대표적인 것이 소프트웨어 전문가에게 있어 사회적 자본과 기술이 중요하게 대두된 것이지요.  
예전에는 소프트웨어 개발 소프트웨어 개발 전문성과 사회성은 별개로 치부되어 "프로그래밍 실력은 좋은데 의사소통 능력은 부족하다"든가 하는 이야기를 했다면, 이제는 프로그래밍을 잘한다는 정의 안에 의사소통 능력을 그 일부로 보게 된 겁니다.  

그럼에도 아직 대중에게는 이런 전문가 연구의 변화가 충분히 전파되지 않은 것 같습니다.  
그래서 `사회적 자본과 기술이 없이 해당 도메인 지식만 배우게 됩니다.` 그러니 배우도 못 하는 수밖에요. 한걸음 더 나아가 그런 사회적 자본과 기술이 없는 상황에서 도메인 지식만 높으면 해당 지식의 확산과 성공에 오히려 장애가 되기도 합니다. 희망적인 소식은 이런 사회적 기술을 훈련으로 개선할 수 있다는 겁니다.  
FBI나 미 특수부대, 심리 상담, 리더십 등의 영역에서 그 효과에 대한 실증적 연구가 이미 많이 이루어졌습니다.  

사회적 기술을 훈련한다는 게 막막하게 느껴지기도 합니다.  
그렇다면 지금 당장 개인이 실천할 수 있는 게 있을까요? 간단한 방법은 주변 사람들과 매일 주고받는 마이크로 인터랙션(인사 주고받기, 지나가는 대화, 물어보기 등 일상적이고 소소하고 빈번한 상호작용을 말합니다.)에 신경을 쓰는 겁니다. 그걸 기록하고, 복기하고, 다르게 인터랙션한다고 하면 어떻게 했으면 좋았을까를 생각해 보는 것만으로도 훈련이 될 수 있습니다.  

> `어떤 기술적 지식을 전달한다고 해도 그것을 사회적 맥락 속제서 가르치고 경험하게 하려고 노력하고 있습니다.`  
(도움받기, 피드백 주고받기, 영향력 미치기, 가르치고 배우기, 위임하기 등)  

> 한 분이 자신이 속한 조직의 형상 관리 도구를 서브버전(subversion)에서 깃(git)으로 성공적으로 안착시킨 사례를 이야기하고 있었습니다.  
잘 아시겠지만 조직의 형상 관리 시스템을 바꾼다는 것은 그리 쉬운 일이 아닙니다. 상대적으로 낮은 직급에서 이런 조직적 전환을 만들었다니 더 놀라운 일이었죠.  
사례 공유가 끝나자 청중 한 분이 손을 들고 묻더군요. "이해가 되지 않습니다. 저 역시 그렇게 하려고 깃의 장점에 대한 발표도 하고 교육도 몇 번에 걸쳐 해줬는데 결국 사람들이 쓰게 하는데에 실패했습니다. 사람들이 너무 수동적이고 보수적이에요" 발표자가 뭐라고 답을 했던 것 같은데, 옆에서 지켜보던 제가 호기심이 생겨서 질문하셨던 분과 발표자에게 각기 동일한 질문을 드렸습니다.  
`"그 조직원들이 선생님을 좋아하나요?"` 질문자와 발표자가 상반된 답을 했으리라는 건 여러분도 짐작할 수 있지 않을까 하네요.  

----- 





